{"meta":{"title":"Lynx-Blog","subtitle":null,"description":null,"author":"Keefe Wang","url":"http://keefe.wang"},"pages":[{"title":"About","date":"2017-05-15T02:02:29.000Z","updated":"2017-10-09T07:13:05.000Z","comments":true,"path":"about/index.html","permalink":"http://keefe.wang/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-05-15T01:58:51.000Z","updated":"2017-10-09T07:13:05.000Z","comments":true,"path":"categories/index.html","permalink":"http://keefe.wang/categories/index.html","excerpt":"","text":""},{"title":"welcome","date":"2017-05-18T14:44:39.000Z","updated":"2017-10-09T07:13:05.000Z","comments":true,"path":"welcome/index.html","permalink":"http://keefe.wang/welcome/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-05-15T01:54:35.000Z","updated":"2017-10-09T07:13:05.000Z","comments":true,"path":"tags/index.html","permalink":"http://keefe.wang/tags/index.html","excerpt":"","text":""},{"title":"html editor","date":"2021-01-27T02:24:00.000Z","updated":"2021-01-27T02:25:01.914Z","comments":true,"path":"editor/index.html","permalink":"http://keefe.wang/editor/index.html","excerpt":"","text":""},{"title":"","date":"2021-01-27T03:03:56.331Z","updated":"2021-01-27T03:03:56.331Z","comments":true,"path":"editor/index.html","permalink":"http://keefe.wang/editor/index.html","excerpt":"","text":"HTML Editor html { height: 100%; padding: 0; margin: 0; } body { display: flex; flex-direction: column; height: 100%; padding: 0; margin: 0; } textarea { border: 1px solid black; box-shadow: 0px 0px 5px rgba(0,0,0,0.2) inset; padding: 10px; resize: none; color: #333; width: calc( 100% - 20px ); height: 300px; margin: 15px 0; border: 0; } textarea:focus { outline: none; } iframe { margin: 0; border: 0; height: 300px; } .iframe::-webkit-scrollbar-track { -webkit-box-shadow: inset 0 0 8px rgba(0,0,0,0.3); background-color: #efefef; } .iframe::-webkit-scrollbar { width: 8px; background-color: #F5F5F5; } .iframe::-webkit-scrollbar-thumb { background-color: fe4365; } .controls { background-color: #000; border-top : 1px solid #808080; border-bottom: 1px solid #808080; padding: 12px; white-space: nowrap; overflow-x: auto; min-height: 23px; } .controls input[type=\"checkbox\" i]:checked { background-color: #fe4365; cursor: default; appearance: checkbox; box-sizing: border-box; margin: 3px 3px 3px 4px; padding: initial; border: initial; } .controls a, .controls label { background-color: #fe4365; text-decoration: none; color: #000; user-select: none; margin-right: 15px; padding: 6px 15px; cursor: pointer; } .controls a:hover, .controls label:hover { color: #fe4365; background: #f0f0f0; text-decoration: none; transition: all .2s; } body { padding: 50px; } span { display: inline-block; background: #fe4365; color: white; padding: 20px; } 在这里编辑代码，下方查看代码运行的结果~ 运行 新页面打开 function update() { let outty = window.hello.document; outty.open(); let inny=document.getElementById(\"data\"); outty.write(inny.value); outty.close(); }; function goFullscreen(newWin) { if (newWin) outWin= window.open() else outWin= window.open(\"about:blank\",\"html_editor\"); outWin.focus(); let outty = outWin.document; outty.open(); let inny=document.getElementById(\"data\"); outty.write(inny.value); outty.close(); } function realtime(){ if (!document.querySelector(\"#realtime\").checked) return; update(); } dataArea=document.getElementById(\"data\"); dataArea.onkeyup=realtime; update();"}],"posts":[{"title":"[翻译]浏览器怎样渲染一个页面？—— DOM，CSSOM及其渲染","slug":"2020-08-13-translate-how-browser-renders-webpage","date":"2020-08-13T14:02:03.000Z","updated":"2021-01-21T13:21:25.611Z","comments":true,"path":"2020/08/13/2020-08-13-translate-how-browser-renders-webpage.html","link":"","permalink":"http://keefe.wang/2020/08/13/2020-08-13-translate-how-browser-renders-webpage.html","excerpt":"","text":"转自笔记 https://www.notion.so/DOM-CSSOM-64405971e5654db28a44c7d741a22a00 在网页开发的过程中，影响用户体验的因素有很多，大部分归咎于资源加载速度慢、初始页面渲染时加载非必须的文件（甚至会出现没有样式的文档）等等。为了避免这些问题的产生，我们需要理解浏览器渲染一个特定的网页的整个周期和流程。 首先，我们需要搞清楚什么是 DOM。当一个浏览器向服务端请求一个 HTML 文档，服务器会将这个 HTML 文档以二进制形式的数据（一个带着 Content-Type = &#39;text/html; charset=UTF-8&#39; 的text 文件）进行响应。这其中， text/html 是一种 MIME 类型（MIME 能够告诉浏览器这是一个 HTML 文档，并且字符编码是 UTF-8）。有了这个信息，浏览器就能将二进制文件转换成一个可理解的文本文件，如下图所示 如果这个响应头丢失，那么浏览器将无法对文件进行解析和渲染。当一切就绪，浏览器就可以对 HTML 文档进行解析。HTML 文档的样子通常如下图所示 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Rendering Test&lt;/title&gt; &lt;!-- stylesheet --&gt; &lt;link rel=\"stylesheet\" href=\"./style.css\"/&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;p&gt;This is a sample paragraph.&lt;/p&gt; &lt;/div&gt; &lt;!-- script --&gt; &lt;script src=\"./main.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在上面的 HTML 文档中，网页主要依赖 style.css 文件来给 HTML 元素提供样式，依赖 main.js 来进行一些 JavaScript 脚本代码的执行。有了 CSS 样式，我们的页面看起来会非常棒 但我们还是没有聊到重点——浏览器是如何将一个漂亮的页面从一个简单的只充满了文本 HTML 文件渲染出来的呢？接下来我们就聊聊 DOM、CSSOM 和渲染树（Render Tree）。 DOM（Document Object Model）当浏览器解析 HTML 代码时，遇到像 html、body 和 div 等等的标签，会创建一个称作节点（Node） 的JavaScript 对象。最终，所有的 HTML 元素都会被转换成这样的节点。 HTML 元素都会有自己不同的属性（properties），相应的，节点对象会从不同的类被构造出来。例如 div 元素会被创建为一个 HTMLDivElement 类的节点实例（继承于 Node 类），如下图 浏览器有很多这样内置的类，例如 HTMLDivElement、HTMLScriptElement 和 Node 类等等。 当浏览器解析完 HTML 文档并相应的创建出许多的节点后，还会将这些节点构建成为一个树状结构（如下图）。就想 HTML 文档中元素都是相互嵌套的，浏览器也需要相应的把这些节点构建成类似的嵌套的结构。这种结构会让浏览器更加高效的渲染和操作。 DOM 树的结构就如上图所示。一棵 DOM 树由 html 元素节点开始，其中的其他元素像树枝和叶子一样被层层嵌套（在 HTML 文档解析过程中，每当遇到一个 HTML 元素，就会从相应的节点类中构造出一个 DOM 节点并添加在 DOM 树上）。 DOM 节点并不总是 HTML 元素。当浏览器构建 DOM 树时，也会将注释、属性（attributes）和文本等保存成树上的节点。为了整个流程的简单描述，文中的节点我们都认为是由 HTML 元素创建的节点。点击这里查看所有的节点类型。 你可以在谷歌浏览器的 Devtools 控制台中可视化地查看 DOM 树的层级（如下图）。 JavaScript 是无法理解 DOM 是什么东西的。DOM 是浏览器为了搞笑渲染网页而向开发者暴露的 Web API，让开发者可以动态的去操作这些 DOM 元素。 开发者能够使用 DOM API 来进行 HTML 元素的添加和删除，改变其样式，为其绑定一些事件监听器。使用 DOM API 还能够在内存中人工创建和复制一些 HTML 元素，而不受已经渲染好的 DOM 树的影响。这些特性都让开发者为了提升用户体验而更好地开发动态网页。 CSSOM（CSS Object Model）在设计一个网页时，我们会尽可能地让网页看起来更加美观。我们会在 HTML 元素中添加 CSS 样式来达到此目的。CSS 选择器让我们能够对选定的 DOM 元素设置类似 color 或 font-size 等的样式属性。 为元素添加样式有很多方法，有直接向 HTML 元素中添加样式（内联样式），或在 HTML 文档中添加 标签并在其中添加一些样式，也可以引入一个外部的 CSS 文件。最终，将 CSS 样式添加到 DOM 元素这个重担还是要落在浏览器身上。 针对上面提供的 HTML 文档，我们采用下面的 CSS 样式来进行美化。 1234567891011121314151617181920212223html &#123; padding: 0; margin: 0;&#125;body &#123; font-size: 14px;&#125;.container &#123; width: 300px; height: 200px; color: black;&#125;.container &gt; h1 &#123; color: gray;&#125;.container &gt; p &#123; font-size: 12px; display: none;&#125; DOM 树构建完成后，浏览器将读取资源（外部的、内联的、HTML文档中的和用户代理）中的 CSS 样式文件，并构建出一个 CSSOM 树。CSSOM 意为 CSS Object Model，就和 DOM 树一样都是树结构。 在 CSSOM 树上，每一个节点都是针对一个 DOM 元素所包含的样式。而且，CSSOM 树不像 DOM 树（、等）一样能够被打印在屏幕上。 用户代理样式，是大部分浏览器自带的一些样式表。浏览器在计算 CSS 样式属性时，会首先加载用户代理样式，然后会将开发人员提供的样式表（根据一定的 CSS 优先级规律）进行覆盖，来构造出每一个节点。 即使有的 HTML 元素没有用户代理和开发者提供特定样式，样式的默认值也会根据 W3C CSS 标准进行默认赋值。而一些元素的属性也会继承逐步继承这些默认的属性值。 例如，color 和 font-size 属性如果没有进行任何值的指定，他们会继承父元素的属性值。所以我们能够想象这些样式都是一层层进行继承和覆盖。这就是为什么样式表被称之为 CSS（cascading style sheets），这种规则也是浏览器能构建出 CSSOM 树的原因。 你能使用谷歌浏览器的 DevTools 控制台的 Elements 面板，在左侧选中一个 HTML 元素，点击后能够在右侧的 computed 面板中看到相应的样式计算结果。 我们将之前例子中的 CSSOM 树可视化为下面的图表。 如上图所示，CSSOM 树是不包含能够打印出来的元素和标签的。上面红色的 CSS 属性和值就是从 body 元素上面的样式继承而来的，而 h1 标签的 color 属性则覆盖了其父元素 div 中的 color 属性。 Render Tree渲染树也是一个树形结构，它结合了 DOM 树和 CSSOM 树。浏览器接下来需要计算每一个可见元素的布局并将其绘制在屏幕上，为了达到这一目的，浏览器需要用到 Render Tree。而 Render Tree 又是由 Dom 和 CSSOM 树得到的。 由于渲染树是能最终在屏幕上打印出的底层表示，它不会包含任何不包含像素矩阵面积的节点——例如使用了 display: none 样式的元素，这样的元素是不会出现在渲染树上的。 如上图所示，渲染树结合了 DOM 树和 CSSOM 树来构建出一个树形结构，这个树结构只包含能够最终绘制在屏幕上的元素。 上面代码中的 p 元素由于被设置了 display: none 样式，所以这个元素以及该元素的子元素都不会呈现在渲染树中，因为它不占任何屏幕空间。但是有一些例外，比如被设置了 visibility:hidden or opacity:0 样式的元素，他们虽然没有占据任何屏幕空间，但是仍然会被添加到渲染树上。 和 DOM API 能够让开发者去操控 DOM 元素不同，CSSOM 是被隐藏起来的，但由于渲染树结合了两者，所以浏览器通过提供高级的 DOM 上的 API 来暴露出 CSSOM 节点，这让开发者能够去操作和修改 CSSOM 节点的 CSS 属性。 本文不讨论怎样使用 JavaScript 脚本去操作元素的样式，这里仅提供描述了 CSSOM API 的链接 CSS Tricks Article。CSS Typed Object 一文提供了在 JavaScript 中更精确地操作元素样式属性的 API。 渲染流程现在我们对 DOM，CSSOM 以及渲染树都有了一定的了解，接下来我们将揭露浏览器如何对一个网页进行渲染。对这个流程有一个简单的了解会让网站开发者提升网站的用户体验有极大的作用。 当一个页面加载时，浏览器首先会扫描 HTML 文档并构建出 DOM 树，然后会处理 CSS 文件（无论是内联还是外部的文件）并构建出 CSSOM 树。 当 DOM 树和 CSSOM 树构建出来之后，浏览器会结合两者来构建出渲染树。一旦渲染树构建完成，浏览器就能把每一个元素绘制在屏幕上。 布局（layout）首先，浏览器会计算出每一个渲染树节点的布局。这里所说的布局包括这个节点的像素大小、以及绘制位置。这个过程被称作“布局（layout）“，有些时候也会被称作是回流（reflow）或浏览器回流（browser reflow）。回流是在用户进行滚动、缩放浏览器或操作 DOM 元素时会触发的。这里列举了一系列能够触发回流的事件和操作。 我们应当避免网页出现过多的布局和回流，因为这是一个极其消耗性能的操作。Paul Lewis 的文章讲述了一些如何避免复杂和消耗性能的操作。Layout thrashing 一文也可供参考。 绘制（paint）目前我们已经有了一系列需要打印在屏幕上的文字和图案。由于渲染树上的元素有可能会彼此覆盖，甚至会有一些 CSS 属性让这些元素频繁的更改样式、位置等（例如动画），浏览器为此创建了图层（layer）。 图层让浏览器能够高效地进行绘制，无论是在网页上滑动还是缩放浏览器窗口。图层也能帮助浏览器正确地把元素以层叠的方式（开发者所需要的）进行绘制。 现在浏览器能够结合图层，将元素绘制在屏幕上了。但是，浏览器是不会一次性把所有图层绘制出来的，每一个图层都是有先后的绘制顺序。 在每一层中，浏览器会填充每一个可见属性的像素点（例如边框、背景颜色、阴影和文字等）。这个过程也被称作栅格化。为了提升性能，浏览器会使用不同的线程来进行栅格化操作。 这里的图层就像是 Photoshop 软件中的图层。你可以在 Chrome DevTools 中查看每一个不同的图层。打开 Chrome DevTools，在 more tools 选项中选择 Layers 标签。能够在 Rendering 面板上看到每一个层的边界。 栅格化一般都是由 CPU 来执行的，所以速度慢且成本高，但是现在出现的 GPU 技术能够很大程度提升这一步骤的性能。这篇 intel article 文章详细概括了绘制流程（尽量去阅读它！）。为了能够更加深入地理解图层，你需要查看这篇文章。 渲染层合并（compositing operation）到现在，我们还没有在屏幕上绘制出任何一个元素。但是我们现在有了能够按照一定顺序绘制在屏幕上的一系列不同的图层。在渲染层合并这个流程里，这些图层将被送往 GPU 进行最终的绘制。 将所有的图层一起进行传输显然是低效的，因为每一次回流和重绘都需要全部发送一遍。所以每一个图层都被拆解为不同的块（tiles），这些块才是能够最终被绘制在屏幕上的单元。在 Chrome DevTools 的 Rendering 面板中也能够看到这些块。 上面画出了目前为止的所有渲染流程，也被称作 critical rendering path 。 Mariko Kosaka 写过一篇文章来详细讲述这一流程中的每一个概念（极力推荐） 浏览器引擎DOM 树、CSSOM 树以及控制整个渲染的逻辑都是在一个被叫做浏览器内置的浏览器引擎（Browser Engine)（也被称作是渲染引擎或布局引擎）。这个浏览器引擎包含了所有将 HTML 文档渲染成为屏幕上的像素点所必须的元素和逻辑。 你听说过 WebKit 吗，这就是一个浏览器引擎。WebKit 是在苹果的 Safari 浏览器中，也是之前谷歌 Chrome 浏览器默认的渲染引擎。现在 Chromium 项目已经开始用 Blink 作为 Chrome 浏览器默认的引擎。这是一系列不同的浏览器对应的引擎。 浏览器的渲染过程众所周知 JavaScript 是一种符合 ECMAScript 标准的语言，事实上由于 JavaScript 已经被注册为商标，我们现在都称其为 ECMAScript。所以，任何一种 JavaScript 引擎（包括 V8，Chakra，SpiderMonkey）都需要遵守这一标准。 这一标准让所有的 JavaScript 运行时环境（浏览器、Node、Deno等）一致的体验。这让 JavaScript 能够在多平台进行统一的应用开发。 然而浏览器渲染页面却很难提现这样的一致性，因为 HTML、CSS 和 JavaScript，这些语言都有自己独有的标准。所以 Chrome 和 Safari 浏览器在渲染流程上就有所不同。因此我们很难去预测不同浏览器背后所支持的渲染流程。但是 HTML5 规范对理论上如何渲染做出了一些努力，但是是否遵循这一规范不同的浏览器厂家也各有不同。 不管上面所提到的不同点，所有的浏览器在渲染过程其实遵循的规则大体上通常是一致的。我们这里就来了解一下浏览器渲染流程周期中共通的一些事件。为了更好地理解这个过程，下面准备了一个小的工程来测试不同的渲染场景。 course-one/browser-rendering-test 解析文档解析是扫描 HTML 文档内容并构建 DOM 树的一个过程。所以这个解析也被称作是 DOM 解析，执行解析的程序被称作 DOM 解析器。 大多数浏览器都会提供 DOMParser Web API 来将 HTML 文档构建成 DOM 树。一个 DOMParser 类的实例代表一个 DOM 解析器，这个解析器使用 parseFromString 原型方法来将 HTML 文本解析成 DOM 树结构。 当浏览器向服务器请求并返回了一个 HTML 文档时，浏览器就可以开始解析这个文档。因此浏览器能够逐步地构建 DOM 树，一次构建一个节点。浏览器是从上到下地扫描 HTML 文档。 上图展示了在 Node 服务器上以 10kbps 的速度请求 incremental.html 文件。因为这个请求获取文件的过程需要很长一段时间，浏览器加载这个文件从一开始的一小部分代码就能够不断地增量渲染出节点。 如果你在 Chrome DevTools 中的 Performance 面板中查看上述请求，能够看到每一步流程的时序。这些事件都被称作是性能指标，当这些事件能靠的很近，那么说明用户体验会很好。 使用⟳按钮可以将某一个性能档案进行捕捉。 FP 代表着 First Paint，意思是浏览器开始绘制。FCP 代表着 First Contentful Paint，意思是浏览器开始绘制第一个像素点。LCP 代表着 Largest Contentful Paint，意思是浏览器渲染一大块文本或图像的时间。 你可能听过 FMP，代表着 First Meaningful Paint，与 LCP 指标类似，但是已经被 Chrome 弃用了。 L 代表着 onload 事件（浏览器在 window 对象上所触发的事件）。DCL 代表着 DOMContentLoaded 事件（在 document 对象上触发但是会冒泡到 window 对象）。因此可以监听 window 对象。这些事件有一些复杂，我们会简单介绍一下。 每当浏览器扫描到了外部的资源，比如一些 标签标示的脚本文件（JavaScript文件）或 引入的样式文件，亦或是图片元素，浏览器会开始在后台下载这些资源（而不是 JavaScript 执行的主线程）。 最重要的一点是要记住——DOM解析通常是在主线程上进行的。所以当 JavaScript 主线程忙时，DOM 解析会被挂起直到线程空闲。为什么 JavaScript 会阻塞 DOM 的解析？那是因为脚本元素是解析阻塞的（脚本会影响 DOM 树的生成），而样式表、图片、pdf和视频等静态资源文件则不会阻塞。 阻塞解析脚本阻塞解析脚本指的是会让 HTML 文档解析阻塞的脚本文件。当浏览器遇到 script 标签时，如果是嵌入式脚本，脚本会被立即执行然后再继续解析 HTML 文档来构建 DOM 树。 如果遇到的 script 标签是一个引入的外部脚本文件，浏览器会在后台非主线程上开始下载这个脚本文件，在下载过程中，主线程的任务也是被暂时挂起的。在外部脚本没有下载完成之前，DOM 解析不会开始。 一旦脚本文件下载完成，浏览器会在首先主线程上执行这个脚本文件，然后开始 DOM 解析。浏览器再遇到相同的脚本标签，也会重复这一过程。为啥要这么做呢？这是因为浏览器将 DOM API 暴露给 JavaScript 运行时，这意味着我们可以使用 JavaScript 脚本来操控 DOM 元素。这也是 React 和 Angular 这些框架能够动态改变网页的原因。但是如果浏览器并行地解析 DOM 和执行脚本，可能会存在条件竞争漏洞（不知道到底哪个最终会影响 DOM 树的生成）。 但是很显然，在脚本下载的过程中暂停 DOM 的解析也是非常没有必要的，所以 HTML5 为 script 标签新增了 async 属性——当浏览器遇到了带有 async 属性的 script 标签，不会暂停解析过程并在后台下载脚本文件，但是当文件下载完成，解析过程会被挂起直到脚本被执行完。 另外，HTML5 还提供了 defer 属性，有点类似 async 属性，不同的是这种脚本在下载完成之后也不会立即执行。所有带 defer 属性的 script 标签，都会在后台并行下载，等到 HTML 解析完成，DOM 树构建完成，这些脚本才会被执行。 所有其他正常的 script 标签代表的脚本，都是阻塞解析的脚本。所有 async 脚本都是下载期间不阻塞解析，下载完成后阻塞解析。而 defer 脚本是无论如何都不会阻塞 DOM 解析的。 上图中的例子，是 parser-blocking.html 文件，其中包含了30个元素之后的解析阻塞脚本。如果我们看一眼 Performance 面板，其中 FP 和 FCP 都是在 HTML 准备完成尽可能早的开始构建 DOM 树。LCP 在5秒之后开始，这是因为脚本阻塞了 DOM 解析（下载时间），只有30个文本元素被绘制出来。一旦脚本下载和执行完成，DOM 解析便会重新开始。 解析阻塞也被称为渲染阻塞，因为此时渲染也不会进行（渲染需要依赖渲染树，而渲染树依赖 DOM 树）。但是两者还是有一些不同的。 Some browsers may incorporate a speculative parsing strategy where the HTML parsing (but not the DOM tree construction) is offloaded to a separate thread so that browser can read elements such as link(CSS), script, img, etc. and download these resources eagerly. This is quite helpful if you have three script elements one after the other, but the browser won’t be able to start the download of the second script until the first script is downloaded as the DOM parser couldn’t read the second script element. We can fix this easily by using async tag but asynchronous scripts are not guaranteed to execute in order. The reason it is called speculative parsing because the browser is making a speculation that a particular resource is expected to load in the future, so better load it now in the background. However, if some JavaScript manipulates DOM and removes/hides the element with an external resource, then speculation fails and these files were loaded for nothing. Tough. 💡 Every browser has a mind of its own, so when or if speculative parsing will happen is not guaranteed. However, you can ask the browser to load some resources ahead of time using the element. 渲染阻塞 CSS我们了解了，任何除了解析阻塞脚本之外的外部资源请求都是不会阻塞 DOM 解析和树构建的。所以 CSS 并不会阻塞 DOM 解析，等一下，其实是会阻塞的。为了理解这一点，我们需要了解渲染的过程。 DOM 和 CSSOM 树的构建都是在主线程上的，而且这些树时并行进行构建的。它们一起构建出了渲染树，用来绘制元素。这一过程其实也是跟随着 DOM 树的增量构建进行的。 上面谈到 DOM 树的生成时增量生成的（并非一下子生成），也就是浏览器一边解析 HTML 文件，一遍在 DOM 树上增加节点。但是 CSSOM 可不是这样——CSSOM 树的构建并不是增量构建的。 当浏览器遇到 style 嵌入代码块时，它会扫描所有的 CSS 代码，并依据相应的规则更新 CSSOM 树。然后，它会继续解析 HTML 文档，内联的样式也是一样的。 但是外部的样式表就有所不同了。我们知道外部样式表不是解析阻塞资源，所以它能够在后台与 DOM 解析并行地进行下载。但是与脚本不同，浏览器不会在外部样式表下载完后第一时间进行解析，这是因为浏览器无法一边扫描 CSS 文件一边构建 CSSOM 树。原因很简单：CSS 的规则表明，越后面的样式属性，越有可能覆盖前面的属性。一但浏览器增量地生成 CSSOM 树，那么会产生多个渲染树，这会造成很差的体验。 所以浏览器不会增量地生成 CSSOM 树，而是 CSS 文件全部扫描完后才生成完整的 CSSOM。一旦 CSSOM 树生成后，渲染树才会更新并绘制。 CSS 是渲染阻塞资源。一旦浏览器去请求一个外部的样式表文件，渲染树的构建就会暂停（因为渲染树依赖 CSSOM树），因此 CRP（Critical Rendering Path）也会阻塞。但是，DOM 树还是会进行解析。 A browser could have used an older state of the CSSOM tree to generate Render Tree as HTML is getting parsed to render things on the screen incrementally. But this has a huge downside. In this case, once the stylesheet is downloaded and parsed, and CSSOM is updated, Render Tree will be updated and rendered on the screen. Now the Render Tree nodes generated with older CSSOM will be repainted with new styles and it could also lead to Flash of Unstyled Content (FOUC) which is is very bad for UX. Hence browsers will wait until the stylesheet is loaded and parsed. Once the stylesheet is parsed and CSSOM is updated, the Render Tree is updated, and CRP is unblocked which leads to the paint of Render Tree on the screen. Due to this reason, it is recommended to load all external stylesheets as early as possible, possibly in the head section. Let’s imagine a scenario where the browser has started parsing HTML and it encounters an external stylesheet file. It will start the download of the file in the background, block the CRP, and continue with the DOM parsing. But then it encounters a script tag. So it will start the download of the external script file and block the DOM parsing. Now the browser is sitting idle waiting for the stylesheet and script file to download completely. But this time, the external script file has been downloaded completely while the stylesheet is still being downloaded in the background. Should the browser execute the script file? Is there any harm doing that? As we know, CSSOM provides a high-level JavaScript API to interact with the styles of the DOM elements. For example, you can read or update the background color of a DOM element using elem.style.backgroundColor property. The style object associated the elem element exposes the CSSOM API and there are many other APIs to do the same (read this css-tricks article). As a stylesheet is being downloaded background, JavaScript can still execute as the main thread is not being blocked by the loading stylesheet. If our JavaScript program accesses CSS properties of a DOM element (through CSSOM API), we will get a proper value (as per the current state of CSSOM). But once the stylesheet is downloaded and parsed, which leads to CSSOM update, our JavaScript now has a bad CSS value of the element since the new CSSOM update could have changed the CSS properties of that DOM element. Due to this reason, it’s not safe to execute JavaScript while the stylesheet is being downloaded. As per the HTML5 specification, the browser may download a script file but it will not execute it unless all previous stylesheets are parsed. When a stylesheet blocks the execution of a script, it is called a script-blocking stylesheet or a script-blocking CSS. In the above example, the [script-blocking.html](https://github.com/course-one/browser-rendering-test/blob/master/html/script-blocking.html) contains a link tag (for an external stylesheet) followed by a script tag (for an external JavaScript). Here the script gets downloaded really fast without any delay but the stylesheet takes 6 seconds to download. Hence, even though the script is downloaded completely as we can see from the Network panel, it wasn’t executed by the browser immediately. Only after the stylesheet is loaded, we see the Hello World messaged logged by the script. 💡 Like async or defer attribute makes script element non-parser-blocking, an external stylesheet can also be marked as non-render-blocking using the media attribute. Using the media attribute value, the browser can make a smart decision when to load the stylesheet. Document’s DOMContentLoaded EventThe [DOMContentLoaded](https://developer.mozilla.org/en-US/docs/Web/API/Document/DOMContentLoaded_event) (DCL) event marks a point in time when the browser has constructed a complete DOM tree from all the available HTML. But there are a lot of factors involved that can change when the DCL event is fired. 123document.addEventListener( &apos;DOMContentLoaded&apos;, function(e) &#123; console.log( &apos;DOM is fully parsed!&apos; );&#125; ); If our HTML doesn’t contain any scripts, DOM parsing won’t get blocked and DCL will fire as quickly as the browser can parse the entire HTML. If we have parser-blocking scripts, then DCL has to wait until all parser-blocking scripts are downloaded and executed. Things get a little complicated when stylesheets are thrown into the picture. Even though you have no external scripts, DCL will wait until all stylesheets are loaded. Since DCL marks a point in time when the entire DOM tree is ready, but DOM won’t be safe to access (for the style information) unless CSSOM is also fully constructed. Hence most browsers wait until all external stylesheets are loaded and parsed. Script-blocking stylesheet will obviously delay the DCL. In this case, since the script is waiting for the stylesheet to load, the DOM tree is not getting constructed. DCL is one of the website performance metrics. We should optimize the DCL to be as small as possible (the time at which it occurs). One of the best practices is to use defer and async tag for script element whenever possible so that browser can perform other things while scripts are being downloaded in the background. Second, we should optimize the script-blocking and render-blocking stylesheets. Window’s load eventAs we know JavaScript can block DOM tree generation but that’s not the case with external stylesheets and files such as images, videos, etc. The DOMContentLoaded event marks a point in time when the DOM tree is fully constructed and it is safe to access, the window.onload event marks a point in time when external stylesheets and files are downloaded and our web application (complete) has finished downloading. 123window.addEventListener( &apos;load&apos;, function(e) &#123; console.log( &apos;Page is fully loaded!&apos; );&#125; ) In the above example, the [rendering.html](https://github.com/course-one/browser-rendering-test/blob/master/html/rendering.html) file has an external stylesheet in the head that takes around 5 seconds to download. Since it’s in the head section, the FP and FCP occurs after 5 seconds since the stylesheet will block the rendering of any content below it (as it blocks CRP). After that, we have an img element that loads an image that takes around 10 seconds to download. So the browser will keep downloading this file in the background and move on with the DOM parsing and rendering (as an external image resource is neither parser-blocking nor render-blocking). Next, we have three external JavaScript files and they take 3s, 6s, and 9s to download respectively and most importantly, they are not async. This means the total load time should be close to 18 seconds as the subsequent script won’t start downloading before the previous one is executed. However, looking at the DCL event, our browser seemed to have used the speculative strategy to eagerly download the script files so the total time to load is close to 9 seconds. Since the last file to download that can affect the DCL is the last script file with the load time of 9 seconds (since stylesheet has already been downloaded in 5 seconds), the DCL event occurs around 9.1 seconds. We also had another external resource which was the image file and it kept loading in the background. Once it was fully downloaded (which takes 10 seconds), the window’s load event was fired after 10.2 seconds which marks that the webpage (application) is fully loaded.","categories":[{"name":"Translate","slug":"Translate","permalink":"http://keefe.wang/categories/Translate/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://keefe.wang/tags/JavaScript/"},{"name":"Browser","slug":"Browser","permalink":"http://keefe.wang/tags/Browser/"}]},{"title":"使用 vue-test-utils 进行测试","slug":"2020-07-29-use-vue-test-utils-to-test-components","date":"2020-07-29T14:23:00.000Z","updated":"2021-01-20T01:47:47.848Z","comments":true,"path":"2020/07/29/2020-07-29-use-vue-test-utils-to-test-components.html","link":"","permalink":"http://keefe.wang/2020/07/29/2020-07-29-use-vue-test-utils-to-test-components.html","excerpt":"","text":"插件安装我们使用 Vue CLI 脚手架进行项目的创建，按照提示一步步进行项目配置，尽量都选择无任何配置，尤其是自带的测试插件： 1vue create vue-test 新建好项目之后，我们需要在项目根目录下新建一个 test 目录来放置我们的测试文件。 由于我们是在 Vue 项目中进行测试，采用的是 vue-test-utils 这个测试工具插件进行测试，所以下面几类 npm 插件是必须要安装的： jest 相关 jest 是 vue-test-utils 官方推荐的测试运行器，所以这个插件是必要的；要使用 jest 来处理 *.vue 文件，需要安装和配置 vue-jest 插件。 1npm i --save-dev jest vue-jest 12345678910111213// 在 package.json 中做如下配置&#123; \"scripts\": &#123; \"test\": \"jest\" &#125;, \"jest\": &#123; \"moduleFileExtensions\": [ \"js\", \"json\", \"vue\" ] &#125;&#125; babel 相关 我们一般都不可避免地希望在代码中使用 ES2015 的特性，这时我们需要安装 babel 相关的插件，其中 babel-jest 是测试中的 ES2015 特性编译的插件 1npm install --save-dev babel-core babel-preset-env babel-jest 12345678910111213141516171819// 在 package.json 中做如下配置&#123; \"jest\": &#123; \"transform\": &#123; \".*\\\\.(vue)$\": \"vue-jest\", \"^.+\\\\.js$\": \"&lt;rootDir&gt;/node_modules/babel-jest\" &#125; &#125;&#125;// 在 .babelrc 或 babel.config.js 文件中做如下配置&#123; \"presets\": [[\"env\", &#123; \"modules\": false &#125;]], \"env\": &#123; \"test\": &#123; \"presets\": [[\"env\", &#123; \"targets\": &#123; \"node\": \"current\" &#125; &#125;]] &#125; &#125;&#125; vue-test-utils 依赖浏览器环境，我们使用 JSDOM 在 Node 虚拟浏览器环境运行测试。jest 中有自动设置 JSDOM，如果没有，需要安装以下插件 1npm install --save-dev jsdom jsdom-global 至此，所以前期的插件安装和配置工作就完成了。这时，我们在 test 目录下新建一个 *.test.js 文件，并在 terminal 中运行 npm run test 命令，就可以进行 vue 组件的测试了。","categories":[{"name":"Document","slug":"Document","permalink":"http://keefe.wang/categories/Document/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://keefe.wang/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"http://keefe.wang/tags/Vue/"},{"name":"Test","slug":"Test","permalink":"http://keefe.wang/tags/Test/"}]},{"title":"Vue 高级用法与精粹","slug":"2020-07-23-advanced-function-in-vue","date":"2020-07-23T11:32:00.000Z","updated":"2021-01-20T01:47:37.904Z","comments":true,"path":"2020/07/23/2020-07-23-advanced-function-in-vue.html","link":"","permalink":"http://keefe.wang/2020/07/23/2020-07-23-advanced-function-in-vue.html","excerpt":"","text":"复用与组合Mixin多重继承大致有两种模式，一种就是按照顺序将各个父类进行继承，例如当你需要一个类继承 A、B、C和D的特性，那么可以采用 A ⇒ B ⇒ C ⇒ D 这样一个继承链去继承，这种继承方式的好处是知道每一步继承的父子关系。而大多数情况我们不需要知道这些，只要像 duck typing 一样拥有这些父类的特性即可，Mixin 混入机制就是来解决这个问题。Vue 中也提供给了这样的机制： 1234567891011var myMixin = &#123; methods: &#123; hello: function () &#123; console.log('hello from mixin!') &#125; &#125;&#125;var Component = Vue.extend(&#123; mixins: [myMixin]&#125;); 比较好理解的，像 methods、computed 这种本身是对象类型的属性，可以直接进行 merge，所遵循的混合规则如下： 数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先 同名钩子函数将合并为一个数组，数组中的所有函数都将在此钩子生效时执行 混入也支持全局注入，但是需要注意！这会影响到之后的每一个 Vue 组件实例（不建议使用）： 12345678Vue.mixin(&#123; created: function () &#123; var myOption = this.$options.myOption if (myOption) &#123; console.log(myOption) &#125; &#125;&#125;) 自定义指令除了 v-model 和 v-show 等自带的指令之外，也可以自定义指令。自定义指令可以全局注册，也可以在组件内进行局部注册（指令在标签中必须要以 v- 开头）： 12345Vue.directive('focus', &#123; inserted: function (el) &#123; el.focus() &#125;&#125;) 1234567directives: &#123; focus: &#123; inserted: function (el) &#123; el.focus() &#125; &#125;&#125; 上面代码中出现的 inserted 是指令所在的钩子，指令的钩子有以下五种： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。 上述的钩子函数的参数有四个，分别是 el、binding、vnode、oldVnode，其中，指令的值需要从 binding.value 中获取。 自定义指令还可以添加动态参数，v-someDirection:[arg]，使用 binding.arg 来获取动态的指令： 123&lt;div id=\"dynamicexample\"&gt; &lt;p v-pin:[direction]=\"200\"&gt;I am pinned onto the page at 200px to the left.&lt;/p&gt;&lt;/div&gt; 12345678910Vue.directive('pin', &#123; bind: function (el, binding, vnode) &#123; el.style.position = 'fixed' var s = (binding.arg == 'left' ? 'left' : 'top') el.style[s] = binding.value + 'px' &#125;&#125;)// 回调函数可以简写，只支持 bind 和 update 两个钩子同时触发时Vue.directive('pin', function (el, binding, vnode) &#123;&#125;); 自定义指令也支持传入对象字面量 &lt;div v-demo=&quot;{ color: &#39;white&#39;, text: &#39;hello!&#39; }&quot;&gt;&lt;/div&gt; 渲染函数如果想要使用纯 js 的方式来实现视图，可以使用 Vue 提供的 render 函数属性来进行渲染，下面是一个简单的例子： 1234567891011121314Vue.component('anchored-heading', &#123; render: function (createElement) &#123; return createElement( 'h' + this.level, // 标签名称 this.$slots.default // 子节点数组 ) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;) createElement 这个函数可以创建出一个虚拟 Dom，它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息，所以也被称为 Vnode。 123456789101112131415161718192021// @returns &#123;VNode&#125;createElement( // 必填项一个 HTML 标签名、组件选项对象，或者 resolve 了上述任何一种的一个 async 函数 // &#123;String | Object | Function&#125; 'div', // 一个与模板中 attribute 对应的**数据对象**，可选项，&#123;Object&#125;。 &#123;&#125;, // 子级虚拟节点 (VNodes)，由 `createElement()` 构建而成，也可以使用字符串来生成“文本虚拟节点”，可选。 // &#123;String | Array&#125; [ '先写一些文字', createElement('h1', '一则头条'), createElement(MyComponent, &#123; props: &#123; someProp: 'foobar' &#125; &#125;) ]) 上面讲到的数据对象，也就是一个节点中的一些属性描述： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&#123; // 与 `v-bind:class` 的 API 相同， // 接受一个字符串、对象或字符串和对象组成的数组 'class': &#123; foo: true, bar: false &#125;, // 与 `v-bind:style` 的 API 相同， // 接受一个字符串、对象，或对象组成的数组 style: &#123; color: 'red', fontSize: '14px' &#125;, // 普通的 HTML attribute attrs: &#123; id: 'foo' &#125;, // 组件 prop props: &#123; myProp: 'bar' &#125;, // DOM property domProps: &#123; innerHTML: 'baz' &#125;, // 事件监听器在 `on` 内， // 但不再支持如 `v-on:keyup.enter` 这样的修饰器。 // 需要在处理函数中手动检查 keyCode。 on: &#123; click: this.clickHandler &#125;, // 仅用于组件，用于监听原生事件，而不是组件内部使用 // `vm.$emit` 触发的事件。 nativeOn: &#123; click: this.nativeClickHandler &#125;, // 自定义指令。注意，你无法对 `binding` 中的 `oldValue` // 赋值，因为 Vue 已经自动为你进行了同步。 directives: [ &#123; name: 'my-custom-directive', value: '2', expression: '1 + 1', arg: 'foo', modifiers: &#123; bar: true &#125; &#125; ], // 作用域插槽的格式为 // &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125; scopedSlots: &#123; default: props =&gt; createElement('span', props.text) &#125;, // 如果组件是其它组件的子组件，需为插槽指定名称 slot: 'name-of-slot', // 其它特殊顶层 property key: 'myKey', ref: 'myRef', // 如果你在渲染函数中给多个元素都应用了相同的 ref 名， // 那么 `$refs.myRef` 会变成一个数组。 refInFor: true&#125; 插件通过 Vue.use() 方法使用插件，必须要在 new Vue() 实例化之前进行注册。Vue.use 会自动阻止多次注册相同插件，届时即使多次调用也只会注册一次该插件。 过滤器Vue.js 允许你自定义过滤器（filters 可作为与 computed 同一级的属性进行配置），可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式： 12345&lt;!-- 在双花括号中 --&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;!-- 在 `v-bind` 中，过滤器可以串联，前一个的输出会作为下一个的输入 --&gt;&lt;div v-bind:id=\"rawId | capitalize | formatId\"&gt;&lt;/div&gt;","categories":[{"name":"Document","slug":"Document","permalink":"http://keefe.wang/categories/Document/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://keefe.wang/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"http://keefe.wang/tags/Vue/"},{"name":"Framework","slug":"Framework","permalink":"http://keefe.wang/tags/Framework/"}]},{"title":"Vue 中容易被忽视的小功能","slug":"2020-07-22-things-need-to-be-aware-of-in-vue","date":"2020-07-22T11:03:00.000Z","updated":"2021-01-20T01:47:17.815Z","comments":true,"path":"2020/07/22/2020-07-22-things-need-to-be-aware-of-in-vue.html","link":"","permalink":"http://keefe.wang/2020/07/22/2020-07-22-things-need-to-be-aware-of-in-vue.html","excerpt":"","text":"组件通信Prop相关prop 是父组件向子组件传递数据的一种方式，在父组件中使用 kebab-case 的方式传入数据，在子组件中可以添加 props 属性来获取传入的数据。这是一个单向的通信过程。 可以通过 v-bind 传入动态变量，也可以直接传入字符串值到子组件。 如果子组件中 props 属性中没有声明某些值，那么父组件传入的就是非 prop 的 attribute，对于绝大多数 attribute 来说，从外部提供给组件的值会替换掉组件内部设置好的值。所以如果传入 type=”text” 就会替换掉 type=”date” 并把它破坏！庆幸的是，class 和 style attribute 会稍微智能一些，即两边的值会被合并（merge）起来，从而得到最终的值。 可以使用 vm.$attr 属性来获取除 class 和 style 之外的非 prop 的 attribute，可以在父组件中使用 v-bind=&quot;$attr&quot; 传入，还可以通过子组件中的 inheritAttrs: true 字段来控制是否接受父组件传入的非 prop 的 attribute。 事件自定义事件使用 v-on 绑定事件时，最好使用 kebab-case 命名法来命名事件，因为 v-on 事件监听器在 DOM 模板中会被自动转换为全小写 （因为 HTML 是大小写不敏感的）。 可以使用 v-on=&quot;$listeners&quot; 来将所有的事件监听器指向这个组件的某个特定的子元素，它是一个对象，里面包含了作用在这个组件上所有的监听器（监听事件）。这样，在子组件上可以绑定 vm.$listeners 中所包含的监听事件。 事件监听除了 $emit 和 v-on 这一对好基友之外，vue 还提供了类似 总线（bus）机制的观察者模式的事件监听方案： $on(eventName, eventHandler) 侦听一个事件 $once(eventName, eventHandler) 一次性侦听一个事件 $off(eventName, eventHandler) 停止侦听一个事件 修饰符 sync 作用：对 prop 进行简单的“双向绑定”，可以实现简单的父子数据同步 使用：在父组件需要双向绑定的数据上添加 .sync 修饰符，例如 &lt;div&gt;&lt;child :some-prop.sync=&quot;someProp&quot;&gt;&lt;/child&gt;&lt;/div&gt; ；在子组件上使用 vm.$emit 触发数据更新，例如 this.$emit(&#39;update:some-prop&#39;, val) 组件动态组件动态组件是通过 来实现的，但是在切换组件时，会将每个组件的原有状态丢失，这时需要添加一个 keep-alive 标签，例如： 123&lt;keep-alive&gt; &lt;component v-bind:is=\"currentTabComponent\"&gt;&lt;/component&gt;&lt;/keep-alive&gt; 异步组件Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。 12345Vue.component( 'async-webpack-example', // 这个动态导入会返回一个 `Promise` 对象。 () =&gt; import('./my-async-component')) Slot编译作用域父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 default内容可以使用 &lt;slot&gt; Default content &lt;/slot&gt; 来设置分发内容的默认值，当没有内容传入时会显示该内容。 具名插槽有多个插槽需要进行内容分发时，可以使用具名插槽，具体用法如下： 1234&lt;!-- 子元素设置具名插槽 --&gt;&lt;header&gt; &lt;slot name=\"header\"&gt;&lt;/slot&gt;&lt;/header&gt; 1234&lt;!-- 父元素设置分发内容，由 v-slot 属性来指明具体的插槽名 --&gt;&lt;template v-slot:header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt;&lt;/template&gt; 作用域插槽绑定在 元素上的 attribute 被称为插槽 prop，为了让父元素能够访问到子组件中的数据，可以通过 v-bind 进行作用域的绑定，具体代码如下： 1234&lt;!-- 子元素中需要在 slot 中使用 v-bind 绑定具体变量 --&gt;&lt;slot v-bind:user=\"user\"&gt; &#123;&#123; user.lastName &#125;&#125;&lt;/slot&gt; 123456&lt;!-- 父元素通过 v-slot 来指明子元素所 bind 的所有数据 --&gt;&lt;child&gt; &lt;template v-slot=\"slotProps\"&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/template&gt;&lt;/child&gt; v-slot 的缩写为 #，这个在具名插槽中有 结构插槽Prop作用域插槽的内部工作原理是将你的插槽内容包裹在一个拥有单个参数的函数里，这意味着 v-slot 的值实际上可以是任何能够作为函数定义中的参数的 JavaScript 表达式。 1234&lt;!-- prop 重命名 --&gt;&lt;current-user v-slot=\"&#123; user: person &#125;\"&gt; &#123;&#123; person.firstName &#125;&#125;&lt;/current-user&gt; 1234&lt;!-- 为 prop 指定默认值 --&gt;&lt;current-user v-slot=\"&#123; user = &#123; firstName: 'Guest' &#125; &#125;\"&gt; &#123;&#123; user.firstName &#125;&#125;&lt;/current-user&gt; 边界情况处理访问元素&amp;组件 访问根实例 一般不建议触达另一个组件实例内部或手动操作 DOM 元素 如果必须这么做，可以通过 this.$root 来访问根实例中的 data、computed 和 methods 等属性 访问父级元素 同访问根实例，父级元素的访问是通过 this.$parent 访问子元素 你可以通过 ref 这个 attribute 为子组件赋予一个 ID 引用，父组件可以通过 他会 this.$refs.someId 来访问子元素的所有属性 依赖注入 当出现了多层嵌套的组件时，使用 $parent 属性无法很好获取到特定父级元素，这时需要采用依赖注入的方法 provide 和 inject，相当于爷组件和孙组件之间的 props： 123456789// 爷组件中添加 provide 属性provide: function () &#123; return &#123; getMap: this.getMap &#125;&#125;// 孙组件中添加 inject 属性inject: ['getMap'] 循环引用 组件递归引用要避免 不同组件间相互引用，如果产生循环引用（例如 Tree 文件系统或级联系统，模块系统会不知道到底哪个是初始组件），可以采用如下两种方式来解决： 在生命周期钩子 beforeCreate 中进行组件的引入： 123beforeCreate: function () &#123; this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue').default&#125; 引用组件时采用异步方式： 123components: &#123; TreeFolderContents: () =&gt; import('./tree-folder-contents.vue')&#125; 过渡&amp;动画单元素/组件的过渡使用 封装所要添加过渡的元素。这种方式适用于以下四种情况（都是单个组件显隐）： 条件渲染 (使用 v-if) 条件展示 (使用 v-show) 动态组件 组件根节点 封装好元素后，还需要提供相应的 css 样式，分别由六种状态的样式名，需要根据 name 属性进行相应的设置：someTransition-enter 表示进入过渡开始状态，someTransition-enter-active 表示进入过渡生效状态，someTransition-enter-to 表示进入过渡结束状态，someTransition-leave，someTransition-leave-active，someTransition-leave-to。 也可以自定义类名，相对应上面六种默认的样式，可以在 transition 标签中添加 enter-class，enter-active-class，enter-to-class，leave-class，leave-active-class，leave-to-class。 transition 标签中可以指定进入和离开过渡的时长，可以通过 :duration=&quot;{ enter: 500, leave: 800 }&quot; 实现 transition 标签中可以指定过渡各阶段的钩子，以用来绑定相应的事件，包括 @before-enter、@enter、@after-enter、@enter-cancelled、@before-leave、@leave、@after-leave、@leave-cancelled 八种钩子： 123456// 在 enter 和 leave 钩子事件，如果没有 css 控制元素过渡，那么一定需要有 done() 回调// 否则 enter 和 leave 钩子事件会同时完成beforeEnter: function (el) &#123;&#125;,enter: function (el, done) &#123; done()&#125; transition 标签中可以使用 appear 属性来设置元素初始化过渡的样式，用法与 enter 和 leave 相同，可以使用 someTrasition-appear 类或者自定义类名属性，当然也支持钩子的实现。 多元素的过渡多元素使用过渡时，可以在最外层使用 transition 标签进行包装，用法与单元素相同，但是有一点需要注意——使用 v-if 或者 v-for 设置多个元素时，一定要在每个元素上绑定自己的 key。 多个元素切换显隐状态时，Vue 提供了一个 mode 属性来进行平滑过渡： 1&lt;transition name=\"fade\" mode=\"out-in\"&gt;&lt;/transition&gt; 多组件的过渡多组件的过渡，使用之前所提到的动态组件即可实现，在过渡时可以在组件外包装一层 transition，指定过渡的样式名 name 属性，就可以使用上面提到的样式或钩子进行过渡样式的实现，当然也可以添加所需要的 mode： 123&lt;transition name=\"component-fade\" mode=\"out-in\"&gt; &lt;component v-bind:is=\"view\"&gt;&lt;/component&gt;&lt;/transition&gt; 对于列表的过渡，可以使用 包装 v-for 渲染出的列表，指明过渡样式名 name 属性，即可用上面相同的方式进行过渡的实现。在列表打乱或重新排序时，Vue 提供了 someTransition-move 的类名来实现： 123456&lt;button v-on:click=\"shuffle\"&gt;Shuffle&lt;/button&gt;&lt;transition-group name=\"flip-list\" tag=\"ul\"&gt; &lt;li v-for=\"item in items\" v-bind:key=\"item\"&gt; &#123;&#123; item &#125;&#125; &lt;/li&gt;&lt;/transition-group&gt; 1234567891011new Vue(&#123; el: '#flip-list-demo', data: &#123; items: [1,2,3,4,5,6,7,8,9] &#125;, methods: &#123; shuffle: function () &#123; this.items = _.shuffle(this.items) &#125; &#125;&#125;) 123.flip-list-move &#123; transition: transform 1s;&#125;","categories":[{"name":"Document","slug":"Document","permalink":"http://keefe.wang/categories/Document/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://keefe.wang/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"http://keefe.wang/tags/Vue/"},{"name":"Framework","slug":"Framework","permalink":"http://keefe.wang/tags/Framework/"}]},{"title":"JavaScript 基于事件循环的并发模型","slug":"2020-06-03-advanced-eventloop-in-javascript","date":"2020-06-03T08:31:00.000Z","updated":"2021-01-20T01:46:35.460Z","comments":true,"path":"2020/06/03/2020-06-03-advanced-eventloop-in-javascript.html","link":"","permalink":"http://keefe.wang/2020/06/03/2020-06-03-advanced-eventloop-in-javascript.html","excerpt":"","text":"runtime（运行时刻）是指一个程序在运行的状态。JavaScript 的运行时刻有一个基于事件循环的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。 JavaScript 中的函数调用会形成一个由若干帧组成的栈，当一个函数中存在闭包函数时，外层函数会先压入栈中，其中包含参数和局部变量；闭包函数跟着压入栈中，也包含了自己的参数和局部变量。闭包函数先从栈中弹出，执行完了之后外层函数从栈中弹出执行，栈就被清空了。 对象是被分配在堆中。 一个 JavaScript 运行时包含了一个待处理消息的消息队列。每一个消息都关联着一个用以处理这个消息的回调函数。 事件循环123while (queue.waitForMessage()) &#123; queue.processNextMessage();&#125; JavaScript 中每一个函数都是需要完整执行完成才会继续进行下一步（单线程语言：one thread ⇒ one call stack ⇒ one thing at a time），所以 JavaScript 的代码很容易出现一个函数执行时间过长的情况。为了实现程序的并发执行，JavaScript 引入了事件循环机制。 在上面所提到的函数调用栈之外，还会有一个任务队列。当 runtime 执行代码过程中遇到了像 setTimeout 或 DOM 事件绑定的回调函数，会首先调用 WebAPIs 去进行执行——例如 setTimeout 会产生一个 timer 计时器，当计时器到达指定时间后，会将这个事件推入任务队列。任务队列就是由一个个异步操作的回调函数所组成的队列。事件循环简单来说就是：当 runtime 函数调用栈清空后，查看当前任务队列，并把队列第一个任务压入 runtime 函数调用栈。 浏览器的 render 刷新最快是 16.6ms 一次（浏览器刷新一般是 60次/s ），这是在主线程为空的时候（所以任务队列里的任务是不会阻塞浏览器渲染的）。如果想在浏览器渲染任务队列中添加任务，可以使用 requestAnimationFrame(callback)方法来进行添加。如果函数调用栈不为空，则 render 会被阻塞：主线程中的死循环会阻塞浏览器渲染，但是看下面的代码： 1234function loop() &#123; setTimeout(loop, 0);&#125;loop(); 这个无限自我递归调用也会形成一个循环，但是由于 setTimeout 方法只是不停地往任务队列里面添加任务，而主线程还是每次取一个任务去执行，主线程不会被阻塞，所以浏览器渲染也不会被阻塞。 到目前为止，在事件循环中，我们认识到了主线程、任务队列和渲染任务队列。当主线程任务全部执行完成清空后，会从非空的任务队列中拿第一个任务到主线程尽心执行，每次循环都是只取一个任务队列中的任务。而渲染任务则是一次性执行完成的。 实际上，浏览器总还有一个 microTask queue，这个队列中一般我们遇到的 99.9% 应该都是以 promise 形式出现的，microTask 执行的时间是每一段 JS 代码执行完毕（主线程任务清空、任务队列取得第一个任务到主线程并执行完、浏览器渲染任务执行完）都会进行执行，而且一旦执行，microTask queue 中无论有多少个任务（包括同时添加进来的任务）都会一直执行完。所以，microTask queue 是会产生阻塞的。 如上图所示，我们所知的浏览器的事件循环有以下的几种队列机制： 主线程任务队列 接受 JS 程序中按顺序的同步任务，在每次事件循环中都会执行任务直至队列清空 异步回调任务队列 接受像 setTimeout、ajax 等的异步回调函数任务，在每次时间循环中主线程任务队列清空后，会拿出该队列的头部任务放入主线程进行执行 microtask 任务队列 接受 promise.then 的回调函数任务，在事件循环中，每一段 JS 代码执行完毕（主线程任务清空、任务队列取得第一个任务到主线程并执行完、浏览器渲染任务执行完）都会执行，且每次执行都会将该队列清空，包括同时入队的任务也会一并清空 动画帧回调任务队列 接受 requestAnimationFrame 的回调函数任务，在每次浏览器渲染任务执行之前进行执行（目前仅在 chrome 中是该顺序），每次执行都清空当前队列，如有新的任务添加则等待下次渲染前执行 浏览器渲染任务队列 每当上面主线程、异步任务队列、microTask 任务队列执行完毕，且距离上一次渲染时长大于 16.6ms 时，就会进行任务执行，每一次执行都会将当前队列任务全部执行完毕 用一个伪代码来进行上面流程的表述，如下： 12345678910111213141516171819202122while (true) &#123; while (mainThread.hasTasks()) &#123; execute(mainThread.getNextTask()); &#125; queue = getNextQueue(); task = queue.pop(); execute(task); while(microTask.hasTasks()) &#123; doMicroTask(); &#125; if (isRepaintTime()) &#123; animationTasks = animationQueue.copyTasks(); for (task in animationTasks) &#123; doAnimationTask(); &#125; &#125; repaint()&#125; Node 中的事件循环NodeJS 的事件循环基本上与浏览器中的事件循环是一致的，只不过浏览器使用的是 WebAPIs，而 NodeJS 中使用的是 C++ APIs。 主线程与异步任务队列执行以及 microTask 任务队列都与浏览器中的事件循环相同，我们可以看到上图中多了三个没有见到过的任务队列： check phase 任务队列 接受使用 setImmediate 方法传入的回调函数任务，每次在异步任务队列执行完成后，清空该队列 timer phase 任务队列 接受 setTimeout、setInterval 传入的回调函数，每次在 check phase 任务队列清空后，清空该任务队列 nextTick 任务队列 与 microTask 任务队列相同， 接受 process.nextTick 传入的回调函数，该队列优先级高于 microTask 用伪代码进行上述流程的模拟，如下： 123456789101112131415while (tasksAreWaiting()) &#123; queue = getNextQueue(); while (queue.hasTasks()) &#123; task = queue.pop(); execute(task); while (nextTickQueue.hasTasks()) &#123; doNextTickTask(); &#125; while (promiseQueue.hasTasks()) &#123; doPromiseTask(); &#125; &#125;&#125;","categories":[{"name":"Document","slug":"Document","permalink":"http://keefe.wang/categories/Document/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://keefe.wang/tags/JavaScript/"}]},{"title":"EggJS源码阅读-启动流程与代码实现","slug":"2020-05-30-source-code-reading-Egg-starting","date":"2020-05-23T04:30:00.000Z","updated":"2020-10-20T10:00:10.799Z","comments":true,"path":"2020/05/23/2020-05-30-source-code-reading-Egg-starting.html","link":"","permalink":"http://keefe.wang/2020/05/23/2020-05-30-source-code-reading-Egg-starting.html","excerpt":"","text":"egg是阿里开源的一个框架，为企业级框架和应用而生，相较于express和koa，有更加严格的目录结构和规范。不同的团队可以基于egg，根据自己的需求封装出适合团队业务的更上层框架。 egg如何启动 根据package.json中的script命令，可以看到执行的直接是egg-bin dev的命令。找到egg-bin文件夹中的dev.js,会看到里面会去执行外层的start-cluster文件: 1require(options.framework).startCluster(options); 此处的options.framework其实指的就是egg框架，然后调用了egg-cluster包中的startCluster方法，egg正式迈出了启动的第一步。 [源码流程] egg框架采用了master-agent-worder的集群模式，如果所示，官方文档中也对于这三种进程的启动和通信给出了较为详细的说明： Master 启动后先 fork Agent 进程 Agent 初始化成功后，通过 IPC 通道通知 Master Master 再 fork 多个 App Worker App Worker 初始化成功，通知 Master 所有的进程初始化成功后，Master 通知 Agent 和 Worker 应用启动成功 我们尝试从源码中大致将这个流程实现出来： 12345678// egg-cluster/lib/master.jsready.mixin(this); // 将 ready 方法挂在 Master 上this.detectPorts().then(() =&gt; &#123; // 检测端口 this.forkAgentWorker(); // 启动 agent 进程，发送 agent-start 消息给 master 进程&#125;);// master 进程一旦接收到 agent-start 消息后，开始创建 worker 进程this.once('agent-start', this.forkAppWorkers.bind(this)); [源码流程] Agent与AppWorker的实现AgentWorker与AppWorker进程的启动 在启动AgentWorker和AppWorker时，会分别加载agent_worker.js和app_worker.js两个文件并创建进程，其中agent_worker.js中会创建Agent类的实例，而app_worker.js中会创建Application类的实例。 两种进程在启动时都会调用this.loader.load()方法来加载自己相应的一些插件和自定义的扩展。 基于egg_loader实现了AppWorkerLoader和 AgentWorkerLoader，上层框架基于这两个类来扩展，Loader的扩展只能在框架进行。 123456789101112131415161718192021222324252627import &#123; AppWorkerLoader &#125; from 'egg'import common from './common'class MyAppWorkerLoader extends AppWorkerLoader &#123; constructor(opt) &#123; super(opt); // 自定义初始化 &#125; loadConfig() &#123; super.loadConfig(); // 对 config 进行处理 &#125; load() &#123; super.load(); // 自定义加载其他目录 // 或对已加载的文件进行处理 &#125;&#125;Object.assign(MyAppWorkerLoader.prototype, &#123; // 可以根据自己的需求，重写一些获取配置的方法 getServerEnv()&#123;&#125;; _preloadAppConfig()&#123;&#125; getTypeFiles()&#123;&#125;&#125;)export default MyAppWorkerLoader Agent如何实现 Agent对象在egg-cluster创建环节中被创建出来，继承自egg.Agent对象，该对象继承EggApplication,且loader为./lib/loader/agent_worker_loader.js文件，继承自egg-core.eggLoader对象，整体继承链如上图。 1234567891011121314151617// egg/lib/agent.jsclass Agent extends EggApplication &#123; constructor(options = &#123;&#125;) &#123; options.type = 'agent'; // 1.完成父类构建 super(options); // 2.驱动loader执行load方法 this.loader.load(); // 3.dump相关配置文件进入./run目录下 this.dumpConfig(); setInterval(() =&gt; &#123;&#125;, 24 * 60 * 60 * 1000); // 4.监听异常事件 this._uncaughtExceptionHandler = this._uncaughtExceptionHandler.bind(this); process.on('uncaughtException', this._uncaughtExceptionHandler); &#125;&#125; Agent类的实现中，主要是实例化了EggApplication，调用了this.loader.load()方法来加载各种文件和配置。 1234567891011121314151617181920// egg/lib/egg.jsclass EggApplication extends EggCore &#123; constructor(options = &#123;&#125;) &#123; options.mode = options.mode || 'cluster'; // 1.原型EggCore构建 super(options); // 2.调用loadConfig，在agent的实现中，指向的并不是egg-core.loader，而是agent_worker_loader this.loader.loadConfig(); // 3.ready事件 this.ready(() =&gt; process.nextTick(() =&gt; &#123; const dumpStartTime = Date.now(); this.dumpConfig(); this.dumpTiming(); &#125;)); // 监听unhandleRejection事件 // 4.cluster初始化 this[CLUSTER_CLIENTS] = []; this.cluster = (clientClass, options) =&gt; &#123;&#125;; &#125;&#125; 在EggApplication类的实现中，我们可以看到是继承自EggCore类，在父类构建好之后，会调用this.loader.loadConfig()方法，该方法的loader实例实际指向了AgentWorkerLoader（agent_worker_loader.js）： 1234567891011121314// egg/lib/loader/agent_worker_loader.jsclass AgentWorkerLoader extends EggLoader &#123; loadConfig() &#123; this.loadPlugin(); // loadPlugin from egg-core/lib/loader/mixin/plgin.js super.loadConfig(); // loadConfig from egg-core/lib/loader/mixin/config.js &#125; load() &#123; this.loadAgentExtend(); this.loadContextExtend(); this.loadCustomAgent(); &#125;&#125; loadPlugin方法会加载三种插件： eggPlugins，从eggjs框架配置的插件，也就是egg/config/plugins.js文件中egg框架自带的插件； appPlugins，每个应用自己配置的插件，也就是myproject/config/plugins.js，用户可以自定义配置一些特殊的插件； customPlugins，应用启动命令中参数EGG_PLUGINS值所代表的插件； 最后会将这三种插件都挂在app实例上：this.plugins = enablePlugins; loadConfig方法会加载三种配置： appConfig，每个应用自己独有的配置，其中会按顺序加载两个配置，一个是默认配置config.default，另一个是当前环境的配置config.${this.serverEnv}，也就是myproject/config下的一些配置文件加载 加载自定义添加的plugin插件的配置 加载框架egg的配置，即egg/config 重新加载应用app的配置，即myproject/config下的 最后将合并的配置挂载在app实例上this.config = target; Application如何实现上面提到，AppWorker在实例化的过程中，会调用this.loader.load()。进入具体这个Application所对应的loader.load方法，可以发现Application的实现比Agent的实现多调用了很多加载的方法： this.loadApplicationExtend();，该方法的调用会给应用加载扩展方法，加载路径为app\\extend\\application.js, 会将对应的对象挂载在app 应用上。 this.loadRequestExtend();，加载app\\extend\\request.js this.loadResponseExtend();，加载app\\extend\\response.js this.loadContextExtend();，加载app\\extend\\context.js this.loadHelperExtend();，加载app\\extend\\helper.js this.loadService() this.loadMiddleware() this.loadController() this.loadRouter() 总结 egg启动服务集群，采用了master-agent-worker模式，AgentWorker和AppWorker都由Application(egg/lib/applicaton.js) -&gt; EggApplication(egg/lib/egg.js) -&gt; EggCore(egg-core/lib/egg.js) -&gt; KoaApplication(koa)原型链进行继承 Agent和Application在实例化的过程中，都会调用相应的Loader去加载自己所需的插件和配置，且加载顺序严格按照插件plugin-框架framework-应用application这样一个顺序","categories":[{"name":"SourceCodeReading","slug":"SourceCodeReading","permalink":"http://keefe.wang/categories/SourceCodeReading/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://keefe.wang/tags/JavaScript/"},{"name":"源码学习","slug":"源码学习","permalink":"http://keefe.wang/tags/源码学习/"},{"name":"EggJS","slug":"EggJS","permalink":"http://keefe.wang/tags/EggJS/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://keefe.wang/tags/NodeJS/"}]},{"title":"Express源码阅读-router相关","slug":"2020-03-05-source-code-reading-express-router","date":"2020-03-15T04:30:00.000Z","updated":"2020-10-20T10:00:17.103Z","comments":true,"path":"2020/03/15/2020-03-05-source-code-reading-express-router.html","link":"","permalink":"http://keefe.wang/2020/03/15/2020-03-05-source-code-reading-express-router.html","excerpt":"","text":"Express 是一种保持最低程度规模的灵活 Node.js Web 应用程序框架，为 Web 和移动应用程序提供一组强大的功能。 Express中的app123456789101112131415161718// express.jsfunction createApplication() &#123; // typeof app === 'function'，同时它身上还绑定着无数属性和方法 var app = function(req, res, next) &#123; app.handle(req, res, next); &#125;; // app同时继承了事件监听/触发机制和application.js中的各种方法 mixin(app, EventEmitter.prototype, false); mixin(app, proto, false); // 此处暴露了request和response两个类 app.request = Object.create(req, &#123; ... &#125;); app.response = Object.create(res, &#123; ... &#125;); // 调用application.js中的init方法，主要调用的是defaultConfiguration方法 app.init(); return app;&#125;// 这里需要注意的是exports和module.exports的不同：当module.exports被赋值后，exports就不同于module.exports了，所以需要这么做；当然也可以只用module.exports；exports = module.exports = createApplication; 可以看出，调用express()返回的app其实是一个函数，调用app.listen()其实执行的是http.createServer(app).listen()。因此，app其实就是一个请求处理函数，作为http.createServer的参数。而express其实是一个工厂函数，用来生成请求处理函数。 中间件 An Express application is essentially a series of middleware calls.一个Express应用实际上就是一系列中间件的调用。 中间件大致可分为两种，一种是普通中间件，通过 app.use(&#39;/user&#39;) 方法进行注册，该方法中的路径是匹配所有以 /user 开头的路径；另外一种是路由中间件，通过 app.METHOD() 方法进行注册，这种方式精确匹配路径，且只能处理确定请求方法的请求。 针对app.use部分的代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546app.use = function use(fn) &#123; var offset = 0; // 默认设置路径为根路径，同时判断中间件是方法还是方法所在路径 var path = '/'; if (typeof fn !== 'function') &#123; var arg = fn; while (Array.isArray(arg) &amp;&amp; arg.length !== 0) &#123; arg = arg[0]; &#125; if (typeof arg !== 'function') &#123; offset = 1; path = fn; &#125; &#125; // router初始化 this.lazyrouter(); var router = this._router; var fns = flatten(slice.call(arguments, offset)); fns.forEach(function (fn) &#123; // non-express app if (!fn || !fn.handle || !fn.set) &#123; return router.use(path, fn); &#125; debug('.use app under %s', path); fn.mountpath = path; fn.parent = this; // restore .app property on req and res router.use(path, function mounted_app(req, res, next) &#123; var orig = req.app; fn.handle(req, res, function (err) &#123; setPrototypeOf(req, orig.request) setPrototypeOf(res, orig.response) next(err); &#125;); &#125;); // mounted an app fn.emit('mount', this); &#125;, this); return this;&#125;; 针对app.METHODS的代码如下：1234567891011121314methods.forEach(function(method)&#123; app[method] = function(path)&#123; if (method === 'get' &amp;&amp; arguments.length === 1) &#123; // app.get(setting) return this.set(path); &#125; // 路由初始化 this.lazyrouter(); var route = this._router.route(path); route[method].apply(route, slice.call(arguments, 1)); return this; &#125;;&#125;); 路由详解在上面两种中间件的实现代码中，都调用了 this.lazyrouter() 方法，所有涉及到路由的方法都会调用这个方法，作用是初始化一个应用的内部路由。1234567891011app.lazyrouter = function lazyrouter() &#123; if (!this._router) &#123; // 生成一个路由实例 this._router = new Router(&#123; caseSensitive: this.enabled('case sensitive routing'), strict: this.enabled('strict routing') &#125;); this._router.use(query(this.get('query parser fn'))); this._router.use(middleware.init(this)); &#125;&#125;; 针对第一个默认路由，可以看下具体调用了哪些方法，最终实现了什么逻辑：1234567this.get('query parser fn');// 上面的 get 方法同 app.get，可以在 methods.forEach 循环处理时，如果 get 方法的入参长度为1时，会调用 this.set(arg)// 在set方法中，有针对 'query parser' 的处理// 最终，query 方法实现了将 req.query 进行 querystring.parse 的一个解析过程case 'query parser': this.set('query parser fn', compileQueryParser(val)); break; 针对第二个默认路由 init，是给 app 上的暴露出的 req、res 继承 node 原生的 request 和 response 的一些属性。 之所以不在 defaultConfiguration 方法中进行这一步路由的初始化，原因在于设置路由的相关参数需要调用app.set方法，这个方法明显需要有app实例，如果在获取app实例的时候就初始化了一个路由，这个路由的参数就没办法配置了。因此，在获取app实例后，必须先对路由参数进行配置，然后再调用对应的app.use等方法。 app.Methods我们先以 app.get 为例，通过断点调试的方式来查看 app.get 这种路由的 _router 对象是什么结构。 上面的截图是当我们初始化一个 express 实例，并设置了一个 app.get() 的路由后，在 app.listen 处添加断点进行调试时的 app 实例的属性。可以看到在 app._router 中有一个 stack，里面按顺存放着三个 layer 对象，分别是初始化时的 query 和 init 两个路由，和第三个则是我们所设置的 get 路由。每一个 layer 中包含路由处理的回调函数 handle，路由对象 route&lt;Route&gt;，该对象中还包含一个存有 Layer 对象的栈（stack)，就和 app._router.stack 相同。 根据上面对于 app.get 这种路由的结构分析，我们可以先猜想它的实现流程： 首先根据传入的路径封装一个Route对象，再对传入的回调函数封装成Layer对象，接着把这个Layer对象push到Route.stack里面去 再创建一个默认Layer(跟app.use里面Layer的同级)，把步骤一中的Route挂到这个Layer.route属性上面，而这个Layer对象，会被push到app._router.stack里面 app.use接下来我们来看 app.use 这种路由又有什么不同。 可以看到，在这种路由中，除了 query 和 init 两个初始化路由的方法外，第三个真正的回调方法被封装成的 Layer 对象中，route 属性的值为 undefined。所以我们可以猜想：在 app.use 这种路由里，传入的参数（路径、回调函数）会被封装成 Layer 对象（其中 route 属性为 undefined），压入 app._router.stack 栈中。 两种路由的源码实现接下来我们通过源码来分析我们写的 app.use(&#39;/main&#39;, someFun()) 是如何成为一个 layer 对象并压入 app._router 的路由栈中的。 首先来看 app.use： 123456789101112131415161718app.use = function use(fn) &#123; var path = '/'; // 设置一个默认的路由方法路径 // ... // 设置路由，同样也是由lazyrouter进行路由对象的初始化：this._router = new Router(&#123;&#125;) this.lazyrouter(); var router = this._router; fns.forEach(function (fn) &#123; // router.use是接下来重点要看的方法 router.use(path, function mounted_app(req, res, next) &#123; // ... &#125;); &#125;); // ... &#125;, this); return this;&#125;; 接下来看 Router 对象的 use 方法实现： 1234567891011121314151617proto.use = function use(fn) &#123; var path = '/'; // ... var callbacks = flatten(slice.call(arguments, offset)); for (var i = 0; i &lt; callbacks.length; i++) &#123; var fn = callbacks[i]; // 针对传入路由中的每一个回调方法，都包装成一个 Layer 对象并压入 var layer = new Layer(path, &#123; sensitive: this.caseSensitive, strict: false, end: false &#125;, fn); layer.route = undefined; this.stack.push(layer); &#125; return this;&#125;; 从代码中可以看到，与我们的猜想一致，app.use 这种路由的实现，是将传入的一个个路径或回调方法等参数封装成 Layer 对象压入 _router.stack 栈中。 然后来看 app.get 这种路由的代码实现： 1234567891011121314// methods 中包含各种请求类型等，get 就包含在其中methods.forEach(function(method)&#123; app[method] = function(path)&#123; if (method === 'get' &amp;&amp; arguments.length === 1) &#123; // app.get(setting) return this.set(path); &#125; this.lazyrouter(); // 路由对象 Router 初始化 var route = this._router.route(path); route[method].apply(route, slice.call(arguments, 1)); return this; &#125;;&#125;); 上面代码中最终返回的是 app，那么这端代码对 app 进行了什么样的操作呢？我们可以将目光聚焦在 route[method].apply() 这行代码上。接下来我们可以看下 route 到底是个什么东西。this._router.route 的代码实现： 1234567891011121314proto.route = function route(path) &#123; var route = new Route(path); var layer = new Layer(path, &#123; sensitive: this.caseSensitive, strict: this.strict, end: true &#125;, route.dispatch.bind(route)); layer.route = route; this.stack.push(layer); return route;&#125;; 这里可以看到返回的 route 是一个 Route 对象，在这个对象中将参数封装成了 Layer 对象推入了 app._router.stack 中。 接下来我们看一下 Route 对象中的一些实现代码： 1234567891011121314151617181920212223function Route(path) &#123; // Route对象初始化时添加了一个空数组stack属性 this.path = path; this.stack = []; this.methods = &#123;&#125;;&#125;// 对于app.METHODS这种路由，将路由参数（路径、回调方法）包装成Layer对象压入Route.stack中methods.forEach(function(method)&#123; Route.prototype[method] = function()&#123; var handles = flatten(slice.call(arguments)); for (var i = 0; i &lt; handles.length; i++) &#123; // ... var layer = Layer('/', &#123;&#125;, handle); layer.method = method; this.methods[method] = true; this.stack.push(layer); &#125; // ... return this; &#125;;&#125;); 至此，在调用 route[method].apply() 时就会为 app.METHODS 这种类型的路由的 Layer 中添加 route&lt;Route&gt; 属性。","categories":[{"name":"SourceCodeReading","slug":"SourceCodeReading","permalink":"http://keefe.wang/categories/SourceCodeReading/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://keefe.wang/tags/JavaScript/"},{"name":"源码学习","slug":"源码学习","permalink":"http://keefe.wang/tags/源码学习/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://keefe.wang/tags/NodeJS/"},{"name":"Express","slug":"Express","permalink":"http://keefe.wang/tags/Express/"}]},{"title":"JavaScript模块化","slug":"2020-01-12-Javascript-module-history","date":"2020-01-12T04:30:00.000Z","updated":"2020-10-20T09:36:13.923Z","comments":true,"path":"2020/01/12/2020-01-12-Javascript-module-history.html","link":"","permalink":"http://keefe.wang/2020/01/12/2020-01-12-Javascript-module-history.html","excerpt":"","text":"名词定义先行模块化主要解决以下三个问题： 代码分离 不同模块间的依赖定义 代码到执行环境的传递 能够解决其中一两个点的解决方案我们称之为“模式”，能够解决全部三个问题的方案我们称之为“模块系统”； 我们将封装好的导出实例（对象、方法等）和引入的实例称为“模块格式”；用“分离依赖定义（detached dependency definitions，即用不同文件存储不同文件）”来描述模块系统中可被使用的独立依赖。 关于模块化所解决的问题 命名冲突 在1995-1999年间，使用var来定义全局变量是非常方便的，因为当时的JavaScript就是用来编写脚本处理小微任务，而随着应用的代码量上升，全局变量的缺点就越来越明显，因此我们甚至不能引用第三方脚本。123456789101112131415// file greeting.jsvar helloInLang = &#123; en: 'Hello world!', es: '¡Hola mundo!', ru: 'Привет мир!'&#125;;function writeHello(lang) &#123; document.write(helloInLang[lang]);&#125;// file hello.jsfunction writeHello() &#123; document.write('The script is broken');&#125; 支持大量代码仓库 由于编写应用的代码量越来越大，我们常常需要将代码分为多个脚本文件逐一引入，这导致了越来越多数量的脚本文件需要我们手动维护，而且还要考虑脚本引入的顺序！这真是太令人头痛！ Directly Defined Dependencies1999年提出的首次对于独立依赖的模式“直接定义依赖”。该模式是由 Erik Arvidsson 在1999年提出。 123456789101112131415161718192021// file greeting.jsdojo.provide(\"app.greeting\");app.greeting.helloInLang = &#123; en: 'Hello world!', es: '¡Hola mundo!', ru: 'Привет мир!'&#125;;app.greeting.sayHello = function (lang) &#123; return app.greeting.helloInLang[lang];&#125;;// file hello.jsdojo.provide(\"app.hello\");dojo.require('app.greeting');app.hello = function(x) &#123; document.write(app.greeting.sayHello('es'));&#125;; 代码使用dojo 1.6编写，其中dojo.provide用来定义模块，获取模块时需要使用dojo.require 命名空间模式在JavaScript中，函数是first class citizens，意味着可以被赋给变量，也可以被函数返回。命名空间模式是由 Erik Arvidsson于2002年发明的互联网应用开发工具Bindows开始形成。该模式类似于： 1234567891011121314// file app.jsvar app = &#123;&#125;;// file greeting.jsapp.helloInLang = &#123; en: 'Hello world!', es: '¡Hola mundo!', ru: 'Привет мир!'&#125;;// file hello.jsapp.writeHello = function (lang) &#123; document.write(app.helloInLang[lang]);&#125;; 可见，所有的逻辑和数据都被放在了app对象的属性中，所以不会污染其他全局变量。尽管该模式看似让代码组织有了一定的规律，但是很明显上面的数据和逻辑仍然没有被隔离，我们很轻易就可以修改这些代码。 模块模式模块模式的主旨是将数据和逻辑代码放在闭包中并提供一些公用方法作为对外接口对这些资源进行访问JavaScript Module Pattern: In-Depth。例如： 12345678910111213141516171819var greeting = (function () &#123; var module = &#123;&#125;; var helloInLang = &#123; en: 'Hello world!', es: '¡Hola mundo!', ru: 'Привет мир!' &#125;; module.getHello = function (lang) &#123; return helloInLang[lang]; &#125;; module.writeHello = function (lang) &#123; document.write(module.getHello(lang)) &#125;; return module;&#125;()); 这种将数据和逻辑闭包在立即调用方法中的方式在2008年Douglas Crockford发表的《JavaScript the Good Parts》一书中被称作“模块”。 模板定义依赖（Template Defined Dependencies)当有多个script文件依赖时，我们可以使用一个模板来将这些依赖进行顺序管理： 1234567891011121314151617181920// file app.tmp.js/*borschik:include:../lib/main.js*//*borschik:include:../lib/helloInLang.js*//*borschik:include:../lib/writeHello.js*/// file main.jsvar app = &#123;&#125;;// file helloInLang.jsapp.helloInLang = &#123; en: 'Hello world!', es: '¡Hola mundo!', ru: 'Привет мир!'&#125;;// file writeHello.jsapp.writeHello = function (lang) &#123; document.write(app.helloInLang[lang]);&#125;; 注释定义依赖1234567891011121314151617181920// file helloInLang.jsvar helloInLang = &#123; en: 'Hello world!', es: '¡Hola mundo!', ru: 'Привет мир!'&#125;;// file sayHello.js/*! lazy require scripts/app/helloInLang.js */function sayHello(lang) &#123; return helloInLang[lang];&#125;// file hello.js/*! lazy require scripts/app/sayHello.js */document.write(sayHello('en')); 这种依赖的工作方式是：首先下载这些依赖文件，并进行文件内容解析，解析到有依赖存在的注释时迭代下载、解析…… 外部定义依赖1234567891011121314151617181920212223// file deps.json&#123; \"files\": &#123; \"main.js\": [\"sayHello.js\"], \"sayHello.js\": [\"helloInLang.js\"], \"helloInLang.js\": [] &#125;&#125;// file helloInLang.jsvar helloInLang = &#123; en: 'Hello world!', es: '¡Hola mundo!', ru: 'Привет мир!'&#125;;// file sayHello.jsfunction sayHello(lang) &#123; return helloInLang[lang];&#125;// file main.jsconsole.log(sayHello('en')); deps.json文件就是我们定义所有依赖的外部上下文依赖文件。当运行这个应用时，加载器会获取到这个文件，将这个文件中的依赖按照数组的正确顺序进行读取和加载。lodash就是使用的这种方法进行依赖加载的。 沙箱模式123456789101112131415161718192021222324252627282930313233343536// file sandbox.jsfunction Sandbox(callback) &#123; var modules = []; for (var i in Sandbox.modules) &#123; modules.push(i); &#125; for (var i = 0; i &lt; modules.length; i++) &#123; this[modules[i]] = Sandbox.modules[modules[i]](); &#125; callback(this);&#125;// file greeting.jsSandbox.modules = Sandbox.modules || &#123;&#125;;Sandbox.modules.greeting = function () &#123; var helloInLang = &#123; en: 'Hello world!', es: '¡Hola mundo!', ru: 'Привет мир!' &#125;; return &#123; sayHello: function (lang) &#123; return helloInLang[lang]; &#125; &#125;;&#125;;// file app.jsnew Sandbox(function(box) &#123; document.write(box.greeting.sayHello('es'));&#125;); 该模式的关键是使用一个全局的构造函数来代替全局对象，依赖模块可以被定义为这个构造函数的属性。 依赖注入12345678910111213141516171819// file greeting.jsangular.module('greeter', []) .value('greeting', &#123; helloInLang: &#123; en: 'Hello world!', es: '¡Hola mundo!', ru: 'Привет мир!' &#125;, sayHello: function(lang) &#123; return this.helloInLang[lang]; &#125; &#125;);// file app.jsangular.module('app', ['greeter']) .controller('GreetingController', ['$scope', 'greeting', function($scope, greeting) &#123; $scope.phrase = greeting.sayHello('en'); &#125;]); CommonJS Modules1234567891011121314151617// file greeting.jsvar helloInLang = &#123; en: 'Hello world!', es: '¡Hola mundo!', ru: 'Привет мир!'&#125;;var sayHello = function (lang) &#123; return helloInLang[lang];&#125;module.exports.sayHello = sayHello;// file hello.jsvar sayHello = require('./lib/greeting').sayHello;var phrase = sayHello('en');console.log(phrase); CommonJS使用require和module两个标志来表示依赖的引入和导出。 AMD1234567891011121314151617181920// file lib/greeting.jsdefine(function() &#123; var helloInLang = &#123; en: 'Hello world!', es: '¡Hola mundo!', ru: 'Привет мир!' &#125;; return &#123; sayHello: function (lang) &#123; return helloInLang[lang]; &#125; &#125;;&#125;);// file hello.jsdefine(['./lib/greeting'], function(greeting) &#123; var phrase = greeting.sayHello('en'); document.write(phrase);&#125;);","categories":[{"name":"Reading","slug":"Reading","permalink":"http://keefe.wang/categories/Reading/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://keefe.wang/tags/JavaScript/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://keefe.wang/tags/读书笔记/"},{"name":"规范","slug":"规范","permalink":"http://keefe.wang/tags/规范/"}]},{"title":"怎样做一个Pragmatic Programmer","slug":"2020-01-09-how-to-be-a-pragmatic-programmer","date":"2020-01-09T04:30:00.000Z","updated":"2020-10-20T10:00:20.894Z","comments":true,"path":"2020/01/09/2020-01-09-how-to-be-a-pragmatic-programmer.html","link":"","permalink":"http://keefe.wang/2020/01/09/2020-01-09-how-to-be-a-pragmatic-programmer.html","excerpt":"","text":"What maks a pragmatic programmer1.Early adopter/faster adapter: 善于学习新的技术并能够尝试将其集成在自己的知识库中;2.Inquisitive：善于提问、保持好奇心；3.Critical thinker：辩证地看待问题而非一味接受前人的话语；4.Realistic：发觉问题的本质，认识问题的难度并能估计解决该问题的时间；5.Jack of all trades：能够转移领域之后快速适应，通过掌握核心基础知识；6.We who cut mere stones must always be envisioning cathedrals.7.持续以上过程 TIPsTip1.在乎你所做的事情Tip2.不断思考所做的事情，不断从big picture进行思考Tip3.提供解决方案而非各种借口Tip4.“不留一扇破窗”，一旦发现问题及时修复Tip5.做项目的催化剂，吸引资源到一个可预见成功的项目中Tip6.时刻牢记“蓝图”Tip7.将产品质量作为需求之一进行考量Tip8.定期对知识进行投资Tip9.批判地看待自己的所见所闻 持续进行知识投资1.定期地进行知识投资2.注重知识的多样性3.在2的基础上注意控制风险4.在一个技术还未成熟前进行学习5.时常对知识库进行review e.g.1.一年至少学习一种新的语言2.一个季度看一本技术书籍（甚至一个月、可涉及非技术例如用户等）3.上课4.参与到用户群体中5.在不同环境中进行试验6.跟上潮流：订阅杂志或期刊","categories":[{"name":"Reading","slug":"Reading","permalink":"http://keefe.wang/categories/Reading/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://keefe.wang/tags/JavaScript/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://keefe.wang/tags/读书笔记/"},{"name":"规范","slug":"规范","permalink":"http://keefe.wang/tags/规范/"}]},{"title":"Clean Code规范整理","slug":"2019-12-21-clean-code-note","date":"2019-12-21T03:30:00.000Z","updated":"2020-10-20T09:29:42.058Z","comments":true,"path":"2019/12/21/2019-12-21-clean-code-note.html","link":"","permalink":"http://keefe.wang/2019/12/21/2019-12-21-clean-code-note.html","excerpt":"","text":"变量：1.变量名有意义 2.不使用魔法数字 3.参数用变量而不是数字 4.mapping中的iterator变量命名清楚 5.属性中不要出现类名/对象名 6.方法参数使用默认值检查参数是否为undefined 方法：1.使用一到两个形参（或方法复杂、使用对象类型参数、形参的解构赋值） 2.一个方法应该只做一件事！ 3.方法名要能自我解释 4.如果出现重复的代码要精练和抽象 5.使用Object.assign给对象赋值 6.（如果方法中出现flag，应当分成两个方法处理） 7.尽量避免方法的副作用（更改全局变量、多个方法写一个文件、公用一个状态等） 8.处理数组、对象时最好处理其复本 9.修改原生对象和方法最好使用class新建 10.尽量使用函数式编程代替命令式编程 11.存在多个判断条件时用方法来包括，避免使用非类型条件 12.避免使用条件语句，使用多态性（class）来代替 13.避免类型判断 对象与数据结构1.使用class来实现继承 2.使用链式方法调用 3.谨慎使用继承（仅在以下三种情况使用）： a.关系为is-a而不是has-a的时候 b.基类可以被复用时 c.想通过更改基类来进行全局属性的改变时 SOLID原则1.SRP（单一职责）：一个类要足够内聚，负责尽量单一的功能，减少类的改动； 2.OCP（开闭原则）：对扩展开放，对修改封闭； 3.LSP（里式替换）：父类特性在子类中要完全继承无变化，即在父类对象被替换为子类对象时无影响； 4.ISP（接口隔离）：不同接口之间需要进行隔离； 5.DIP（依赖倒置）：高层模块不能依赖底层模块，应都依赖于抽象； 并发1.用Promises，不用回调函数callbacks（用async/await更好） 错误处理1.不确定的代码需要try...catch... 2.不要忘了catch里的错误处理、reject里的错误处理 格式1.驼峰、下划线、大小写都需要保持一致","categories":[{"name":"Reading","slug":"Reading","permalink":"http://keefe.wang/categories/Reading/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://keefe.wang/tags/JavaScript/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://keefe.wang/tags/读书笔记/"},{"name":"规范","slug":"规范","permalink":"http://keefe.wang/tags/规范/"}]},{"title":"源码阅读 - Vue的数据响应式原理","slug":"2019-12-01-Vue-source-code-reading-data-binding","date":"2019-12-01T02:00:00.000Z","updated":"2020-10-20T09:44:41.240Z","comments":true,"path":"2019/12/01/2019-12-01-Vue-source-code-reading-data-binding.html","link":"","permalink":"http://keefe.wang/2019/12/01/2019-12-01-Vue-source-code-reading-data-binding.html","excerpt":"","text":"什么是数据响应式 Vue.js 一个核心思想是数据驱动。所谓数据驱动，是指视图是由数据驱动生成的，我们对视图的修改，不会直接操作 DOM，而是通过修改数据。——《Vue.js技术揭秘》 没有像 Vue 和 React 这些具有数据响应式特性的前端框架之前，我们从服务端提供过的接口获取到数据要渲染在 html 页面上时，抑或是需要获取表单的值进行计算回显到页面上时，都需要建立很多 DOM 事件监听器，并进行许多的 DOM 操作。举个最简单的例子：用户在 html 页面的表单中输入两个加数 a 和 b ，计算得到两个加数之和，并展示到页面上。这时我们需要监听表单中 a 和 b 两个输入框的变化，拿到变化值相加然后通过修改指定 id 或者 class 的选择器对应的 DOM 来修改两数之和。但是当输入表单不止两个时，就会令人捉急。 而 Vue 的数据响应式大大地优化了这一整套的流程。面对大量的 UI 交互和数据更新，数据响应式让我们做到从容不迫——我们需要去了解数据的改变是怎样被触发，更新触发后的数据改变又是怎样反馈到视图。接下来我们通过对部分 Vue 源码的简单分析和学习来深入了解 Vue 中的数据响应式是怎样实现的。 我们将这一部分的代码分析大致分为三部分：让数据变成响应式、依赖收集和派发更新。 数据响应式的中心思想 该原理图源自 Vue 官方教程的深入响应式原理，这张图向我们展示了 Vue 的数据响应式的中心思想。 我们先来介绍图中的四个模块，黄色部分是 Vue 的渲染方法，视图初始化和视图更新时都会调用 vm._render 方法进行重新渲染。渲染时不可避免地会 touch 到每个需要展示到视图上的数据（紫色部分），触发这些数据的 get 方法从而收集到本次渲染的所有依赖。收集依赖和更新派发都是基于蓝色部分的 Watcher 观察者。而当我们在修改这些收集到依赖的数据时，会触发数据中的 set 属性方法，该方法会修改数据的值并 notify 到依赖到它的观察者，从而触发视图的重新渲染。绿色部分是渲染过程中生成的 Virtual DOM Tree，这棵树不仅关系到视图渲染，更是 Vue 优化视图更新过程的基础。 让数据变成响应式基本上大家都了解 Vue 的数据响应式原理是由 JS标准内置对象方法 Object.defineProperty 来实现的，而这个方法是不兼容IE8和FF22及以下版本的浏览器的，所以 Vue 也只能在这些版本之上的浏览器中才能正常使用。这个方法的作用是直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。那么数据响应式用这个方法为什么对象添加或修改了什么属性呢？我们从 Vue 的初始化讲起。 Vue 的初始化12345678function Vue (options) &#123; // ... this._init(options)&#125;initMixin(Vue) stateMixin(Vue) // ...export default Vue 在 src/core/index.js 中我们可以看到一个 Vue 被导出，这个Vue是在 src/core/instance/index 中定义的，Vue 是一个方法，参数是options，我们大胆猜想这个 Vue 就是进行 vue 实例化的方法，而 options 就是我们传入的 data、computed、methods 等属性。这个 Vue 方法中主要调用了 _init 方法，这个方法是在 initMixin 方法调用时定义在 Vue 原型上的一个方法，_init 方法中对当前传入的 options 进行了一些处理（主要是判断当前实例化的是否为组件，使用 mergeOptions 方法对 options 进行加工，此处不做赘述），然后又调用了一系列方法进行了生命周期、事件、渲染器的初始化，我们主要来关注 initState 这个方法（src/core/instance/state.js）:12345678910111213141516export function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options if (opts.props) initProps(vm, opts.props) if (opts.methods) initMethods(vm, opts.methods) // a* if (opts.data) &#123; initData(vm) &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125; 将 Vue 实例上的 data 响应式化上面的方法中对props、methods、data、computed和watch进行了初始化，这些都是Vue实例化方法中传入参数options对象的一些属性，这些属性都需要被响应式化。而针对于data的初始化分了两种情况[a]，一种是options中没有data属性的，该方法会给data赋值一个空对象并进行observe（该方法之后我们会详细讲述），如果有data属性，则调用[*initData](https://github.com/DQFE/vue/blob/dev/src/core/instance/state.js#L112)方法进行初始化。我们主要通过对data属性的初始化来分析Vue中的数据响应式原理。12345678910111213141516171819202122232425262728293031323334353637383940414243function initData (vm: Component) &#123; let data = vm.$options.data // a* data = vm._data = typeof data === 'function' ? getData(data, vm) : data || &#123;&#125; if (!isPlainObject(data)) &#123; data = &#123;&#125; process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm ) &#125; // b* const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) &#123; // c* const key = keys[i] if (process.env.NODE_ENV !== 'production') &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn( `Method \"$&#123;key&#125;\" has already been defined as a data property.`, vm ) &#125; &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `The data property \"$&#123;key&#125;\" is already declared as a prop. ` + `Use prop default value instead.`, vm ) &#125; else if (!isReserved(key)) &#123; proxy(vm, `_data`, key) &#125; &#125; // d* observe(data, true)&#125; initData 方法对 options 中的 data 进行处理，主要是有两个目的: 一方面将 data 代理到 Vue 实例上，同时检查 data 中是否使用了 Vue 中的保留字、是否与 props、methods 属性中的数据同名 使用 observe 方法将data中的属性变成响应式的 之前我们提到在调用 initState 方法之前会有对 Vue 实例化传入的 options 参数进行处理的环节（mergeOptions），这个过程会将 data 处理成一个函数（例如我们在 vue 组件中的 data 属性），之后会调用 callHook(vm, &#39;beforeCreate&#39;) 方法来触发 beforeCreate 的生命周期钩子，这个方法的调用可能会对 data 属性进行进一步处理，所以方法一开始会对 data 统一做处理使其成为一个function[a*]。 接下来会对 data 中的每一个数据进行遍历[b]，遍历过程将会使用 hasOwn(methods, key)、hasOwn(props, key)、!isReserved(key) 方法对该数据是否占用保留字、是否与 props 和 methods 中的属性重名进行判断，然后调用 proxy 方法将其代理到 Vue 实例上。此处需要注意的是：*如果 data 中的属性与 props、methods 中的属性重名，那么在 Vue 实例上调用这个属性时的优先级顺序是 props &gt; methods &gt; data。 最后对每一个 data 中的属性调用 observe 方法，该方法的功能是赋予 data 中的属性可被监测的特性。这个方法和其中使用到的 Observe 类是在src/core/observer/index.js文件中，observe 方法主要是调用Observer类构造方法，将每一个 data中的 value 变成可观察、响应式的：1234567891011121314constructor (value: any) &#123; this.value = value this.dep = new Dep() this.vmCount = 0 def(value, '__ob__', this) if (Array.isArray(value)) &#123; //... this.observeArray(value) &#125; else &#123; this.walk(value) &#125; &#125; 可以看到该构造函数有以下几个目的： 针对当前的数据对象新建一个订阅器； 为每个数据的value都添加一个ob属性，该属性不可枚举并指向自身； 针对数组类型的数据进行单独处理（包括赋予其数组的属性和方法，以及 observeArray 进行的数组类型数据的响应式）； this.walk(value)，遍历对象的 key 调用 defineReactive 方法； defineReactive是真正为数据添加 get 和 set 属性方法的方法，它将 data 中的数据定义一个响应式对象，并给该对象设置 get 和 set 属性方法，其中 get 方法是对依赖进行收集， set 方法是当数据改变时通知 Watcher 派发更新。 依赖收集依赖收集的原理是：当视图被渲染时，会触发渲染中所使用到的数据的 get 属性方法，通过 get 方法进行依赖收集。 其真实的逻辑我们举例来说明：当前正在渲染组件 ComponentA，会将当前全局唯一的监听器置为这个 Watcher，这个组件中使用到了数据 data () { return { a: b + 1} }，此时触发b的 getter 会将当前的 watcher 添加到b的订阅者列表 subs 中。也就是说如果 ComponentA 依赖 b，则将该组件的渲染 Watcher 作为订阅者加入b的订阅者列表中。 我们先看下 get 属性方法：12345678910111213get: function reactiveGetter () &#123; const value = getter ? getter.call(obj) : val if (Dep.target) &#123; dep.depend() if (childOb) &#123; childOb.dep.depend() if (Array.isArray(value)) &#123; dependArray(value) &#125; &#125; &#125; return value&#125; Dep - 订阅器数据对象中的 get 方法主要使用 depend 方法进行依赖收集，该方法是 Dep 类中的属性方法，继续来看 Dep 类是怎样实现的：123456789101112131415161718192021222324252627282930313233export default class Dep &#123; // a* static target: ?Watcher; id: number; subs: Array&lt;Watcher&gt;; constructor () &#123; this.id = uid++ this.subs = [] &#125; addSub (sub: Watcher) &#123; this.subs.push(sub) &#125; depend () &#123; if (Dep.target) &#123; Dep.target.addDep(this) &#125; &#125;&#125;Dep.target = nullconst targetStack = []export function pushTarget (target: ?Watcher) &#123; targetStack.push(target) Dep.target = target&#125;export function popTarget () &#123; targetStack.pop() Dep.target = targetStack[targetStack.length - 1]&#125; Dep 类中有三个属性：target、id 和 subs，分别表示当前全局唯一的静态数据依赖的监听器 Watcher、该属性的 id 以及订阅这个属性数据的订阅者列表[a*]。另外还提供了将订阅者添加到订阅者列表的 addSub方法、从订阅者列表删除订阅者的 removeSub 方法。 Dep.target 是当前全局唯一的订阅者，这是因为同一时间只允许一个订阅者被处理。target 的意思就是指当前正在处理的目标订阅者，而这个订阅者是有一个订阅者栈 targetStack，当某一个组件执行到某个生命周期的 hook 时（例如 mountComponent），会将当前目标订阅者 target 置为这个 watcher，并将其压入 targetStack 栈顶。 接下来是添加当前数据依赖的 depend方法，Dep.target 对象是一个 Watcher 类的实例，调用 Watcher 类的 addDep 方法，我们看下 addDep 方法将当前的依赖 Dep 实例放在了哪里：12345678910addDep (dep: Dep) &#123; const id = dep.id if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) &#123; dep.addSub(this) &#125; &#125;&#125; 我们稍后会对 Watcher 类进行分析，目前先来简单看下 addDep 这个属性方法做了什么。可以看到入参是一个 Dep 类实例，这个实例实际上是当前全局唯一的订阅者，newDepIds 是当前数据依赖 dep 的 id 列表，newDeps 是当前数据依赖 dep 列表，depsId 则是上一个 tick 的数据依赖的 id 列表。这个方法主要的逻辑就是调用当前数据依赖 dep 的类方法 addSub，而这个方法在上面Dep 类方法中可以看到，就是将当前全局唯一的 watcher 实例放入这个数据依赖的订阅者列表中。 target Watcher的产生我们以生命周期中的 mountComponent 这一个阶段为例来分析上面提到的Dep.target 这个全局唯一的当前订阅者 Watcher 是怎样产生的。 1234567891011121314151617181920212223export function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean): Component &#123; // ... let updateComponent if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; updateComponent = () =&gt; &#123; // 首次渲染视图会进入，生成虚拟Node，更新DOM&#125; &#125; else &#123; updateComponent = () =&gt; &#123; // 数据更新时会进入，调用渲染函数对视图进行更新 vm._update(vm._render(), hydrating) &#125; &#125; new Watcher(vm, updateComponent, noop, &#123; before () &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, 'beforeUpdate') &#125; &#125; &#125;, true /* isRenderWatcher */) // ... return vm&#125; 通过mountComponent的代码可以看到在触发了beforeMount生命周期钩子后，紧接着创建了一个用于渲染Watcher实例。我们通过Watcher类的构造函数来看创建Watcher实例时做了哪些工作：1234567891011121314151617181920212223242526constructor ( vm: Component, // 当前渲染的组件 expOrFn: string | Function, // 当前Watcher实例的getter属性方法 cb: Function, // 回调函数 options?: ?Object, // 手动传入watch时的option isRenderWatcher?: boolean // 是否为渲染watcher的标识 ) &#123; this.vm = vm if (isRenderWatcher) &#123; vm._watcher = this &#125; vm._watchers.push(this) // 此处处理我们传入的watcher参数（在组件内手动新建watch属性） if (options) &#123;&#125; else &#123;&#125; // ... // parse expression for getter if (typeof expOrFn === 'function') &#123; this.getter = expOrFn &#125; else &#123; this.getter = parsePath(expOrFn) if (!this.getter) &#123; this.getter = noop &#125; &#125; this.value = this.lazy ? undefined : this.get()&#125; 通过 Watcher 类的构造函数传参可以看到 mountComponent 生命周期中创建的 Watcher 是一个渲染 Watcher，将当前的 getter 设置为了 updateComponent 方法（也就是重新渲染视图的方法），最后调用了 get 属性方法，我们接下来看 get 方法做了什么：12345678910111213141516171819get () &#123; pushTarget(this) let value const vm = this.vm try &#123; value = this.getter.call(vm, vm) &#125; catch (e) &#123; if (this.user) &#123; handleError(e, vm, `getter for watcher \"$&#123;this.expression&#125;\"`) &#125; else &#123; throw e &#125; &#125; finally &#123; if (this.deep) &#123; traverse(value) &#125; popTarget() this.cleanupDeps() &#125; return value&#125; get 方法首先调用了在 Dep类文件中定义的全局方法 pushTarget，将 Dep.target 置为当前正在执行的渲染 Watcher，并将这个 watcher 压到了 targetStack。接下来调用 wathcer 的 getter 方法：由于此时的 getter 就是 updateComponent 方法，执行 updateComponent 方法，也就是 vm._update(vm._render(), hydrating) 进行渲染，渲染过程中必然会 touch 到 data 中相关依赖的属性，此时就会触发各个属性中的 get 方法（也就是将当前的渲染 Watcher 添加到所有渲染中使用到的数据的依赖列表 subs 中）。 渲染完之后会将当前的渲染 Watcher 从 targetStack 推出，进行下一个 watcher 的任务。最后会进行依赖的清空，每次数据的变化都会引起视图重新渲染，每一次渲染又会进行依赖收集，又会触发 data 中每个属性的 get 方法，这时会有一种情况发生：&lt;div v-if=&quot;someBool&quot;&gt;&lt;/div&gt;&lt;div v-else&gt;&lt;/div&gt; 第一次当 someBool 为真时，进行渲染，当我们把 someBool 的值 update 为 false 时，这时候属性 a 不会被使用，所以如果不进行依赖清空，会导致不必要的依赖通知。依赖清空主要是对 newDeps 进行更新，通过对比本次收集的依赖和之前的依赖进行对比，把不需要的依赖清除。 派发更新 当我们修改一个存在 data 属性上的值时，会触发数据中的 set 属性方法，首先会判断并修改该属性数据的值，并触发自身的 dep.notify 方法开始更新派发： 123456789set: function reactiveSetter (newVal) &#123; const value = getter ? getter.call(obj) : val if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; // ... childOb = !shallow &amp;&amp; observe(newVal) dep.notify()&#125; 接下来让我们进入dep.notify这个方法：123456789notify () &#123; const subs = this.subs.slice() if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) &#123; subs.sort((a, b) =&gt; a.id - b.id) &#125; for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125; notify 这个方法是每一个数据在响应式化之后自己内部闭包的 dep 实例的方法，还记得之前讲过的 subs 保存着所有订阅该数据的订阅者，所以在 notify 方法中首先对 subs 这个订阅者序列按照其 id 进行了排序。接下来就是调用每一个订阅者 watcher 实例的 update 方法进行更新的派发。update 方法是在 Watcher 类文件中，使用了队列的方式来管理订阅者的更新派发，其中主要调用了 queueWatcher 这个方法来实现该逻辑：1234567891011121314151617181920export function queueWatcher (watcher: Watcher) &#123; const id = watcher.id if (has[id] == null) &#123; // a* has[id] = true if (!flushing) &#123; // b* queue.push(watcher) &#125; else &#123; let i = queue.length - 1 while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123; i-- &#125; queue.splice(i + 1, 0, watcher) &#125; if (!waiting) &#123; // c* waiting = true // ... nextTick(flushSchedulerQueue) &#125; &#125;&#125; 进入该方法后，首先使用一个名为 has 的 Map 来保证每一个 watcher 仅推入队列一次[a]。flushing 这个标识符表示目前这个队列是否正在进行更新派发，如果是，那么将这个 id 对应的订阅者进行替换，如果已经路过这个 id，那么就立刻将这个 id 对应的 watcher 放在下一个排入队列[b]。接下来根据waiting 这个标识符来表示当前是否正在对这个队列进行更新派发[c*]，如果没有的话，就可以调用 nextTick(flushSchedulerQueue) 方法进行真正的更新派发了。 12345678910111213141516function flushSchedulerQueue () &#123; flushing = true let watcher, id queue.sort((a, b) =&gt; a.id - b.id) for (index = 0; index &lt; queue.length; index++) &#123; watcher = queue[index] if (watcher.before) &#123; watcher.before() &#125; id = watcher.id has[id] = null watcher.run() // ... &#125; 这个方法首先对队列中的 watcher 按照其 id 进行了排序，排序的主要目的有三： 组件的更新由父到子；因为父组件的创建过程是先于子的，所以 watcher 的创建也是先父后子，执行顺序也应该保持先父后子。 用户的自定义 watcher 要优先于渲染 watcher 执行；因为用户自定义 watcher 是在渲染 watcher 之前创建的。 如果一个组件在父组件的 watcher 执行期间被销毁，那么它对应的 watcher 执行都可以被跳过，所以父组件的 watcher 应该先执行。排序结束之后，便对这个队列进行遍历，并执行watcher.run()方法去实现数据更新的通知，run方法的逻辑是： 新的值与老的值不同时会触发通知； 但是当值是对象或者deep为true时无论如何都会进行通知 所以 watcher 有两个功能，一个是将属性的值进行更新，另一个就是可以执行 watch 中的回调函数 handler(newVal, oldVal)，这也是为何我们可以在 watcher 中拿到新旧两个值的原因。 至此，数据的更新派发也通知到了各个组件，便又可以进行视图的更新渲染，收集依赖，派发更新……","categories":[{"name":"SourceCodeReading","slug":"SourceCodeReading","permalink":"http://keefe.wang/categories/SourceCodeReading/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://keefe.wang/tags/JavaScript/"},{"name":"源码学习","slug":"源码学习","permalink":"http://keefe.wang/tags/源码学习/"},{"name":"VUE","slug":"VUE","permalink":"http://keefe.wang/tags/VUE/"},{"name":"数据响应","slug":"数据响应","permalink":"http://keefe.wang/tags/数据响应/"}]},{"title":"从输入URL到页面加载发生了什么之进阶篇","slug":"2018-03-22-what-happend-during-opening-url","date":"2018-03-22T04:00:00.000Z","updated":"2020-10-20T09:29:19.202Z","comments":true,"path":"2018/03/22/2018-03-22-what-happend-during-opening-url.html","link":"","permalink":"http://keefe.wang/2018/03/22/2018-03-22-what-happend-during-opening-url.html","excerpt":"","text":"文章来源：https://segmentfault.com/a/1190000006879700文章优点：采用总分总的形式进行撰写，结构和章节明确，发散较广。 文章首先指出整个过程分为六大步骤： DNS解析 TCP连接 发送HTTP请求 服务器处理请求并返回HTTP报文 浏览器解析渲染页面 连接结束 DNS解析：将网站的【姓名】翻译成【身份证号】，是一个翻译的过程。这个过程是将网址从右到左进行解析和查询的过程。.=&gt;com=&gt;google.com为了查询效率，DNS解析简历起多级缓存（浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存）为了均衡地发送和处理请求，DNS进行负载均衡（DNS重定向），CDN也是利用了该技术，根据每台机器负载量、地理位置距离等返回给用户最优的一个IP地址没有使用CDN时请求服务器资源：localDNS-rootDNS-逐级查询到域名授权的DNS记录-使用查询到的ip去请求内容使用了CDN之后：localDNS-rootDNS-逐级查询到域名授权的DNS记录-向DNS服务器请求最优ip地址-使用该ip去CDN节点服务器返回对应的资源 TCP连接网站请求大部分使用http请求，http协议是使用tcp作为其传输层协议，（应用http、传输tcp、网络ip、数据、物理），http由tcp报文中提取。由于http报文为明文存在一定风险，所以在http报文包裹入tcp报文之前使用ssl对其进行加密。https在原有tcp握手的基础上需要提前进行一个解密握手。https会有时间损耗，需要在安全和性能两者做出权衡。（公钥加密报文，私钥加密公钥） 发送HTTP请求请求报文：请求行（请求方法、内容、协议），请求报头（Accept、Content-Type、Cookie、User-Agent）、请求正文（POST/PUT时会有）响应报文：状态码、响应报头、相应报文状态码：1xx：指示信息–表示请求已接收，继续处理。2xx：成功–表示请求已被成功接收、理解、接受。3xx：重定向–要完成请求必须进行更进一步的操作。4xx：客户端错误–请求有语法错误或请求无法实现。5xx：服务器端错误–服务器未能实现合法的请求。 浏览器解析渲染页面文档来源：https://www.html5rocks.com/en/tutorials/internals/howbrowserswork主要文章：https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#The_rendering_engine总流程： 没有脚本的流程： HTML Parsing: 输出DOM treeHTML不是一种context free grammar，是因为它不同于XML，它允许一些类似标签缺失等的容错分为两部分：tokenize和tree constructionTokenize：状态机实现，初始状态为DATA，遇到&lt;状态改为TAGOPEN，之后遇到第一个a-z的字符状态改为TAGNAME，之后遇到&gt;状态改为DATA，直到&lt;/&gt;，tokenize就commit一个token，Tree Construction：状态机实现。Document Object在token的parser创建时同时创建，每当一个token被commited，constroctor会判断该token跟哪个dom元素相关，新建该token的元素，并添加到开放元素栈（这个栈用于检查标签闭合以及未正常闭合标签）中： css和js的parse过程：Firefox blocks all scripts when there is a style sheet that is still being loaded and parsed.WebKit blocks scripts only when they try to access certain style properties that may be affected by unloaded style sheets.文章的优点：从dom tree的构建的词法分析层面指出一些标签错误以及兼容方式，从语法分析层面指出了类似这种情况应当怎样处理。render tree构建过程中，构建方法对head标签以及display:none的标签不予插入树结构中，而hidden则会存在在结构当中。 Web优化雅虎35条军规：https://juejin.im/post/5b73ef38f265da281e048e51","categories":[{"name":"Reading","slug":"Reading","permalink":"http://keefe.wang/categories/Reading/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://keefe.wang/tags/基础知识/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://keefe.wang/tags/JavaScript/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://keefe.wang/tags/读书笔记/"},{"name":"HTTP","slug":"HTTP","permalink":"http://keefe.wang/tags/HTTP/"}]},{"title":"JS语言精粹中的精粹","slug":"2017-10-10-The-Good-Part-of-JavaScripts-The-Good-Part","date":"2017-10-10T04:00:00.000Z","updated":"2020-10-20T08:55:20.270Z","comments":true,"path":"2017/10/10/2017-10-10-The-Good-Part-of-JavaScripts-The-Good-Part.html","link":"","permalink":"http://keefe.wang/2017/10/10/2017-10-10-The-Good-Part-of-JavaScripts-The-Good-Part.html","excerpt":"《JavaScript语言精粹》这本书可谓是JavaScript这门语言的几乎所有知识点的总结，相当于考试之前要画的重点。尽管书中对于各个知识点的介绍比较少，但是知识点覆盖很全，可以进行反复阅读和积累。下面就对这本书中的知识点进行一个整理和总结。","text":"《JavaScript语言精粹》这本书可谓是JavaScript这门语言的几乎所有知识点的总结，相当于考试之前要画的重点。尽管书中对于各个知识点的介绍比较少，但是知识点覆盖很全，可以进行反复阅读和积累。下面就对这本书中的知识点进行一个整理和总结。 语法这一部分主要总结JavaScript中的语言结构和相关语法知识点。 空白：空格一般是可以省略，但是对于var that = this;这种语句var和that之间的空格是必须保留的，而且为了代码美观，也要适当使用空格。 注释：使用/* */这种风格的注释在遇到正则表达式中出现/时很容易出错，所以*建议使用//的注释方式。 标识符：只能使用字母、$、_开头，其中也只能使用字母、数字或下划线。避免使用保留字作为标识符。 数字：JS中只有一个数字类型，内部表示为64位浮点数，一定程度可以避免溢出问题；NaN是一个数值，不等于任何值（包括自己），有isNaN(number)方法；Infinity表示无限大；数字拥有方法，也可以使用Math对象的方法对数字进行操作。 字符串：由单引号/双引号包括，\\开头是转义字符。在ES5中，JS中所有字符都是16位Unicode；字符串有.length属性，不可变，但是可以通过一些方法对其进行操作。 语句：switch、while、for、do可有前置标签label，配合break语句使用 if语句中可以作为假值的条件有：false、null、undefined、’’、0、NaN，其他都作为真值条件； for语句中可以使用for in语句对对象或者类对象的属性/键名进行枚举，但是要确保该属性是否来自该对象还是原型链，使用if(object.hasOwnProperty(variable))进行确定； 表达式：注意运算符的优先级；typeof运算符可产生六个值（字符串）number、string、boolean、undefined、function和object； 字面量： 函数： 对象JavaScript中的简单数据类型有Number、String、Bool、Null、undefined，这些类型都不可变（但是数字、字符串和布尔值有一些方法），其他的数据类型都属于对象Object。 对象字面量： 1234var stooge = &#123; \"first-name\": \"Jerome\", //不合法的属性名要用\"\"包括 last_name: \"Howard\" &#125; 检索：对象的属性检索方式有两种，一种是","categories":[{"name":"Document","slug":"Document","permalink":"http://keefe.wang/categories/Document/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://keefe.wang/tags/基础知识/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://keefe.wang/tags/JavaScript/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://keefe.wang/tags/读书笔记/"}]},{"title":"形状文法简介","slug":"2017-10-08-shape-grammar-learning-notes","date":"2017-10-08T04:00:00.000Z","updated":"2020-10-20T08:55:17.801Z","comments":true,"path":"2017/10/08/2017-10-08-shape-grammar-learning-notes.html","link":"","permalink":"http://keefe.wang/2017/10/08/2017-10-08-shape-grammar-learning-notes.html","excerpt":"形状文法（shape grammar）最早由George Stiny和James Gips在1972年提出，是一种用带符号的形状作为基本要素，用语法结构分析和产生新的形状的设计推理方法，是一种以运算规律为主的设计方法。最早运用于绘画、雕塑和建筑设计领域，后被推广到工业设计领域。我的毕设开题之后，是实验室和阿里一起合作的项目中的一个系统实现，其中大量地使用到了形状文法的方法，所以有必要对该研究进行一些了解和知识点的整理。","text":"形状文法（shape grammar）最早由George Stiny和James Gips在1972年提出，是一种用带符号的形状作为基本要素，用语法结构分析和产生新的形状的设计推理方法，是一种以运算规律为主的设计方法。最早运用于绘画、雕塑和建筑设计领域，后被推广到工业设计领域。我的毕设开题之后，是实验室和阿里一起合作的项目中的一个系统实现，其中大量地使用到了形状文法的方法，所以有必要对该研究进行一些了解和知识点的整理。 概念更加简洁的概念：形状文法是一种计算机辅助设计方法，它可以按照人们的设计思想和要求，依据一定的规则产生新的形状。形状是指有限直线段的组合，并且带有符号标记，以指示形状生成的方向；规则是指对形状进行改变的规定。广义地来讲，形状文法是对已有产品特征的分析、描述和归纳；再现和发展原有产品特征，形成新的风格 形状文法的定义： 形状文法定义为四元组，即SG＝(S, L, R, I)。其中，Ｓ为形状的有限集合；Ｌ为符号的有限集合；Ｒ为规则的有限集合，规则的基本形式为α → β，α是一个带符号形状，α∈(S, L)+，β也是一个带符号形状，β∈(S, L)，(S, L)＋是一个形状和符号所组成的集合，（S, L）则是（S, L）+∪（SΦ, L）；Ｉ为初始形状，I∈(S, L)+．一个形状文法定义的形状集合称为语言，这个语言包含所有的由形状文法生成的无符号形状或带符号形状，其中的每一个形状都是通过应用形状规则从初始形状派生出来的，如下图所示： 基础的形状文法规则有生成性规则和衍生性（修改性）规则，衍生性规则是在生成性规则的基础上进行更多参数和更多步骤的规则变化，能够生成更加复杂的纹样和图案。 形状文法应用流程： 以纹样的形状文法生成为例来说，最基本的步骤分为三步： 纹样研究，对传统纹样及相关文化背景进行研究以锁定目标纹样。目标纹样应为传统纹样的代表，能够反映特定的文化特色。再针对目标纹样进行特征分析，包括纹样主题纹样构图规律、骨骼形式、纹样元素组织方式等信息。 形状演变，对第一部分得到的典型图形运用形状文法的规则进行演变，生成基本图形单元。再对基本图形单元进行派生，以得到多种创新纹样元素。 方案生成，设计师对派生出来的多种纹样元素进行筛选，再以纹样设计文法为约束对纹样元素进行合理组织、重构，以生成新的纹样设计方案。 形状文法实施过程 问题定义：即对即将要使用形状文法的客体进行研究问题的确定，一般从逻辑推理的方法得出对问题的定义； 初始形状确定： 收集样本：选定某个领域的客体实例作为研究对象，广泛收集该领域各个发展阶段的图片，将这些图片进行整理、分类，去除类型接近的图片，找出代表性的图片，将其制作成可供调查的样本，并以一定的方式编号（labeling）。 专家访谈：邀集相关的专家进行访谈，一般应包括资深设计师和深度使用者。访谈的主要目的首先在于对影响该纹理特征进行分类，然后对各类特征的重要程度做出主观评价，以确定各个因子的权重．再根据纹理分类和专家的直观经验，列举出该领域实例主要的可识别特征，为进行下一步设计形态分析做准备。 设计形态分析：设计形态分析法是由荷兰学者Ware，具体过程是： 将选取的产品样本图片和专家列举的产品显性特征制成调查表，的受试者选择面要广，包括专家、设计师、一般用户等，年龄、性别和职业要分布合理。 由受试者将产品样本一一对照各个形态特征进行判断，以“强”、“弱”、“无”作为标准，并对应以不同分数。 对调查结果进行统计分析，判断并提取产品的风格特征。 形状规则的确定： 生成性规则：生成性规则的形式可分两种：添加，即从无到有；置换，以一个完全不同的全新形态代替原形态． 修改性规则：“修改”就是指对原有形态的改变、变形、调整．由于生成性规则是对纹理本质的“变异”，因而修改性规则应侧重于“遗传”，否则纹理的显性特征变得面目全非，品牌的延续将无从谈起。例如，可以使用仿射变换（affine transform）进行变形，或者对整体轮廓曲线采用贝塞尔曲线（Bezier curve）进行描述并进行非精确性变形。 设计要求与约束规则： 在完成以上两项初始形状和文法规则的确立之后，还要对于已确定问题的边界和约束进行规定。 目前形状文法落实进展： 形状生成：Tranglify算法生成随机背景 形状布局：通过布局风格（平铺/随机）、布局区域（全局/环绕）、形状旋转和形状缩放的python代码实现 颜色渲染：图片颜色整个色盘选择替换","categories":[{"name":"Research","slug":"Research","permalink":"http://keefe.wang/categories/Research/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://keefe.wang/tags/基础知识/"},{"name":"形状文法","slug":"形状文法","permalink":"http://keefe.wang/tags/形状文法/"}]},{"title":"前端要学习的http基础知识","slug":"2017-10-05-http-primary-knowledge-in-Frontend","date":"2017-09-21T04:00:00.000Z","updated":"2020-10-20T09:48:27.891Z","comments":true,"path":"2017/09/21/2017-10-05-http-primary-knowledge-in-Frontend.html","link":"","permalink":"http://keefe.wang/2017/09/21/2017-10-05-http-primary-knowledge-in-Frontend.html","excerpt":"HTTP协议基础HTTPHyper Text Transfer Protocol(超文本传输协议)，基于TCP/IP通信协议来传递数据，默认端口号80。HTTP协议是前端技术基础中的基础，所以掌握其相关知识也是必要技能之一。","text":"HTTP协议基础HTTPHyper Text Transfer Protocol(超文本传输协议)，基于TCP/IP通信协议来传递数据，默认端口号80。HTTP协议是前端技术基础中的基础，所以掌握其相关知识也是必要技能之一。 HTTP工作原理工作于C/S架构上，浏览器作为http客户端通过URL向WEB服务器（Apache、IIS）发送所有请求 HTTP的特点 无连接：每次连接只处理一个请求（节省传输时间） 媒体独立：任何类型内容数据都可通过HTTP发送（制定MIME-type内容类型） 无状态：对事务没有记忆能力，若要在当前状态进行后续处理，则必须重传（导致每次连接传送的数据量增大，但是应答比较快） HTTP请求与返回 HTTP请求： 123GET / HTTP/1.0User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)Accept: */* 其中第一行为请求命令，命令有POST/GET/PUT/DELETE等等，且请求的资源后面要添加所使用的协议版本，详见附录；第三行中的Accept指定的是可以接受的MIME type，与回应头中的Content-Type字段相对应。 HTTP回应： 12345678910HTTP/1.0 200 OK Content-Type: text/plainContent-Length: 137582Expires: Thu, 05 Dec 1997 16:00:00 GMTLast-Modified: Wed, 5 August 1996 15:55:28 GMTServer: Apache 0.84&lt;html&gt; &lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt; 回应信息分为两部分，一部分是回应头信息，一部分是回应的数据和内容。其中第一行是&quot;协议版本 + 状态码（status code） + 状态描述&quot;；第二行是用来指定数据格式的&quot;Content-Type字段&quot;。 各版本HTTP协议的区别 HTTP/0.9 只有GET一个请求命令，而且服务器只能回应HTML格式的字符串，服务器发送完毕，TCP连接就关闭。 HTTP/1.0 完善了POST和HEAD命令，服务器可以回应更多种格式的（MIME type/多种压缩方法）数据，但是需要在回应中有一个header来描述元数据。另外添加了状态吗、权限、缓存等等。 但是与0.9版本相同的是，每个TCP连接只能发送一个请求，发送完成就关闭连接。所以有一个hack方法：Connection字段设置为keep-alive来实现保持连接和请求复用。 HTTP/1.1 添加了PUT/PATCH/HEAD/OPTIONS/DELETE请求命令，以及HOST字段指定服务器的域名（该字段可以将请求发往同一台服务器的不同网站，是虚拟主机实现的基础）； 最大的改动是默认服务器连接为keep-alive，不需要声明Connection字段，但是如果主动关闭连接需要添加Connection: close的字段；添加管道机制，即在同一个TCP连接里面，客户端可以同时发送多个请求；在管道机制之上需要有区分数据包的机制，该版本提供了Content-Length字段；有了管道机制，就可以实现分块传输编码（不使用Content-Length字段的方法），只需要设置Transfer-Encoding字段为chunked即可，每一个返回的内容数据块之前苏姚添加该数据块的长度，最后一个长度需要表示为0来标识回应数据结束。 1.1版本中唯一的缺点是数据通信单线程按次序进行，非常容易堵塞，所以要求网页设计时减少请求书并多开持久连接； HTTP/2.0 该版本主要有四个亮点： 二进制协议：头信息和数据块都可以是二进制（被称为头信息帧和数据帧），更加容易解析； 多工通信：在同一个连接里，S/C两端可以同时发送多个请求和回应，避免单线程堵塞；这个技术也为服务器推送奠定了基础； 数据流： 在多工通信的前提下，请求和回应数据必须进行标记（ID），所以提出了数据流概念，奇数表明客户端发出数据流，偶数则为服务器发出；另外客户端还可以指定请求数据流的优先级； 头信息压缩：针对Cookie、User Agent字段的重复和冗余，引入头信息压缩机制，可以使用gzip和compress压缩后再发送，提高速度。 附录HTTP header字段（通用头，请求头，响应头，实体头） 通用头：Cache-Control/Connection/Date/Pragma/Transfer-Encoding/Upgrade/Via 请求头： 字段名 含义 示例 Accept 指定客户端能够接收的内容类型 Accept-Charset 浏览器可以接受的字符编码集 Accept-Encoding 指定浏览器可以支持的web服务器返回内容压缩编码类型 Accept-Language 浏览器可接受的语言 Accept-Ranges 可以请求网页实体的一个或者多个子范围字段 Authorization HTTP授权的授权证书 Cookie HTTP请求发送时，会把保存该请求域名下所有cookie发给服务器 Content-Length 请求的内容长度 Content-Length: 348 Content-Type 请求的与实体对应的MIME信息 Expect 请求的特定的服务器行为 Expect: 100-continue From 发出请求的用户的Email From: user@email.com Host 指定请求的服务器的域名和端口号 Host: www.zcmhi.com If-Match 只有请求内容与实体相匹配才有效 If-Modified-Since 若请求部分在指定时间后被修改则请求成功，未被修改则返回304代码 If-None-Match 如果内容未改变返回304代码 If-Range 如果实体未改变，服务器发送客户端丢失部分，否则发送整个实体 If-Unmodified-Since 只在实体在指定时间之后未被修改才请求成功 Max-Forwards 限制信息通过代理和网关传送的时间 Max-Forwards: 10 Proxy-Authorization 连接到代理的授权证书 Range 只请求实体的一部分，指定范围 Range: bytes=500-999 Referer 先前网页的地址，当前请求网页紧随其后,即来路 User-Agent 包含发出请求的用户信息 User-Agent: Mozilla/5.0 (Linux; X11) Warning 关于消息实体的警告信息 响应头： 字段名 含义 示例 Accept-Ranges 表明服务器是否支持指定范围请求及哪种类型的分段请求 Age 从原始服务器到代理缓存形成的估算时间（以秒计，非负） Age: 12 Allow 对某网络资源的有效的请求行为POST/GET等，不允许则返回405 Content-Encoding web服务器支持的返回内容压缩编码类型 Content-Encoding: gzip Content-Language 响应体的语言 Content-Language: en,zh Content-Length 响应体的长度 Content-Length: 348 Content-Location 请求资源可替代的备用的另一地址 Content-Location: /index.htm Content-MD5 返回资源的MD5校验值 Content-Range 在整个返回体中本部分的字节位置 Content-Type 返回内容的MIME类型 Content-Type: text/html; charset=utf-8 ETag 请求变量的实体标签的当前值 Expires 响应过期的日期和时间 Expires: Thu, 01 Dec 2010 16:00:00 GMT Last-Modified 请求资源的最后修改时间 Location 用来重定向接收方到非请求URL的位置来完成请求或标识新的资源 Proxy-Authenticate 它指出认证方案和可应用到代理的该URL上的参数 Refresh 应用于重定向或一个新的资源被创造，在5秒之后重定向 Retry-After 如果实体暂时不可取，通知客户端在指定时间之后再次尝试 Retry-After: 120 Server web服务器软件名称 Server: Apache/1.3.27 (Unix) (Red-Hat/Linux) Set-Cookie 设置Http Cookie Trailer 指出头域在分块传输编码的尾部存在 Trailer: Max-Forwards Vary 告诉下游代理是使用缓存响应还是从原始服务器请求 Vary: * Warning 警告实体可能存在的问题 Warning: 199 Miscellaneous warning WWW-Authenticate 表明客户端请求实体应该使用的授权方案 HTTP请求方法GET（请求制定的页面信息，并返回实体主体）HEAD（与GET相似，只用于获取报头）POST（向制定资源提交数据进行处理请求，表单或者上传文件等，会导致新资源建立或资源修改）PUT（从客户端向服务器传送的数据取代制定的文档内容）CONNECT（HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器）OPTIONS（允许客户端查看服务器的性能）TRACE（回显服务器收到的请求，主要用于测试诊断）DELETE（删除删除服务器上的某资源） 常见的MIME typetext/plaintext/htmltext/cssimage/jpegimage/pngimage/svg+xmlaudio/mp4video/mp4application/javascriptapplication/pdfapplication/zipapplication/atom+xml","categories":[{"name":"Document","slug":"Document","permalink":"http://keefe.wang/categories/Document/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://keefe.wang/tags/基础知识/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://keefe.wang/tags/JavaScript/"},{"name":"Http","slug":"Http","permalink":"http://keefe.wang/tags/Http/"}]},{"title":"Babel的使用方法","slug":"2017-09-21-babel-document-study","date":"2017-09-21T04:00:00.000Z","updated":"2020-10-20T09:48:27.903Z","comments":true,"path":"2017/09/21/2017-09-21-babel-document-study.html","link":"","permalink":"http://keefe.wang/2017/09/21/2017-09-21-babel-document-study.html","excerpt":"Babel是一个广泛使用的转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。","text":"Babel是一个广泛使用的转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。 使用命令行转码 安装babel-cli：npm install --global babel-cli 使用： 转码结果输出到标准输出：babel compiled.js 转码结果写入一个文件：babel source.js -o compiled.js 整个目录转码：babel src -d lib 生成source map文件：babel src -d lib -s 在package.json中使用babel-cli 在项目中安装babel-cli：npm install --save-dev babel-cli 在package.json中进行配置（使用npm run build就可以进行babel转码）： 123456789&#123; // ... \"devDependencies\": &#123; \"babel-cli\": \"^6.0.0\" &#125;, \"scripts\": &#123; \"build\": \"babel src -d lib\" &#125;,&#125; 安装和注册 安装 ES2015转码规则 npm install –save-dev babel-preset-es2015 react转码规则 npm install –save-dev babel-preset-react ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个 npm install –save-dev babel-preset-stage-0 npm install –save-dev babel-preset-stage-1 npm install –save-dev babel-preset-stage-2 npm install –save-dev babel-preset-stage-3 如果是想使用比较新的语法时，比如ES7中的async/await语法，选择安装stage-3是比较稳妥的。在安装好之后，需要在Babel的配置文件中进行注册，在项目的根目录下新建.babelrc文件并进行配置： 12345678&#123; \"presets\": [ \"es2015\", \"react\", \"stage-2\" ], \"plugins\": []&#125; webpack配置babel 安装：安装方式仍如上一步npm安装方式 配置： 123456789101112131415161718192021222324//webpack1.0module: &#123; loaders: [ &#123; test: /\\.js$/, exclude: /(node_modules|bower_components)/, loader: \"babel\", query: &#123; presets: ['es2015', 'stage-3'] &#125; &#125;, ]&#125;//webpack3.0，preset如果已经在package.json中指定（`babel:&#123;\"presets\": [\"lastest\"]&#125;`），这里可以不用配置module: &#123; rules: &#123; &#123; test: /\\.js$/, use: 'babel-loader', exclude: /(node_modules|bower_components)/, &#125; &#125;&#125; 开发环境使用babel-registerbabel-register的作用是在模块使用require命令进行引入时，对该命令引入的模块进行babel的转码（只要是js/jsx/es/es6类型文件）： 安装babel-register：npm install --save-dev babel-register 加载babel-register：require(&quot;babel-register&quot;);require(&quot;./index.js&quot;);，即可对index.js进行转码（注意：register不会对当前js文件进行转码） 使用babel-core的API进行转码 安装：npm install babel-core --save 使用： 123var babel = require('babel-core');// 字符串转码babel.transform('code();', options); babel-polyfillBabel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。举例来说，ES6在Array对象上新增了Array.from方法。Babel就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。[^1] 例如之前在学习koa2的过程中，遇到了async/await的情况，就必须安装polyfill才能够正常加载。","categories":[{"name":"Document","slug":"Document","permalink":"http://keefe.wang/categories/Document/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://keefe.wang/tags/基础知识/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://keefe.wang/tags/JavaScript/"},{"name":"Babel","slug":"Babel","permalink":"http://keefe.wang/tags/Babel/"}]},{"title":"LESS官方文档学习笔记","slug":"2017-05-10-LESS-document-note","date":"2017-08-02T04:00:00.000Z","updated":"2020-10-20T08:55:07.530Z","comments":true,"path":"2017/08/02/2017-05-10-LESS-document-note.html","link":"","permalink":"http://keefe.wang/2017/08/02/2017-05-10-LESS-document-note.html","excerpt":"LESS是一种动态样式语言。LESS将CSS赋予了动态语言的特性，如变量，继承，运算，函数。LESS既可以在客户端上运行 (支持IE 6+，Webkit， Firefox)，也可以借助Node.js或者Rhino在服务端运行。","text":"LESS是一种动态样式语言。LESS将CSS赋予了动态语言的特性，如变量，继承，运算，函数。LESS既可以在客户端上运行 (支持IE 6+，Webkit， Firefox)，也可以借助Node.js或者Rhino在服务端运行。 使用方式 客户端使用 在页面顶端加入下面代码，在服务器环境下可以使用less文件： 12&lt;link rel=\"stylesheet/less\" type=\"text/css\" href=\"styles.less\"&gt;&lt;script src=\"less.js\" type=\"text/javascript\"&gt;&lt;/script&gt; 注意，LESS文件引入时rel的值为stylesheet/less；less.js一定要在LESS文件引用之后的位置。 在服务器端使用 使用npm工具管理器在服务器端安装LESS，之后可以在Node中调用编译器，类似于： 1234var less = require('less');less.render('.class &#123; width: 1 + 1 &#125;', function (e, css) &#123; console.log(css);&#125;); 可以通过向解析器传递参数对LESS进行配置： 1234567var parser = new(less.Parser)(&#123; paths: ['.', './lib'], // Specify search paths for @import directives filename: 'style.less' // Specify a filename, for better error messages&#125;);parser.parse('.class &#123; width: 1 + 1 &#125;', function (e, tree) &#123; tree.toCSS(&#123; compress: true &#125;); // Minify CSS output&#125;); 也可以通过命令行的方式调用LESS解析器对LESS文件进行解析或编译： 12$ lessc styles.less$ lessc styles.less &gt; styles.css 语法注释完全支持CSS中的注释方法。 变量LESS中的变量是完全的“常量”，由@符号引导，且只能够定义一次： 123456789@nice-blue: #5B83AD;@light-blue: @nice-blue + #111; @fnord: \"I am fnord.\";@var: 'fnord';.text&#123; color: light-blue; content: @@var;&#125; 混合LESS中定义好通用的class属性集之后，可以在另一个属性集中调用： 12345678.bordered &#123; border-top: dotted 1px black; border-bottom: solid 2px black;&#125;.post a &#123; color: red; .bordered;&#125; 带参数混合 可以像函数的参数一样为样式属性集合名称中添加带默认值的参数（参数可设置多个，使用逗号进行分割，可以使用@arguments代替所有参数出现在样式属性集合体之中），该混合方法最适合隐藏某属性集合但需要引用该属性集合时使用。 12345678910111213141516171819202122/*带有参数的混合方法*/.border-radius (@radius: 5px) &#123; border-radius: @radius; -moz-border-radius: @radius; -webkit-border-radius: @radius;&#125;#header &#123; .border-radius(4px);&#125;/* 使用@arguments代替所有参数进行表达 其中传参个数可以少于参数数量，但是参 数的位置必须对应，中间参数位置不可空*/.box-shadow (@x: 0, @y: 0, @blur: 1px, @color: #000) &#123; box-shadow: @arguments; -moz-box-shadow: @arguments; -webkit-box-shadow: @arguments;&#125;.special-box-shadow &#123; .box-shadow(2px, 5px);&#125; 模式匹配和导引表达是 模式匹配 如果想根据传入的参数来改变混合的默认呈现，可以使用模式匹配方式（相当于将第一个参数设置为可变参数，该参数可以设置switch的选项来启动相应的模式）： 123456789101112131415.mixin (dark, @color) &#123; color: darken(@color, 10%);&#125;.mixin (light, @color) &#123; color: lighten(@color, 10%);&#125;/*接受任意值，相当于默认值*/.mixin (@_, @color) &#123; display: block;&#125;@switch: light; .someClass &#123; .mixin(@switch, #888);&#125; 引导 当我们想根据表达式进行匹配，而非根据值和参数匹配时，导引就显得非常有用。如果你对函数式编程非常熟悉，那么你很可能已经使用过导引。 导引中可以用的比较运算符有：&gt;、&gt;=、=（这里相当于==）、=&lt;、&lt; 12345678910111213/* 使用when语句判断条件，lightness()是一个 判断颜色亮度的函数。*/.mixin (@a) when (lightness(@a) &gt;= 50%) &#123; background-color: black;&#125;.mixin (@a) when (lightness(@a) &lt; 50%) &#123; background-color: white;&#125;.mixin (@a) &#123; color: @a;&#125; when后面所跟的条件，值为布尔true时才会执行解析，而LESS中的除去上面的**比较结果返回值**以及**关键词true**以外的值都视为布尔false： 12345/*下面两个语句含义相同*/.truth (@a) when (@a) &#123; color: black; &#125;.truth (@a) when (@a = true) &#123; color: black; &#125;/*下面一句是不会匹配任何条件，也不执行*/.someClass &#123; .truth(255); &#125; 导引之后可以有**多个条件**，一般使用`(condition1),(condition2),...`的形式来表示。符合其中的任意一个条件，匹配就可以成功，属性集才会被执行，这个形式相当于使用关键词*or*来连接条件实现或门。另外，可以使用关键词*and*实现与门，使用*when not*关键词实现非门。 导引语句when之后的判断条件中可以是**不含参数**的判断条件，也可以是对多个参数的比较等： 1234.mixin (@a) when (@media = mobile) &#123; ... &#125;.mixin (@a) when (@media = desktop) &#123; ... &#125;.max (@a, @b) when (@a &gt; @b) &#123; width: @a &#125;.max (@a, @b) when (@a &lt; @b) &#123; width: @b &#125; 其中判断语句中可以使用一些判断函数，如常见的类型判断：`iscolor()`，`isnumber()`，`isstring()`，`iskeyword()`，`isurl()`；常见的单位量判断：`ispixel()`，`ispercentage()`，`isem()`。 嵌套规则此处的嵌套，指的是对上级重复的派生选择器进行嵌套方式的简写，例如： 12345678910#header &#123; color: black; &#125;#header .navigation &#123; font-size: 12px;&#125;#header .logo &#123; width: 300px; &#125;#header .logo:hover &#123; text-decoration: none;&#125; 可以简写为： 12345678910#header &#123; color: black; .navigation &#123; font-size: 12px; &#125; .logo &#123; width: 300px; &amp;:hover: text-decoration: none; &#125;&#125; 这里需要注意的是，对于:hover和:focus这样的伪类等，需要使用串联选择器而非后代选择器时（串联选择器之间无空格，后代选择器有）应该使用&amp;符号置于前面： 12345678.bordered &#123; &amp;.float &#123; float: left; &#125; /*输出的是.bordered.float选择器*/ .top &#123; margin: 5px; &#125; /*输出的是.bordered .top选择器*/&#125; 运算数字、颜色或者变量都可以参与运算，且支持并向下兼容带有单位的数值： 12345678@base: 5%;@filler: @base * 2; /*返回10%*/@other: @base + @filler; /*返回15%*/color: #888 / 4;background-color: @base-color + #111;height: 100% / 2 + @filler;@var: 1px + 5; /*输出结果是6px*/width: (@var + 5) * 2; 函数LESS中提供了非常丰富且方便使用的函数，包括有color函数、字符串函数、数学函数等等，下面主要介绍一下color函数，其余的函数可以在官方的API中查询使用^1 Color函数LESS提供的颜色运算函数，本质是先把RGB格式转化成HSL（就是色调、饱和度和亮度三维空间）色彩空间，然后再通道级别进行操作： 123456789101112131415161718hue(@color); /* 返回该颜色的hue通道值 */saturation(@color); /* 返回该颜色的饱和度值 */lightness(@color); /* 返回颜色的亮度值 */lighten(@color, 10%); /* 颜色亮度提高10% */darken(@color, 10%); /* 颜色亮度降低10% */saturate(@color, 10%); /* 颜色饱和度提高10% */desaturate(@color, 10%); /* 颜色饱和度降低10% */fadein(@color, 10%); /* 颜色透明度降低10% */fadeout(@color, 10%); /* 颜色透明度提高10% */fade(@color, 50%); /* 颜色透明度变为50% */spin(@color, 10); /* 在色轮上顺时针旋转10°spin(@color, -10); /* 在色轮上逆时针旋转10°mix(@color1, @color2); /* 两种颜色的混色 命名空间为了对CSS进行更好的封装，可以将一些变量或混合模式打包起来，如： 123456789101112131415#bundle &#123; .button () &#123; display: block; border: 1px solid black; background-color: grey; &amp;:hover &#123; background-color: white &#125; &#125; .tab &#123; ... &#125; .citation &#123; ... &#125;&#125;/* 使用&gt;符号来进行引入 */#header a &#123; color: orange; #bundle &gt; .button;&#125; 作用域LESS中的作用域类似于JS中原型链，首先会从本地查找变量或者混合模块，如果没找到的话会去父级作用域中查找，直到找到为止. importing可以通过@import “less-file-name.less”，其中.less的后缀是可选的。 字符串插值变量可以通过使用@{someName}的方式来将变量放入字符串中，例如： 12@base-url: \"http://assets.fnord.com\";background-image: url(\"@&#123;base-url&#125;/images/bg.png\"); 避免编译当我们需要让一些语句失去作用，避免编译这些语句时，可以在语句字符串前面加上~，例如： 123.class &#123; filter: ~\"ms:alwaysHasItsOwnSyntax.For.Stuff()\";&#125; 在LESS中使用JavaScript通过反单引号``的形式包围： 12@str: \"hello\";@var: ~`\"@&#123;str&#125;\".toUpperCase() + '!'`;","categories":[{"name":"Document","slug":"Document","permalink":"http://keefe.wang/categories/Document/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://keefe.wang/tags/基础知识/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://keefe.wang/tags/JavaScript/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://keefe.wang/tags/读书笔记/"}]},{"title":"ES6入门必须了解的知识（上）","slug":"2017-08-02-ES6-Must-Know-Keypoint-Note","date":"2017-08-02T04:00:00.000Z","updated":"2020-10-20T08:55:12.173Z","comments":true,"path":"2017/08/02/2017-08-02-ES6-Must-Know-Keypoint-Note.html","link":"","permalink":"http://keefe.wang/2017/08/02/2017-08-02-ES6-Must-Know-Keypoint-Note.html","excerpt":"最近一段时间的实习期间，团队进行了一次ESLint规范的调整和文档改进，里面涉及到了非常多ES6的内容，而在之前热力图项目中也用到了像Promise对象、async函数等的知识，所以专门参考阮一峰写的《ECMAScript6入门》一书对ES6的一些重要知识点进行一次整理。","text":"最近一段时间的实习期间，团队进行了一次ESLint规范的调整和文档改进，里面涉及到了非常多ES6的内容，而在之前热力图项目中也用到了像Promise对象、async函数等的知识，所以专门参考阮一峰写的《ECMAScript6入门》一书对ES6的一些重要知识点进行一次整理。 Babel转码器Babel是可以将ES6代码转为ES5代码的转码器。 配置文件 .babelrc 该配置文件是使用Babel工具和模块必须的，存放在项目的根目录下，用来设置转码规则和插件，基本格式如下 1234&#123; \"presets\": [], \"plugins\": []&#125; 其中presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。一般安装最新的的规则集 npm install --save-dev babel-preset-latest ，然后，配置文件应该如下 12345678&#123; \"presets\": [ \"latest\", \"react\", \"stage-2\" ], \"plugins\": []&#125; 命令行转码babel-cli 安装命令： npm install --global babel-cli 基本用法（全局环境下）： 转码结果输出到标准输出： babel example.js 转码结果写入一个文件： babel example.js --out-file compiled.js 整个目录转码： babel src --out-dir lib 建议将babel-cli安装在项目目录下 安装命令： npm install --save-dev babel-cli; 改写package.json 12345678&#123; \"devDependencies\": &#123; \"babel-cli\": \"^6.0.0\" &#125;, \"scripts\": &#123; \"build\": \"babel src -d lib\" &#125;&#125; 转码命令（在项目目录下）： npm run build; ES6的REPL环境babel-node： babel-node随babel-cli工具安装，执行 babel-node 进入REPL环境可以直接运行命令了 babel-register babel-register木块改写require命令，可以使文档中使用require加载的.js/.jsx/.es/.es6后缀的文件先进行babel转码： 局部安装： npm install --save-dev babel-register 使用（前必须先加载babel-register）： 12require(\"babel-register\");require(\"./index.js\"); babel-core：当代码需要调用Babel的API进行转码时 安装： npm install babel-core --save 项目中调用： 123456789101112131415161718var babel = require('babel-core'); // 字符串转码babel.transform('code();', options);// =&gt; &#123; code, map, ast &#125; // 文件转码（异步）babel.transformFile('filename.js', options, function(err, result) &#123; result; // =&gt; &#123; code, map, ast &#125;&#125;); // 文件转码（同步）babel.transformFileSync('filename.js', options);// =&gt; &#123; code, map, ast &#125; // Babel AST转码babel.transformFromAst(ast, code, options);// =&gt; &#123; code, map, ast &#125; babel-polyfill Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。如果想让这个方法运行，必须使用babel-polyfill Traceus转码器 直接插入网页 在线转换 命令行转换 常量和变量除了ES5提出的var和function两种声明变量的方法，ES6提出了let和const命令，以及import命令和class命令。所以ES6中一共有六种声明变量的方法。 let和const命令 let命令 ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 基本用法：特别适合在for循环计数器中使用，而且循环体是循环语句的自作用域： 123456789101112var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 可以避免闭包中只能读取最后一个值 for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc'; console.log(i);&#125; // abc 特点 不存在变量提升（变量提升是指变量在声明之前可以使用但是值为undefined） 暂时性死区：只要块中有let声明变量语句，该变量在该块中就必须服从let语句的规则（const也是如此），所以typeof也是不安全的 不允许重复声明：包括在相同作用域内禁止重复声明同一个变量（只要出现let就不允许，包括var），以及函数内部重新声明参数 块级作用域 由于内层变量可能会覆盖外层变量，用来计数的循环变量泄露成为全局变量。 let实际上为JavaScript新增了块级作用域： 1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; 特点 块级作用域可以任意嵌套，但是外层作用域无法读取内层作用域的变量 内层作用域可以定义外层作用域的同名变量 实际上让立即执行函数表达式不再必要（直接将需要立即执行的函数内部代码写在{}块级作用域中即可） 块级作用域与函数声明 ES6明确允许在块级作用域中声明函数（在ES5中函数声明只能在函数作用域或全局作用域中进行），且块级作用域中的函数声明行为类似于let，，但必须在有大括号的情况下成立，且在块级作用域外不可引用。 但是浏览器不遵守上述规定，有自己的行为方式： 允许在块级作用域内声明函数 函数声明类似于var，即会提升到全局作用域或函数作用域的头部 同时，函数声明还会提升到所在的块级作用域的头部 所以尽量不要在块级作用域内声明函数，若非要声明，也应该写成函数表达式而非函数声明语句。 do表达式 块级作用域内的let声明的变量无法在作用域外被访问，所以提出了do表达式，可以使块级作用域表现为表达式并有返回值： 1234let x = do &#123; let t = f(); t * t + 1;&#125;; const命令 声明一个只读的常量，声明之后该值不能改变。所以一旦声明必须赋值！ 特点： 不会被提升； 存在暂时性死区 将一个引用变量声明为常量需要小心（该常量指向引用变量的地址，但是里面的内容是可以修改的，所以对象常量不可以被重新赋值为新的引用变量） 如果想让对象以及对象里的内容只读，那么需要使用 const foo = Object.freeze({}); 顶层对象的属性 顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。但是这样存在很多问题： 没法在编译时报出变量未声明的错误（只能运行时报错） 容易莫名其妙创建全局变量 顶层对象可以随处读写，不利于模块化编程 所以ES6提出了： var命令和function命令声明的全局变量依旧是顶层对象的属性 let命令、const命令和class命令声明的全局变量不属于顶层对象的属性： 12let b = 1;window.b // undefined global对象 ES5中的顶层对象，在浏览器中是window，浏览器和WebWorker里面self也指向顶层对象，在Node里面是global 对于this变量来说，ES5全局环境this返回顶层对象；Node和ES6模块返回当前模块；函数作为对象的方法运行指向对象，否则指向顶层对象，严格模式下返回undefined； 变量的解构赋值 数组的解构赋值 用法： let[a, b, c] = [1, 2, 3]; 只要两边的数组结构模式相同，那么就可以使用这种数组解构赋值。 两种特殊情况： 左边模式变量多于右边数组元素变量，解构不成功，返回undefined 左边模式变量少于右边数组元素变量，解构成功 等号右边不是数组（严格讲，可遍历的数据结构），报错 事实上，只要具有Iterator解构的数据结构，都可以采用数组的形式进行解构赋值，例如 let [x, y, z] = Set([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]); , 默认值：解构赋值允许指定默认值，使用表达式来赋值，但是默认值对应的数组中的位置如果不是严格等于undefined，默认值不会生效： 12let [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 默认值是一个惰性求值的表达式，只有右边数组中没有或者undefined时才会求值 123456789function f() &#123; console.log('aaa');&#125;let [x = f()] = [1]; //此处f()不会求值，因为右边已经赋值成功 let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError 对象的解构赋值 按照对象的同名属性可以进行正确得解构赋值 123456let &#123; bar, foo &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo // \"aaa\"bar // \"bbb\" let &#123; baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz // undefined 其真正的机制为： let { foo: foo, bar: bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; 注意冒号后面的才是真正的变量 所以 let { foo: baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; 中baz才被赋值 这里需要注意的是由let进行声明，不可以重新声明，可以使用var替换，也可以试用一下的方式： 1234567891011let foo;(&#123;foo&#125; = &#123;foo: 1&#125;); // 成功，圆括号必须有，否则会认为是一个代码块而非赋值语句let baz;(&#123;bar: baz&#125; = &#123;bar: 1&#125;); // 成功// 错误的写法let x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error, &#123;&#125;会被理解成一个代码块 // 正确的写法(&#123;x&#125; = &#123;x: 1&#125;); 解构赋值失败会返回undefined，与数组相同，对象也可以用于嵌套结构，牢记冒号前的一般为模式，要分清模式和真正的变量；对象也可以有默认值，默认值的表达式也是惰性求值（任何非undefined的值都会对默认值进行覆盖），常用例子： let { log, sin, cos } = Math; 数组本质是特殊的对象，所以对象解构赋值等号右边可以是一个数组。 字符串的解构赋值 字符串分解为数组： const [a, b, c, d, e] = &#39;hello&#39;; 字符串（是一个对象）属性解构赋值：let {length : len} = &#39;hello&#39;; 数值和布尔值的解构赋值 由于Number和Bool值都是值类型，所以解构赋值前需要转换为引用类型，比如可以使用toString方法： 12let &#123;toString: s&#125; = 123;s === Number.prototype.toString // true 由于undefined和null无法转为对象，所以无法进行解构赋值 函数参数的解构赋值 函数参数的解构赋值就是在函数的参数位置进行解构赋值，可以使用上面提到的数组解构赋值、对象解构赋值、字符串解构赋值等，支持默认值（默认值是当解构失败会返回的值），也可以直接传入数组、对象 1234567891011121314151617function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125; //该处为x,y指定默认值 move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125; //该处为函数的参数指定默认值，这里要进行深入研究 move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] 圆括号问题：尽量不要再解构赋值的模式（等号左边的一堆）中放置圆括号 不能使用圆括号的三种情况 变量声明语句中模式不能带有圆括号 函数参数中模式不能带有圆括号 赋值语句中，不能在模式外/嵌套模式中的一层套圆括号 可以使用圆括号的情况 只有一种：赋值语句的非模式部分可以使用圆括号 解构赋值的用途 交换变量的值 123let x = 1;let y = 2;[x, y] = [y, x]; 从函数返回多个值 1234567891011121314// 返回一个数组function example() &#123;return [1, 2, 3];&#125;let [a, b, c] = example(); // 返回一个对象function example() &#123;return &#123; foo: 1, bar: 2&#125;;&#125;let &#123; foo, bar &#125; = example(); 函数参数的定义 1234567// 参数是一组有次序的值function f([x, y, z]) &#123; /*...*/ &#125;f([1, 2, 3]); // 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; /*...*/ &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取JSON数据（都支持嵌套结构） 12345678910let jsonData = &#123; id: 42, status: \"OK\", data: [867, 5309]&#125;; let &#123; id, status, data: number &#125; = jsonData; console.log(id, status, number);// 42, \"OK\", [867, 5309] 函数参数默认值 1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;; 遍历Map结构 12345678910111213141516171819var map = new Map();map.set('first', 'hello');map.set('second', 'world'); for (let [key, value] of map) &#123; console.log(key + \" is \" + value);&#125;// first is hello// second is world // 获取键名for (let [key] of map) &#123;// ...&#125; // 获取键值for (let [,value] of map) &#123;// ...&#125; 输入模块的指定方法：const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;); 字符串的扩展 字符的Unicode表示法 ES5只限制采用码点在\\u0000~\\uFFFF之间的字符，ES6规定只要将码点放入大括号，就能正确解读（最后JS有z \\z \\172 \\x7A \\u007A \\u{7A}六种表示字符方法）： 1234567891011\"\\u&#123;20BB7&#125;\"// \"𠮷\" \"\\u&#123;41&#125;\\u&#123;42&#125;\\u&#123;43&#125;\"// \"ABC\" let hello = 123;hell\\u&#123;6F&#125; // 123 '\\u&#123;1F680&#125;' === '\\uD83D\\uDE80'// true codePointAt() JS内部字符以UTF-16的格式储存，每个字符固定为2个字节。大于2个字节的字符，charAt()和charCodeAt()都不能读取整个字符，所以引入了codePointAt()，返回十进制码点。想返回十六进制，可以.toString(16) String.fromCodePoint() 可识别大于0xFFFF的字符，与上面的codePointAt()方法正好相反 字符串遍历器接口 ES6可以使用for a of b结构对字符串循环遍历： 1234567891011var text = String.fromCodePoint(0x20BB7); for (let i = 0; i &lt; text.length; i++) &#123;console.log(text[i]);&#125;// 无法识别0xFFFF的码点 for (let i of text) &#123;console.log(i);&#125;// \"𠮷\" .at() 使用垫片库实现&#39;𠮷&#39;.at(0)对0xFFFF字符进行charAt()操作 .normalize() 用来将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。 1234'\\u01D1'.normalize() === '\\u004F\\u030C'.normalize()// true /*该函数可以接收NFC(合成形式)/NFD(分解形式)/NFKC/NFKD作为参数*/ .includes(), .startsWith(), .endsWith() 都是找字符串中是否是包含、以…开始、以…结束的，均返回bool值，接收两个参数，第一个参数为寻找的子串，第二个参数为开始（end是结束）寻找的父串的下标： 12345var s = 'Hello world!'; s.startsWith('world', 6) // true，这里要注意s.endsWith('Hello', 5) // trues.includes('Hello', 6) // false .repeat() 接收一个参数作为重复次数n（n&gt;-1），返回一个重复n次的新字符串： .padStart(), .padEnd() 接收两个参数，一个是指定字符串长度，第二个是用来补全的”补丁字符串”（若补丁字符串超出长度则截取，若第二个参数省略用空格补全，不想要的话使用.trim()）： 12'x'.padStart(5, 'ab') // 'ababx''x'.padEnd(4, 'ab') // 'xaba' 模板字符串 ES6引入模板字符串，使用反引号（`）来标识（可嵌套），可以当做普通字符串，也可以用来定义多行字符串（多行字符串中的空格和缩进都会保留在输出之中）： 12345678910111213141516// 普通字符串`In JavaScript '\\n' is a line-feed.` // 多行字符串`In JavaScript this isnot legal.` console.log(`string text line 1string text line 2`); // 字符串中嵌入变量使用$&#123;表达式、对象属性甚至调用函数等&#125;，牢记&#123;&#125;中最后返回的都是字符串var name = \"Bob\", time = \"today\";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` //字符串里出现`需要转义var greeting = `\\`Yo\\` World!`; 模板编译 标签模板 模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。 当模板字符串里有变量，会将模板字符串先处理成多个参数，再调用函数 处理结果是(stringArray, value1, value2)，处理过程是将所有非变量的部分存在一个字符串数组中，剩下的变量依次一个个排在后面: 1234567891011121314151617var total = 30;var msg = passthru`The total is $&#123;total&#125; ($&#123;total*1.05&#125; with tax)`; function passthru(literals) &#123;var result = '';var i = 0; while (i &lt; literals.length) &#123; result += literals[i++]; if (i &lt; arguments.length) &#123; result += arguments[i]; &#125;&#125;return result;&#125; msg // \"The total is 30 (31.5 with tax)\" “标签模板”重要应用： 过滤HTML字符串，防止用户输入恶意内容 多语言转换（国际化处理） 嵌入其他语言 String.raw() 用来充当模板字符串的处理函数，返回一个斜杠都被转义（斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串，源码如下： 123456789String.raw = function (strings, ...values) &#123; var output = \"\"; for (var index = 0; index &lt; values.length; index++) &#123; output += strings.raw[index] + values[index]; &#125; output += strings.raw[index] return output;&#125; 该函数接受第一个参数是有raw数组属性的的对象 模板字符串的限制：默认会将字符串转义，所以无法嵌入其他语言（例如LaTeX），但是标签模板可以 正则的扩展 RegExp构造函数 ES5中，RegExp构造函数如下： 参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）var regex = new RegExp(&#39;xyz&#39;, &#39;i&#39;); 参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝var regex = new RegExp(/xyz/i); ES6允许有第二个参数（flag）：var regex = new RegExp(/xyz/ig, &#39;i&#39;);，且第二个参数会覆盖表达式中的修饰符 字符串的正则方法： 字符串对象共有4个方法，可以使用正则表达式：match()、replace()、search()和split()。ES6将这4个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。 String.prototype.match 调用 RegExp.prototype[Symbol.match]，以此类推… u修饰符 含义为Unicode模式，处理大于\\uFFFF的Unicode字符 点字符：对于码点大于0xFFFF的Unicode字符，点字符不能识别，必须加上u修饰符 1234var s = '𠮷'; /^.$/.test(s) // false/^.$/u.test(s) // true Unicode字符表示法：使用大括号表示的unicode字符需要加u修饰符/\\u{20BB7}/u.test(&#39;𠮷&#39;) 预定义模式 i修饰符：添加u才能够识别非规范的字母 y修饰符 粘连修饰符，y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。 123456789var s = 'aaa_aa_a';var r1 = /a+/g;var r2 = /a+/y; r1.exec(s) // [\"aaa\"]r2.exec(s) // [\"aaa\"] r1.exec(s) // [\"aa\"]r2.exec(s) // null sticky属性 flags属性 RegExp.escape() s修饰符：dotAll模式 后行断言 Unicode属性类 数值的扩展 二进制和八进制的表示法 二进制0b/0B，八进制0o/0O Number.isFinite(Number), Number.isNaN(Number) 分别检查一个数值是否为有限的、是否为NaN Number.parseInt(Number), Number.parseFloat(Number) 分别将参数（字符串）转换为int和float数据类型 Number.isInteger() 用来判断一个值是否为整数（3和3.0都可以返回true） Number.EPSILON() 一个极小的常量，用来设置一个误差范围来精确浮点数计算： 12345function withinErrorMargin (left, right) &#123; return Math.abs(left - right) &lt; Number.EPSILON;&#125;withinErrorMargin(0.1 + 0.2, 0.3) // truewithinErrorMargin(0.2 + 0.2, 0.3) // false 安全证书和Number.isSafeInteger() JavaScript能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。 Math对象的扩展 Math.trunc方法用于去除一个数的小数部分，返回整数部分,可以接收数字和数字字符串 Math.sign方法用来判断一个数到底是正数、负数、还是零 Math.cbrt方法用于计算一个数的立方根 Math.clz32方法返回一个数的32位无符号整数形式有多少个前导0 Math.imul方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数 Math.fround方法返回一个数的单精度浮点数形式 Math.hypot方法返回所有参数的平方和的平方根 Math.expm1(x)返回ex - 1，即Math.exp(x) - 1 Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x) Math.log10(x)返回以10为底的x的对数 Math.log2(x)返回以2为底的x的对数。如果x小于0，则返回NaN ES6新增了6个三角函数方法： Math.sinh(x) 返回x的双曲正弦（hyperbolic sine） Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine） Math.tanh(x) 返回x的双曲正切（hyperbolic tangent） Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine） Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine） Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent） Math.signbit() Math.signbit()方法判断一个数的符号位是否设置了 指数运算符 两个乘号代表指数运算符 数组的扩展 扩展运算符扩展运算符（spread）是三个点（…），可将一个数组转为用逗号分隔的参数序列。所以该运算符可以用来代替apply调用函数的方式,apply方法是将数组展开为函数的参数，扩展运算符也可以达到此目的。 扩展运算符的应用主要有： 合并数组：[...arr1, ...arr2, ...arr3] 与解构赋值结合：const [first, ...rest] = [1, 2, 3, 4, 5]; 函数返回多个值； 将字符串转化为数组：能够正确识别32位的Unicode字符，最好使用扩展运算符； 实现了Iterator接口的对象： Map、Set解构和Generator函数都可以使用扩展运算符 Array.from() Array.from方法用于将两类对象转为真正的数组：类似数组的对象（DOM操作返回的NodeList集合以及函数内部arguments对象）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map），第一个参数接受一个类数组对象，第二个参数接受一个类map方法对对象进行操作。 12345678910111213141516171819// arguments对象function foo() &#123; var args = Array.from(arguments); // ...&#125;``` 也可以用来进行对数组的复制`arrayCopy = Array.from([1,2,3]);` 扩展运算符（...）也可以将某些数据结构转为数组（必须是部署了Symbol.iterator遍历器接口的对象）： ```javascript// arguments对象function foo() &#123; var args = [...arguments];&#125; // NodeList对象[...document.querySelectorAll('div')] Array.of() ES5中，Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于2个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。 Array.of方法用于将一组值，转换为数组。 1234Array.of() // []Array.of(undefined) // [undefined]Array.of(1) // [1]Array.of(1, 2) // [1, 2] 数组实例的copyWithin() 它接受三个参数，start和end指定要复制的子串，target指定从哪里开始替换:[1, 2, 3, 4, 5].copyWithin(0, 3) // [4, 5, 3, 4, 5] target（必需）：从该位置开始替换数据。 start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数（加数组长度即可）。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 数组实例的find()和findIndex() 数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 123[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10 1findIndex()与find()用法相同，返回寻找到的成员下标 数组实例的fill() fill方法使用给定值，填充一个数组： 12['a', 'b', 'c'].fill(7) // [7, 7, 7]['a', 'b', 'c'].fill(7, 1, 2) // ['a', 7, 'c'] 数组实例的entries(), key()和values() ES6提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 数组实例的includes() Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。该方法属于ES7，但Babel转码器已经支持。 数组的空位 数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。空位不是undefined，undefined是属于有值的！ 函数的扩展 函数参数的默认值 1234567function Point(x = 0, y = 0) &#123; this.x = x; this.y = y;&#125; var p = new Point();p // &#123; x: 0, y: 0 &#125; 如果参数默认值是变量，那么参数就不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。 123456789let x = 99;function foo(p = x + 1) &#123; console.log(p);&#125; foo() // 100 x = 100;foo() // 101 与解构赋值默认值结合使用 1234function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y); &#125;foo(&#123;x: 1&#125;) // 1, 5 **在某些情况下，传入undefined时才会触发参数默认值** 函数的length属性：指函数预期传入参数的个数，返回没有指定默认值时的参数的个数（指定了默认值后length属性失真，从指定默认值的那以为开始失真，而之前没有指定默认值的还是会计入length）：(function (a, b = 1, c) {}).length // 返回1 参数默认值和作用域 一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。 1234567891011121314151617181920212223242526272829var x = 1;function f(x, y = x) &#123; console.log(y);&#125;f(2) // 由于参数初始化自己形成单独作用域，所以y=x=2，不考虑函数外的全局变量let a = 1;function f(b = a) &#123;let a = 2;console.log(b);&#125;f() // 在这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x``` 这个参数默认值的作用域有一个非常不错的应用途径：指定某参数不可忽略，否则抛出错误提示：```javascriptfunction throwIfMissing() &#123; throw new Error('Missing parameter');&#125;function foo(mustBeProvided = throwIfMissing()) &#123; return mustBeProvided;&#125;foo() rest参数 rest参数使用…扩展运算符将多余参数放入数组中，形式为(a, …b),所以该函数可以传入任意数目的参数，该参数也可以使用所有数组特有的方法： 123456789const sortNumbers = (...numbers) =&gt; numbers.sort();function push(array, ...items) &#123; items.forEach(function(item) &#123; array.push(item); console.log(item); &#125;);&#125;var a = [];push(a, 1, 2, 3) 需要注意的是，rest参数之后不能再有其他的参数，函数的length属性也不适用于rest参数。 函数内部严格模式 在ES5中，函数内部可以使用严格模式，在ES2016中则规定只要函数参数使用了默认值、解构赋值、扩展运算符，那么函数内部就不能显式设定严格模式（这是因为函数内部严格模式适用于函数体和函数参数，由于函数执行是先执行函数参数继而执行函数体，所以在函数参数执行的时候无法获知是否使用严格模式，导致报错）。 如果非要在有默认值、解构赋值或扩展运算符在函数参数中出现并需要再函数内设定严格模式，那么可以使用： 全局性的严格模式 使用无参数的立即执行函数将所需函数包含进去，并在立即执行函数中使用严格模式 函数的name属性：返回该函数的函数名 1234var f = function () &#123;&#125;;f.name // \"f\"const bar = function baz() &#123;&#125;;bar.name // \"baz\" 上面代码中显示，函数表达式中如果赋值的是匿名函数，则函数名返回该变量的变量名，若赋值的是具名函数，则返回该具名函数的函数名。 需要注意两点： Function构造函数返回的函数实例，name属性的值为anonymous，(new Function).name // &quot;anonymous&quot; bind返回的函数，name属性值会加上bound前缀(function(){}).bind({}).name // &quot;bound &quot; 箭头函数：var f = v =&gt; console.log(v); 箭头函数是定义函数的简单方法，相当于匿名函数，‘=&gt;’符号左边是函数的参数（如果不需要参数或者需要多个参数，可以直接使用()代替参数），右边是函数体（多余一条语句的代码块需要用{}括起来，如果返回的是一个对象，则该对象需要使用()括起来）。 12//将上面sort函数改进为可以按照大小排序的方法var result = values.sort((a, b) =&gt; a - b); 需要注意的是： 1. 箭头函数体内this对象是定义时所在对象，而非使用时所在对象2. 箭头函数不可以当做构造函数，不可以使用new命令3. 不能使用arguments对象，但是可以使用rest参数代替4. 不能使用yield命令，因此箭头函数不能用作Generator函数 箭头函数还可以进行嵌套： 123456const pipeline = (...funcs) =&gt; val =&gt; funcs.reduce((a, b) =&gt; b(a), val);const plus1 = a =&gt; a + 1;const mult2 = a =&gt; a * 2;const addThenMult = pipeline(plus1, mult2);addThenMult(5)// 12 上述代码显示，箭头前的（输出）作为箭头后的输入 绑定this：该语法是ES7的一个提案，函数绑定运算符是并排的两个冒号::，左边为一个对象，右边为一个函数，功能是将函数绑定在左边对象的上下文环境中（当前this指向左边的对象）；由于绑定之后返回的仍然是对象，所以可以链式写法： 12345678910111213141516171819202122232425 foo::bar; // 相当于 bar.bind(foo); foo::bar(...arguments); // 等同于 bar.apply(foo, arguments); ``` - 尾调用优化：尾调用是指某个函数的最后一步是调用另一个函数`function f(x)&#123;return g(x);&#125;`- 尾递归优化：对于尾递归来说，只存在一个调用帧，永远不会发生“栈溢出”的错误，但是必须在严格模式下才可以生效： ```javascript //非尾递归： function Fibonacci (n) &#123; if ( n &lt;= 1 ) &#123;return 1&#125;; return Fibonacci(n - 1) + Fibonacci(n - 2); &#125; //尾递归： function Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123; if( n &lt;= 1 ) &#123;return ac2&#125;; return Fibonacci2 (n - 1, ac2, ac1 + ac2); &#125;","categories":[{"name":"Document","slug":"Document","permalink":"http://keefe.wang/categories/Document/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://keefe.wang/tags/基础知识/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://keefe.wang/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://keefe.wang/tags/ES6/"}]},{"title":"使用Leaflet插件在浏览器加载地图","slug":"2017-06-12-using-leaflet-to-load-map","date":"2017-06-12T04:00:00.000Z","updated":"2020-10-20T08:55:09.844Z","comments":true,"path":"2017/06/12/2017-06-12-using-leaflet-to-load-map.html","link":"","permalink":"http://keefe.wang/2017/06/12/2017-06-12-using-leaflet-to-load-map.html","excerpt":"在公司实习的第一个项目就与地图和数据可视化相关，这让从来没有接触过地图API、加载工具以及相关开发的我一开始都有些手足无措。之后技术路线慢慢定下来，在浏览器中加载腾讯地图的瓦片地图，并在该地图上添加热力图等可视化图表。 在经过一番简单的调研之后，在浏览器加载地图无非是采用相应地图公司开发的JavaScript API，或者加载在线/离线瓦片地图。后者由于要使用第三方的插件或者自己开发的工具进行加载，所以实现起来较为复杂，而前者实现起来就比较傻瓜了。本文中主要使用腾讯地图作为实例使用地图，同时也会简单提及其他公司开发的地图。","text":"在公司实习的第一个项目就与地图和数据可视化相关，这让从来没有接触过地图API、加载工具以及相关开发的我一开始都有些手足无措。之后技术路线慢慢定下来，在浏览器中加载腾讯地图的瓦片地图，并在该地图上添加热力图等可视化图表。 在经过一番简单的调研之后，在浏览器加载地图无非是采用相应地图公司开发的JavaScript API，或者加载在线/离线瓦片地图。后者由于要使用第三方的插件或者自己开发的工具进行加载，所以实现起来较为复杂，而前者实现起来就比较傻瓜了。本文中主要使用腾讯地图作为实例使用地图，同时也会简单提及其他公司开发的地图。 使用JavaScript API加载腾讯地图使用JavaScript API在浏览器加载腾讯地图，方式非常简单，最重要就是在页面中加载相应的API的js文件，并初始化地图组件即可： 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt; &lt;title&gt;简单地图&lt;/title&gt; &lt;style type=\"text/css\"&gt; #container&#123; min-width:600px; min-height:767px; &#125; &lt;/style&gt; &lt;script charset=\"utf-8\" src=\"http://map.qq.com/api/js?v=2.exp\"&gt;&lt;/script&gt; &lt;script&gt; window.onload = function()&#123; function init() &#123; //初始化地图函数，自定义函数名init //定义map变量，调用qq.maps.Map()构造函数，获取地图显示容器 var map = new qq.maps.Map(document.getElementById(\"container\"), &#123; // 地图的中心地理坐标： center: new qq.maps.LatLng(39.916527,116.397128), zoom:8 &#125;); &#125; //调用初始化函数地图 init(); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--定义地图显示容器--&gt; &lt;div id=\"container\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 瓦片地图目前的流行的互联网瓦片地图种类有两种，一种是栅格地图瓦片，另一种是矢量地图瓦片。 栅格地图瓦片较为传统，是将矢量数据渲染成为256×256像素大小的图片，例如百度地图、高德地图、天地图和腾讯地图等，这些地图可以使用leaflet框架进行瓦片的加载。矢量地图瓦片是以json格式分块传输，在浏览器端利用前端框架将地图展示出来，mapbox和腾讯地图中的3D地图就是矢量地图瓦片，支持三维旋转等。 使用leaflet.js各个地图公司的产品本身拥有还比较完善的API和相关的插件和工具，比如除了地图加载之外的标志叠加、热力图叠加等。但是地图瓦片的加载目前比较流行和完善的工具就是leaflet.js工具,它通过下载特定地图产品的瓦片（一般是256x256px大小），将相应的x、y坐标对应起来，展示在html文档的容器中。之前在网上搜资料，腾讯地图瓦片的资料也是凤毛麟角，跟公司地图部门的同学了解之后便开始了这个地图应用的开发。下面就用leaflet工具加载腾讯地图瓦片作为例子来展示如何进行地图瓦片的操作。 废话不多说，先上代码： 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt; &lt;title&gt;简单地图&lt;/title&gt; &lt;style type=\"text/css\"&gt; #container&#123; min-width:600px; min-height:767px; &#125; &lt;/style&gt; &lt;script charset=\"utf-8\" src=\"\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--定义地图显示容器--&gt; &lt;div id=\"mapid\"&gt;&lt;/div&gt; &lt;script&gt; var mymap = L.map('mapid').setView([39.90469, 116.40717], 12); L.tileLayer('https://rt&#123;s&#125;.map.gtimg.com/realtimerender?z=&#123;z&#125;&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;type=vector&amp;style=0', &#123; subdomains: [\"0\",\"1\",\"2\",\"3\"], tms: true, maxZoom:18, minZoom:1, detectRetina: true, attribution: '&amp;copy 滴滴出行' &#125;).addTo(mymap); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上面代码中展示的就是在div容器中加载地图瓦片的实例，其中，最重要的就是腾讯地图瓦片的下载地址https://rt{s}.map.gtimg.com/realtimerender?z={z}&amp;x={x}&amp;y={y}&amp;type=vector&amp;style=0，其中{s}是指subdomains，是地图瓦片的集群编号，可以传入字符串或数组，此处我们传入的是[“0”, “1”, “2”, “3”]；其次是{x}、{y}、{z}三个参数分别指的是瓦片的横坐标、纵坐标以及缩放等级。地图实例通过L.map(容器ID)来进行声明，通过L.tileLayer().addTo(地图实例)方法来进行加载，该方法中需要传入一个地图瓦片URL和一个参数对象作为参数。其中参数对象中的参数配置可以参考leaflet官网的文档进行配置。 地图加载完毕之后，可以在加载好的地图图层上继续添加所需要的标志、热力图等等。我们这里展示leaflet工具自带的热力图加载方法： 123456789101112L.heatLayer(data,&#123; minOpacity: 0.6, maxZoom: 18, max: 500, radius: 12, blur: 0, gradient: &#123; 1: '#00ffe4', 0.7: '#0078ff', 0.5:'#4285ff' &#125;&#125;).addTo(mymap); 同样是在一样的容器里添加图层，参数有热力数据和参数对象两个，其中热力数据的数据结构是[纬度, 经度, 热度]该热力图可以通过设置透明度（minOpacity）、渐变色（gradient）、扩展度（blur）来改变热力图的样式。 在本文最基础的使用leaflet工具来加载腾讯地图瓦片之后，相信会接触更多有关地图网页应用的项目，之后也会不断地更新地图相关技术博客文章。","categories":[{"name":"Toolkit","slug":"Toolkit","permalink":"http://keefe.wang/categories/Toolkit/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://keefe.wang/tags/JavaScript/"},{"name":"Leaflet","slug":"Leaflet","permalink":"http://keefe.wang/tags/Leaflet/"},{"name":"Map","slug":"Map","permalink":"http://keefe.wang/tags/Map/"},{"name":"腾讯地图","slug":"腾讯地图","permalink":"http://keefe.wang/tags/腾讯地图/"}]},{"title":"IJavascript-个人在线前端代码解释器安装与使用","slug":"2017-04-15-Online-Javascript-Interpreter-IJavascript","date":"2017-05-09T04:00:00.000Z","updated":"2020-10-20T08:55:02.269Z","comments":true,"path":"2017/05/09/2017-04-15-Online-Javascript-Interpreter-IJavascript.html","link":"","permalink":"http://keefe.wang/2017/05/09/2017-04-15-Online-Javascript-Interpreter-IJavascript.html","excerpt":"Jupyter-开源的文档/代码编辑、解释、分享工具ProjectJupyter1是一项开源的项目，只在创造一个平台供各种开发人员、前沿科学工作者以及坐在电脑前进行工作的各位进行协同开发。该项目下拥有Jupyter Notebook、nbdime、qtconsole等开源应用。本文主要讲述使用Jupyter Notebook应用和IJavascript插件来进行前端代码的可视化编辑、解释以及协同分享。","text":"Jupyter-开源的文档/代码编辑、解释、分享工具ProjectJupyter1是一项开源的项目，只在创造一个平台供各种开发人员、前沿科学工作者以及坐在电脑前进行工作的各位进行协同开发。该项目下拥有Jupyter Notebook、nbdime、qtconsole等开源应用。本文主要讲述使用Jupyter Notebook应用和IJavascript插件来进行前端代码的可视化编辑、解释以及协同分享。 安装Jupyter Notebook Python 环境时安装Jupyter Notebook的必要环境（3.3以上或2.7均可） 可以先从官网下载Anaconda安装包，Anaconda中继承了NumPy和Jupyter Notebook等工具包，所以直接可以打开Jupyter Notebook应用 macOS系统下可以通过终端的pip工具进行安装： 首先要升级pip到最新版本： 1pip3 install --upgrade pip 如果pip3命令不存在，需要安装pip3或者（如果电脑中安装的是python2）使用pip命令进行安装。 使用pip3命令进行安装jupyter： 1pip3 install jupyter 安装IJavascriptJupyter Notebook自带python语言编写程序的编译，如果需要其他语言版本的notebook（Julia，Ruby，Haskell等），还需要安装相应语言对应的Kernel2，对于前端工程师来说，当然是需要一个Html、CSS和JavaScript集成的在线解释器，所以IJavascript3就应运而生。IJavascript是Jupyter Notebook的Kernel（支持该功能的是Jupyter messaging protocol）之一。IJavascript同时也在npm包管理工具中，而npm又需要Node.js环境。所以，需要首先确定系统中有Node.js和npm的环境。 在终端中运行以下代码可以完成IJavascript Kernel的安装： 12345ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"brew install pkg-config node zeromqsudo easy_install pipsudo pip install --upgrade pyzmq jupytersudo npm install -g ijavascript IJavascript的使用在终端中输入代码 1jupyter notebook 启动Jupyter Notebook，可以在浏览器打开地址为http://localhost:8888的web应用，在右上角“new”选项中选择Javascript(Node.js),就可以开始使用了！,就可以开始使用了！) IJavascript不仅可以像控制台一样进行交互式的JavaScript调试，而且可以对HTML和SVG代码进行输出，只需要在输入的时候加上$$html$$或$$svg$$就可以进行代码的所见即所得了。详细的教程可以查看IJavascript官方文档4.","categories":[{"name":"Document","slug":"Document","permalink":"http://keefe.wang/categories/Document/"}],"tags":[{"name":"Jupyter","slug":"Jupyter","permalink":"http://keefe.wang/tags/Jupyter/"},{"name":"前端","slug":"前端","permalink":"http://keefe.wang/tags/前端/"},{"name":"解释器","slug":"解释器","permalink":"http://keefe.wang/tags/解释器/"},{"name":"说明书","slug":"说明书","permalink":"http://keefe.wang/tags/说明书/"}]},{"title":"JavaScript高级程序设计笔记整理","slug":"2017-05-08-JavaScript-Professional-JavaScript-for-Web-Developer-notebook","date":"2017-05-09T04:00:00.000Z","updated":"2020-10-20T08:55:05.194Z","comments":true,"path":"2017/05/09/2017-05-08-JavaScript-Professional-JavaScript-for-Web-Developer-notebook.html","link":"","permalink":"http://keefe.wang/2017/05/09/2017-05-08-JavaScript-Professional-JavaScript-for-Web-Developer-notebook.html","excerpt":"第三章 基本概念语法： 区分大小写：ECMAScript中的一切都区分大小写 标识符：变量、函数、属性、函数参数等的名字，由字母，下划线，一个美元符号开头 注释：//单行注释，/ /多行注释（尽量少用该种注释方法） 严格模式：在脚本顶部或者某函数内顶部添加”use strict”,支持IE10+,Firefox4+，Safari5.1+，Opera12+，Chrome；","text":"第三章 基本概念语法： 区分大小写：ECMAScript中的一切都区分大小写 标识符：变量、函数、属性、函数参数等的名字，由字母，下划线，一个美元符号开头 注释：//单行注释，/ /多行注释（尽量少用该种注释方法） 严格模式：在脚本顶部或者某函数内顶部添加”use strict”,支持IE10+,Firefox4+，Safari5.1+，Opera12+，Chrome； 语句由分号结尾，多条语句以花括号包围形成代码块，有以下几种语句类型： if 语句：与Java中的条件判断语句语法相同 do-while 语句：相同条件下会比while循环语句少执行一次 while 语句：与Java中的条件判断语句语法相同 for 语句：与Java中的条件判断语句语法相同 for-in 语句：支持任何有迭代属性的对象（Object、Array、Set、Map等）进行枚举循环操作 label 语句：添加标签一般与循环语句配合使用，使用break或continue语句引用 1234567891011var temp=0; start: for(var i=0; i&lt;5; i++) &#123; for(var m=0; m&lt;5; m++) &#123; if(m==1) &#123; break start; //输出1，若去掉start将输出5 &#125; temp++; &#125; &#125; alert(temp); break 和 continue 语句：后面可引用label with 语句：将代码作用域设置到一个特定对象中，避免多次编写同一个对象的工作 12345with(someObject) &#123; var qs = search.substring(1); //如果没有使用with语句，这个表达式应该是var qs = someObject.search.substring(1); var hostName = hostname; var url = href;&#125; switch 语句:与Java中的条件判断语句语法相同，注意使用break语句 数据类型和变量 关键字和保留字：表达式和代码块中出现关键字和保留字一定要留意是否可用 变量： ECMAScript中变量为松散类型，var定义局部变量，可以不赋值（此时为undefined类型） 无var关键词时定义的是全局变量（但是严格模式下会抛出错误） 数据类型：由typeof操作符可以显示给定变量的数据类型，有Undefined、Boolean、String、Number、Object（Array、Null）、Function六中数据类型； Undefined：未声量变量使用typeof操作符时显示undefined，而且对未声明变量使用alert()方法会报错； Boolean：true&amp;false，注意各种数据类型对应boolean值得转换规则； Number：八进制0开头，十六进制0x开头；NaN不等于任何值（包括NaN本身）；非数值转换为数值的三个函数：number(),parseInt(“10”,进制基数)，parseFloat()；数值转换（true:1，false:0，null:0，undefined:NaN）；字符串转换规则（只包含有效数字转化为非0开头数值，空字符串转化为0，字符串包含除有效数字之外的转换为NaN）； String：字符串不可变，改变时会将原来的变量值销毁再重新赋值；数值、布尔值、对象和字符串值都有toString()方法； Object：都有Constructor、hasOwnproperty(propertyName)、isPrototypeOf(object)、propertyIsEnumerable(propertyName)、toLocaleString()、toString()、valueOf(); Null：对值为null的变量使用typeof时返回object，因为null表示一个空对象指针；null==undefined总是返回true； 操作符： 一元：++、–、+、-、~位、!逻辑、 二元：&amp;位、|位、^、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;、&amp;&amp;逻辑、||逻辑、+、-、*、/、%、&gt;、&lt;、&gt;=、&lt;=、==、!=、===、!==、 三元：boolean_expression？true_value:false_value; 赋值：=、+=、-=、*=、/=、%=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;= 运算符优先级：.、[]、()先于delete、new、typeof、+（一元）、—（一元）、！、~先于*、/、%先于+、-先于&gt;=、&lt;=、&gt;、&lt;先于===、!==先于&amp;&amp;先于||先于?: 函数：使用function关键词声明函数，参数类似数组并可省略，参数（和js中的基本类型）都是传值而非传引用（例如string对象）；名字相同的函数只有后定义的函数可以使用； 第四章 变量、作用域和内存问题基本类型和引用类型： 除Object之外的基本类型都是按值访问，对象则是通过访问内存中对象的引用； 基本类型无法添加和改变属性； 复制基本类型值会产生一个独立副本，而复制引用类型值时两者是指向同一个对象的指针； 检测基本类型值时使用typeof，检测引用类型值 时使用instanceof。另外，除了instanceof之外还可以使用return somevar.proto.constructor==sometype或者Object.prototype.toString.call(somevar)。 执行环境和作用域： 局部执行环境（某个函数、let绑定代码块等）：某个执行环境中的所有代码执行完后，该环境被销毁，其中的所有变量和函数定义也随之消失； 全局执行环境：Web浏览器中，全局执行环境被认为是window对象； 每个函数也都有自己的执行环境，执行流（ECMAScript）进入函数，该函数环境被推入一个环境栈； 代码在一个环境中执行，会创建一个作用域链，用途是保证对执行环境有权访问的所有变量和函数有序访问； 延长作用域链：try-catch语句中的catch以及with语句 js中 没有块级作用域（任何花括号中的代码块），例如在if和for中的变量可以在if和for之外访问： 声明变量：使用var声明的变量自动被添加到最接近的环境中，没有用var声明会被添加到全局环境； 查询标识符：某环境中出现一个标识符时，要通过搜索确定该标识符代表什么，从作用域链前端开始，向上逐级查询，匹配到的第一个停止搜索，变量就绪；若全局中都没找到，则算未声明； 垃圾回收：js具有自动垃圾收集机制 标记清除：变量进入某环境，标记该变量，离开环境时进行离开标记，释放内存； 引用计数：声明某变量并将引用类型值赋给该变量，该值引用次数为1，每被赋给一次就加1；若包含对这个值引用的变量取得另外一个值，则减1，该值变成0时就释放内存空间； 管理内存：为了占用最少内存达到更好性能，要将不再使用的变量赋值为null来释放其引用； 第五章 引用类型Object类型 创建对象时首选字面量创建方法： 12345var person = &#123; \"name\" : \"Nicholas\", \"age\" : 29, 5 : true&#125;; Array类型 定义：var color = new Array(3); 访问：采用数组下标[]的方式进行访问，使用.length得到数组长度； 检测：value instanceof Array(不推荐),Array.isArray(somearrayvalue)(推荐)； 转换：toLocaleString()/toString()/valueOf(),均生成 逗号分隔 的字符串其中，toLocaleString()方法转换时每一项都是使用toLocaleString()转换的，toString()也是Array.join(someJointSymbol)，默认用逗号连接； 插入/删除：除了直接用下标添加删除，最好用栈方法LIFO-push(任意项参数)在尾部增加任意数量参数，pop()删除最后一项；同时还有队列方法FIFO,在栈方法基础上增加shift()可删除第一项，unshift()可以在前端添加任意项； 排序：sort()升序排列（转化为字符串进行比较，数字比较会出错，需要在参数中提供比较函数compare()）；reverse()反转数组顺序； 操作方法 连接：somearray.concat(otherarrays)返回连接所有数组的副本； 删除：somearray.splice(起始位置，删除项数，插入项)-splice(0,2)删除前两项，splice(2,0,”red”,”green”)在当前数组位置2插入两项，splice(2,1,”red”,”green”)删除第二项并插入； 位置方法：获取数组中元素的位置，indexOf()和lastIndexOf(),返回数组下表对应元素，否则返回-1； 迭代方法：有5个迭代方法，参数都是两个，每一项上运行的函数和运行该函数的作用域对象every(someFunction)；对每一项进行函数操作，每一项返回true则最后返回true；filter(someFunction):对每一项运行给定函数，返回每次调用该函数值为true的项的数组forEach(someFunction):对每一项运行给定函数，无返回值map(someFunction):对每一项运行给定函数，返回每次调用该函数结果的数组some(someFunction):对每一项运行给定函数，只要有一项使函数返回true，则整个返回true； 缩小方法：reduce(给每项调用的函数(可选)，缩小基础初始值)/reduceRight(给每项调用的函数(可选)，缩小基础初始值)，其中，参数中的函数需要传入4个参数，分别是前一项，当前项，项索引，数组对象；reduceRight是相反方向； 禁忌：[， ， ， ，]不可以出现数组最后一项是，的情况 Date类型 定义：`var now = new Date(); 特定时间：var someDate = new Date(Date.parse(“May 25, 2004”));但是不用date.parse也会默认转换； 继承的方法 toLocaleString()按照与浏览器设置的地区相适应的格式返回日期和时间 toString()返回带有时区信息的日期和时间 valueOf()返回日期的毫秒表示 日期格式化方法 toDateString():以特定于实现的格式返回日年月日星期 toTimeString():以特定于实现的格式返回时区、时分秒 toLocaleDateString():以特定于地区的格式返回年月日星期 toLocaleTimeString():以特定于实现的格式显示时分秒 toUTCString():以特定于实现的格式完整的UTC日期 日期时间组件方法￼ ￼ RegExp类型： 定义： 12var pattern = new RegExp(“pattern”, “flags”);var expression = /pattern/ flags; 其中flags有一下几种模式： g:全剧模式，模式应用于所有字符串而非在发现第一个匹配项时立即停止； i:不区分大小写模式； m:多行模式，到达一行末尾还会查找下一行是否有匹配项 元字符转义：( { [ \\ ^ $ | ) ? + . ] } e.g.匹配第一个”[bc]at”:var patter = /\\[bc\\]at/i; 实例属性 .global:bool是否设置g标志 .ignoreCase:bool是否设置了i标志 .lastIndex:整数，表示开始搜索下一个匹配项的自负位置，0算起 .multiline:bool，表示是否设置了m标志 .source:该正则的字符串表示 实例方法：.exec() 构造函数属性： 模式的局限性： Function类型函数是对象，因此函数名实际上也是一个指向函数对象的指针，可以使用多个指针指向同一个函数。 声明： 123function sum(num1, num2)&#123; return num1 + num2;&#125; 特征 没有重载:因为JS中的函数名就像指针一样，所以当为一个函数名（就是一个变量）赋予新的函数时，会覆盖之前的函数； 声明位置和表达式: JS中有函数声明提升过程，所以声明和调用不强调先后顺序。但是！如果把函数放进一个初始化语句中而非函数声明时,会出现先后问题的错误； 作为值的函数:函数名可作为变量像值一样传入另一个函数；函数内也可以返回一个函数的计算结果等等； 函数属性和方法: 函数作为对象有两个属性: length（表示函数希望接受的命名参数的个数） prototype（保存引用类型的所有实例的方法，是不可枚举的） 函数作为对象有两个方法: apply()：接受两个参数，一个是其中运行函数的作用域，另一个是参数数组（可以使arguments对象或者是真实的一个数组） call()：接受this参数以及来自函数的每一个参数都要写进去而非传入数组），这两个函数都是在特定的作用域中调用函数，相当于设置函数体内this对象的值 函数内部对象及环境的属性 两个特殊对象 arguments：包含传入函数的所有参数，并且有一个callee的属性指向拥有这个arguments对象的函数，其实就是这个函数，另一个caller的属性返回引用本函数的函数 this：引用的是函数执行的环境对象，网页的全局就是window 基本包装类型String、Boolean、Number（Object、Null、Undefined、Array） String： 方法： 下标相关 所指的单字符串charAt() 所指字符的编码charCodeAte() 字符串位置indexOf(substr) 最后一个字符串位置lastIndexOf(substr) 字符串操作 连接concat(String str1, String str2) 截取slice(startPos(, endPos)) 截取substr(startPos(, length)) 截取substring(startPos(, endPos))，当输入负数的index时，slice将负数和字符串长度相加，substr将第一个负参数加字符串长度第二个负参数转换为0，substring将所有负参数转化为0； 格式化字符串方法trim(string)创建一个副本并删除前后所有空格 大小写相关 转小写toLowerCase() 转本地语言toLocaleLowerCase() toUpperCase() toLocaleUpperCase() 字符串模式匹配方法match()详见正则表达式，search()返回第一个匹配项索引否则返回-1 replace(新字符串，需要替换的字符串) split(simbol)，由simbol分隔字符串，返回一个字符串数组 string1.localeCompare(string2)返回：string1在string2之前-1，相等0，之后1 fromCharCode()静态方法，接收一或多个字符编码，然后转换成一个字符串 单体内置对象 Global对象 在js中，不属于任何其他对象的属性和方法，都是它的属性和方法。所有在全局作用域中定义的属性和函数都是它的属性和函数。例如isNaN()/isFinite()/parseInt()/parseFloat()/encodeURI()只编码空格/encodeURIComponet()编码所有非字母数字字符/decodeURI()/decodeURICompoment()/eval()接收一个js语句字符串，若是函数则不会被提升，需要按照声明顺序进行调用，严格模式下外部不能访问该函数中的函数或变量 第六章 面向对象的程序设计对象就是无序属性的集合，其属性可以包含基本值、对象或者函数。创建对象的基础方法： 创建Object实例： 123456var person = new Object();person.name = \"Nicholas\";person.age = 29;person.sayName = function()&#123; alert(\"this.name\")&#125; 对象字面量语法： 1234567var person = &#123; person.name = \"Nicholas\"; person.age = 29; person.sayName = function()&#123; alert(\"this.name\") &#125;&#125; 理解对象 属性类型： ECMAScript中有两种属性：数据属性 和 访问器属性。 数据属性：包含一个数据值的位置，在此位置可读取和写入值，有以下特性： [[Configurable]]默认值为true，表示能否通过delete删除属性 [[Enumerable]]默认值为true，表示能否通过for-in循环返回属性 [[Writable]]默认值为true，表示能否修改属性的值 [[Value]]默认值为undefined，包含这个属性的数据值 要修改上述属性，必须通过Object.defineProperty(属性所在对象，属性名，描述符对象)方法： 12345var person = &#123;&#125;;Object.defineProperty(person, \"name\", &#123; writable: false, value: \"Nicholas\"&#125;) 访问器属性：不包含数据值，只包含getter和setter函数（这两个函数并非必需），访问器属性具有如下特征： [[Configurable]]默认值为true，表示能否通过delete删除属性 [[Enumerable]]默认值为true，表示能否通过for-in循环返回属性 [[Get]]默认值为undefined，读取属性时调用的函数 [[Set]]默认值为undefined，写入属性时调用的函数 访问器属性也必须使用Object.defineProperty()方法来进行定义： 12345678910111213141516171819202122232425262728293031323334353637var book = &#123; _year: 2004, edition: 1&#125;;Object.defineProperty(book, \"year\", &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if(newValue &gt; 2004)&#123; this._year = newValue; this.edition = newValue - 2004; &#125; &#125;&#125;);//若想定义多个属性或对应的方法时，可以这样写：Object.defineProperty(book, &#123; //这里定义了两个数据属性 _year: &#123; value: 2004 &#125;, edition: &#123; value: 1 &#125;, //这里定义了一个访问器属性 year: &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if(newValue &gt; 2004)&#123; this._year = newValue; this.edition = newValue - 2004; &#125; &#125; &#125;&#125;); * 如果想读取属性的特征，则要通过Object.getOwnPropertyDescriptor()函数来访问： 123var descriptor = Object.getOwnPropertyDescriptor(book, \"_year\");alert(descriptor.value);alert(typeof descriptor.get); //\"function\" 创建对象创建类和对象名要使用大写字母开头，构造函数也是，而非构造函数则由小写字母开头。 工厂模式：抽象了创建具体对象的过程，用函数来封装以特定接口创建对象的细节： 1234567891011function createPerson(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o;&#125;var person1 = createPerson(\"Nicholas\", 29, \"Software Engineer\"); 其实就是把一个完整的由Object实例来创建对象的过程放在一个函数中； 构造函数模式： 123456789function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; alert(this.name); &#125;;&#125;var person1 = new Person(\"Nicholas\", 29, \"Software Engineer\"); 可以看到，构造函数模式中 没有显式地创建对象，直接将属性和方法赋给了this对象，没有return语句 。 构造函数模式相较于工厂模式的一个优点是，它创建的构造函数可以将它的实例标识为一种特定的类型，即对象也是Object也是Person的实例。 将构造函数当做函数： 任何函数，只要通过new操作符来调用，就可以作为构造函数。 原型模式 JavaScript中并没有提供类的实现，虽然在ES2015/ES6之中引入了class关键字，但是JavaScript仍然是基于原型的。而JavaScript中创建对象的方法有：new Object()方法、字面量方法、工厂模式、构造函数方法和原型模式。其中，使用原型模式创建对象可以令所有实例共享方法，减少内存消耗，有利于对象继承。 JavaScript中的继承则是体现在一种结构上——对象，所有的对象都是由Object衍生的对象，所有的对象都继承了Object.prototype的方法和属性（也有可能被覆盖）。每一个对象都有一个内部链接到另一个对象，这个对象成为它的原型（prototype）。而且，该原型对象也有自己的原型，直到追溯到一个以null为原型的对象，因为null是没有原型的，所以可以作为这个原型链（prototype chain) 中的最终链接。 只要创建了一个新函数，就会为该函数创建一个prototype属性，这个属性指向函数的原型对象。所有原型对象都自动获得一个constructor属性，这个属性包含一个指向prototype属性所在函数的指针。 原型对象的创建： 1234567891011121314function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job;&#125;Person.prototype.sayName = function() &#123; alert(this.name);&#125;;var person1 = new Person(\"Nicholas\", 29, \"Lawyer\");var person2 = new Person(\"Katie\", 30 \"Account\");var person3 = new Person(\"Nicholas\", 29, \"Lawyer\");person1.sayName(); //\"Nicholas\"person2.sayName(); //\"Katie\"alert(person1.sayName == person3.sayName); //true 更加简单的原型对象创建语法： 12345678910function Person() &#123;&#125;Person.prototype = &#123; name : \"Nicholas\", age : 29, job : \"Software Engineer\", sayName : function() &#123; alert(this.name) &#125;&#125;; 寄生构造函数模式 与工厂模式没有本质上的区别，只是在创建新的实例的时候，工厂模式不需要new，而寄生构造函数需要加new。这种模式不能够以来instanceof操作符来确定对象类型，所以建议在能够使用其他模式创建对象时尽量不要使用这种模式。 稳妥构造函数模式 JavaScript中的稳妥对象是指，没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些禁止使用this和new的安全环境中使用，防止被Mashup等的应用程序改动。 稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建的对象的实例方法不引用this；二是不适用new操作符调用构造函数。 1234567function Person(name, age, job) &#123; var o = new Object(); o.sayName = function() &#123; alert(name); &#125;; return o;&#125; 继承原型链 代码搜索某属性的路径（原型链）： 上面代码中出现了Person.prototype,通过该形式可以获得原型对象，并且可以为其添加属性和方法。这段代码也展示了对象属性和方法搜索的路径：每当代码读取某个对象的某个属性时，进行目标为该属性的名字，搜索首先从实例（person1）本身开始，若有该名字的属性则返回该属性，若没有则继续搜索该实例中原型指针指向的原型对象，在原型对象中查找该名字的属性。所以说实例是共享原型中保存的属性和方法。 实例的属性，原型的属性？ 一个对象的所有实例尽管可以共享该原型对象的所有属性和方法，但是却无法重写原型对象中的属性和方法，只能通过利用同名属性和方法来覆盖和屏蔽原型对象中的属性和方法；若想把实例中覆盖的属性还原，可以通过delete操作。使用hasOwnProperty()方法可以检测一个属性是存在于实例中还是存在于原型中。 怎样获得原型对象 下面的代码展示了Object.getPrototypeOf(obj)方法和proto属性的使用： 12Object.getPrototypeOf(person1) === Person.prototype; //trueperson1.__proto__ === Person.prototype; //true 可以看到，Object.getPrototypeOf(obj)是获取obj对象的原型对象的方法，这个方法将在利用原型实现继承的情况中发挥非常重要的作用。obj.proto 也是如此，是每一个对象都拥有的属性，但是proto并不是一个规范的属性（当使用Object.create()方法创建对象时，proto 并不能指向该对象的原型对象），其对应的标准属性应当是[[Prototype]]。 原型对象和构造函数 对于对象Person来说，它的构造函数是Person()，它的原型对象为Person.prototype；而Person.prototype.constructor又会指回Person。而对象Person的实例person1和person2都包含有一个属性[[Prototype]]（也就是上面提到的proto）它们都指向Person.prototype；同时，person1和person2也可以通过isprototypeOf(）方法来确定是否与确定对象之间有这种关系： 1alert(Person.prototype.isPrototypeOf(person1)); //true 原型与in操作符 in操作符单独使用的情况 in操作符单独使用会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是在原型中： 1234//接上面的代码var person4 = new Person();alert(person4.hasOwnproperty(\"name\")); //由于person4实例没有覆盖原型中的name所以返回falsealert(\"name\" in person4); //true for-in循环 该种方式是返回所有能够通过对象访问的、可枚举的属性，包括实例和原型中的属性，并且屏蔽了原型中不可枚举（[[Enumerable]]）的属性（仅在IE8及更早版本中有不可枚举的属性）： 12345678910var o = &#123; toString : function() &#123; return \"my Object\" &#125;&#125;for (var prop in o) &#123; if (prop == \"toString\") &#123; alert(\"Found toString\"); //IE中无法显示 &#125;&#125; 若想获取对象中所有可枚举的实例属性，可以使用Object.keys(),该函数接受一个对象或实例作为参数（当然也可以是原型对象），返回一个包含所有可枚举属性的字符串数组。示例代码如下： 123456789//接Person对象代码var keys = Object.keys(person.prototype);var person5 = new Person();person5.name = \"Rob\";person5.age = 31;alert(keys);alert(Object.keys(person5));var keys2 = Object.getOwnPropertyNames(Person.prototype); alert(keys2); 上述代码中出现的Object.getOwnPropertyNames(Person.prototype)方法可以得到所有的可枚举/不可枚举的实例属性（列入constructor）。 原型的动态性由于从原型中查找值的过程试一次搜索，因此对原型对象所做的任何修改都能从实例上反映出来。即，可以先创建实例，再修改原型对象中的属性或函数，实例依旧可以访问该属性和函数： 123456//接person对象代码var friend = new Person();Person.prototype.sayHi = function() &#123; alert(\"hi!\");&#125;;friend.sayHi(); //返回”hi” 尽管像以上代码中所看到的可以为原型添加属性或方法，但是如果重写整个原型对象，就会切断实例的构造函数与最初原型对象之间的联系。这是因为实例中的指针仅指向原型，而非构造函数。 原生对象的原型不仅是自定义的对象，JavaScript中所有原生的引用类型，都是采用这种模式创建的原生对象。通过原生对象的原型可以取得所有默认方法的引用，也可以自己添加新的方法。 原型对象的缺点 由于原型中所有属性都是可以被实例共享，而对于原型中含有引用类型值的属性来说就会发生问题： 123456//接person对象代码Person.prototype.friends = [\"Shelby\", \"Court\"];var person6 = new Person();person6.friends.push(\"Van\");alert(person6.friends);alert(person1.friends); //此时两个Person的实例拥有相同的朋友，很可能发生错误 可以看到，由于原型的属性可以被共享的这一特性，原型对象中包含的引用类型值很可能被修改之后导致实例的属性也发生错误，必须要在实例属性中覆盖才可以。所以为了解决这个问题，提出了以下组合构造函数模式和原型模式的方法来创建对象： 123456789101112131415//改写上面的Person对象//首先使用构造函数模式创建对象Person并加入容易被修改的属性name，age，jobfunction Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.friends = [\"Shelby\", \"Court\"];&#125;//再使用原型模式创建构造函数和不容易被修改的属性和函数，这样可以发挥原型的共享机制并减少内存消耗Person.prototype = &#123; constructor : Person, sayName : function() &#123; alert(this.name); &#125;&#125; 第七章 函数表达式函数的定义有两种方法：一种是函数声明，另一种是函数表达式 。 函数声明： 123function functionName(arg0, arg1, arg2) &#123; //函数体\\&#125; Firefox、Safari、Chrome和Opera都给函数定义了一个非标准的name属性，可以访问到给函数指定的名字alert(functionName.name);同时我们还需要注意的是，函数有函数声明提升的重要特征，所以函数声明可以放在函数调用语句之后。 函数表达式： 123var functionName = function(arg0, arg1, arg2) &#123; //函数体&#125;; 这种情况下创建的函数叫做匿名函数f，所以函数的name属性是空字符串，而且根据赋值语句的特性，调用一定要在函数赋值语句之后。既然函数可以赋值给变量，同时函数也可以作为其他函数的返回值。 递归 概念 递归函数是在一个函数通过名字调用自身的情况下构成的。 1234567function factorial(num) &#123; if (num &lt;= 1) &#123; return 1; &#125;else&#123; return num * factorial(num - 1); &#125;&#125; 这是一个经典递归阶乘函数，但是存在以下的问题： 123var anotherFactorial = factorial;factorial = null;alert(anotherFactorial(4)); //出错 上面调用出错的原因是，当factorial的引用被替换之后，在anotherFactorial调用时还是会用到factorial，这时候就会发生错误。这种情况可以使用arguments.callee可以解决这个问题。 arguments.callee是一个指向正在执行的函数的指针。所以用这个指针对递归调用能够解决这个问题，例如： 1234567function factorial(num) &#123; if(num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num - 1); &#125;&#125; 如果是严格模式下，callee模式会导致错误，最好使用命名函数表达式来达到相同的目的： 1234567var factorial = (function f(num) &#123; if(num &lt;= 1) &#123; return 1; &#125; else &#123; return num * f(num - 1); &#125;&#125;); 闭包 概念：闭包是指有权访问另一个函数作用域中的变量的函数。 创建闭包：常见方式是在一个函数内部创建另一个函数。 理解闭包 要理解闭包的细节，必须理解如何创建作用域链以及作用域链的作用以及理解函数第一次被调用的时候发生了什么。 当某函数第一次被调用时，会创建一个执行环境以及相应的作用域链，并把作用域链赋值给一个特殊的内部属性（[[Scope]])，然后可以使用this、arguments和其他命名参数的值来初始化函数的活动对象。在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数活动对象处于第三位，直至作为作用域链重点的全局执行环境。 所以说，当函数执行完毕之后，据不活动对象（this、arguments）就会被销毁，内存中也仅保存全局作用域。而引入闭包之后情况就会好转： 在另一个函数内部定义的函数会将包含函数（外部函数）的活动对象添加到它的作用域链中。当调用该函数时，函数执行完毕之后，其活动对象也不会被销毁，因为其中的匿名函数的作用域链仍然在引用这个活动对象，除非使用null来销毁该函数解除对匿名函数的引用，释放内存。 闭包与变量 作用域链的机制有一个副作用：闭包只能取得包含函数中任何变量的最后一个值。闭包所保存的是整个变量的对象，而不是某个特殊的变量。 这是因为匿名函数始终都在内存中保存着作用域链中该函数的活动对象，所以其实所有新建的函数都使用着同一个变量。除非在该匿名函数中再写一个匿名函数才能强制让闭包的行为符合预期。 this对象 在闭包中使用this对象也会出现问题：匿名函数的执行环境具有全局性，因此匿名函数的this对象通常指向window（全局变量）。这是因为内部匿名函数在搜索变量时，根据作用域链进行搜索，所以存在在对象属性的变量是无法访问到的（只有函数才有作用域，还是因为外部函数没有显示声明this对象？），内部函数只能找到全局，所以如果想要闭包的函数中访问到外部函数的this对象，必须要将this对象保存在外部函数中。 内存泄漏 IE9之前的版本中，如果闭包的作用域链中保存着一个HTML元素，那么该元素无法被销毁。 避免发生”循环引用“的情况。 模仿块级作用域JavaScript中没有块级作用域的概念，所有的块语句中定义的变量都存在于函数中的作用域。所以以下代码是可以正常访问的： 123456function outputNumbers(count)&#123; for(var i = 0;i &lt; count;i++)&#123; alert(i); &#125; alert(i); //返回count计数&#125; 就算在最后一个alert(i)之前重新定义声明变量i也不会改变i的值。所以JS从来不会提醒是否多次声明了同一个变量，有可能会导致问题的产生。所以这时候需要匿名函数来模仿块级作用域来避免这个问题: 123(function()&#123; //这里就是块级作用域&#125;)(); 以上代码定义并立即调用了一个匿名函数，前一个括号是函数表达式声明，后一个括号是指立即调用这个函数。需要注意的是，函数表达式后面可以跟圆括号，而函数声明后面是不可以加圆括号的。 私有变量JS中没有私有成员的概念，对象属性和函数都是共有的，但是有一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量。所以利用函数的闭包就可以创建用于访问私有变量的公有方法。该方法成为”特权方法”，创建方式有以下两种： 基本模式 12345678910function MyObject()&#123; var privateVariable = 10; function privateFunction()&#123; return false; &#125; this.publicMethod = function()&#123; privateVariable++; return privateFunction(); &#125;;&#125; 静态私有变量在构造函数中定义特权方法也有一个缺点，那就是必须使用构造函数模式来达到该目的，可是构造函数模式的缺点就是每个实例都会创建同样一组新方法。而使用静态私有变量来实现特权方法就可以避免这个问题。 通过在私有作用域中定义私有变量或函数，同样也可以创建特权方法： 123456789101112(function()&#123; var privateVariable = 10; function privateFunction()&#123; return false; &#125; MyObject = function()&#123; &#125;; //严格模式下未经声明的变量赋值会导致错误 MyObject.prototype.publicMethod = function()&#123; privateVariable++; return privateFunction(); &#125;;&#125;)(); 模块模式单例 是指只有一个实例的对象，通常JavaScript是用对象字面量的方式来创建单例对象。 而模块模式正是专门为单例创建私有变量和特权方法的方式： 12345678910111213var singleton = function()&#123; var privateVariaable = 10; function privateFunction()&#123; return false; &#125; return &#123; publicProperty: true, publicMethod: function()&#123; privateVariable++; return privateFunction(); &#125; &#125;;&#125;(); 这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时时非常有用的。单例经常被用在Web应用程序中来管理应用程序级的信息。 另外还有 增强的模块模式 第八章 BOM如果在Web中使用JavaScript，那么BOM才是真正的核心。 window对象BOM的核心对象是window，它表示浏览器的一个实例。在浏览器中，window对象不仅是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象。 全局作用域 在JavaScript中，全局作用域中声明的变量、函数都会变成window对象的属性和方法。然而定义全局变量和在window对象上直接定义属性仍有一点区别：全局变量无法通过delete操作符删除（IE&lt;9抛错，其他浏览器返回false），而window对象上的属性可以。 窗口关系及框架 如果页面中包含frame，则每一个框架都拥有自己的window对象，并保存在frames集合中。 窗口位置 用来确定和修改window对象位置的属性和方法： IE、Safari、Opera和Chrome都提供screenLeft和screenTop属性；Chrome和Safari以及Firefox则支持screenX和screenY属性： 12var leftPos = (typeof window.screenLeft == \"number\") ? window.screenLeft : window.screenX;var topPos = (typeof window.screenTop == \"number\") ? window.screenTop : window.screenY; 上述代码对浏览器进行选择并获取窗口的位置。默认返回左上角原点（0，0）。 通过winow.moveBy(横坐标长度，纵坐标长度)，window.moveTo(横坐标，纵坐标)，可以移动窗口，但是可能会被浏览器禁用。 窗口大小 IE9+/Firefox/Safari/Opera/Chrome均提供4个属性：innerWidth/innerHeight/outerWidth/outerHeight。其中在IE9+/Safari/Firefox中，outerwidth和outerHeight返回浏览器窗口本身吃葱，Opera中则是表示页面视图容器的大小。而innerWidth、innerHeight是表示该容器中页面视图去的大小。Chrome中内外两对属性返回相同值-viewport大小。 另外，还可以使用window.resizeTo(width,height)/window.resizeBy(widthtoformer,lengthtoformer) 导航和打开窗口 window.open()方法可以导航到特定URL或打开新浏览器窗口。 12window.open(\"http://www.wrox.com/\",topFrame,\"someString\",\"1\")//四个参数分别是网站的url、窗口目标（或者_self/_parent/_top/_blank），特性字符串，是否取代当前页面的bool 如果该方法中第二个参数不存在，就会根据在第三个参数为止传入的字符串创建一个新窗口，有“fullscreen=yes、height=100”等参数，该参数字符串中不允许出现空格。该方法可以按照下面的方式赋值给变量并进行一些操作： 123456var wroxWin = window.open(\"http://www.wrox.com/\",\"wroxWindow\",\"height=400,width=400,top=10,left=10,resizable=yes\");alert(wroxWin.opener == window); //truewroxWin.resizeTo(500,500);wroxWin.moveTo(20,20);wroxWin.close;alert(wroxWin.closed); //true 鉴于有很多网站有很多弹窗广告的窗口，所以为了屏蔽这些窗口，网站的代码中可以 间歇调用和超时调用 JS是单线程语言，但是允许通过设置超时值和间歇时间值（毫秒）来调度代码在特定时刻执行。其中，超时值是在指定时间过后执行代码，后者是每隔指定时间就执行一次代码。 12345678setTimeout(function() &#123; alert(\"Hello world!\");&#125;, 1000);//第一个参数可以是字符串格式的代码，但是不推荐使用，会导致性能损失setInterval(function()&#123; alert(\"Hello World!\");&#125;,10000);//每10000毫秒执行一次代码 该方法也可以赋值给变量，然后通过clearTimeout(timeoutVar)/clearinterval(intervalVaar) 系统对话框 浏览器通过alert(),confirm(),prompt()方法可以调用系统对话框向用户显示消息。其中confirm()方法有OK和cancel两个按钮，prompt()会提示用户输入一个参数。另外还有window.print()打印对话框和window.find()查找对话框。 location对象location是最有用的BOM对象之一，提供了与当前窗口中加载的文档有关的信息和导航功能，还将URL解析为独立片段来通过不同属性访问这些片段。 location既是window对象的一个属性，又是document对象的属性，即window.location=document.location。下面是location的所有属性： hash（#contents）、host（www.wrox.com:80）、hostname（www.wrox.com）、href（http://www.wrox.com）、pathname（/WileyCDA）、port（8080）、protocol（http:）、search（?q=javascript）; 查询字符串参数（对search属性进行字符串解析） 位置操作 通过location.assign(&quot;http://www.wrox.com&quot;);可以打开新的URL，与window.location=&quot;http://www.wrox.com&quot;;以及location.href=&quot;http://www.wrox.com&quot;;相同 如果要禁止将页面存入浏览记录（防止后退到前一个页面），可以使用location.replace(URL); navigator对象 检测插件 navigator.plugins是一个数组，其中每一项都包括name, description, filename, length 但是IE中检测插件需要使用ActiveXObject类型： 123456789function hasIEPlugin(name) &#123; try&#123; new ActivXOBject(name); return true; &#125; catch(e) &#123; return false; &#125;&#125;alert(hasIEPlugin(\"shockwaveFlash.ShockwaveFlash\")); 注册处理程序 navigator对象有registerContentHandler()和registerProtocolHandler()方法； registerContentHandler()接受三个参数：要处理的协议（mailto或ftp），处理该协议的页面URL和应用程序的名称： 1navigator.registerProtocolHandler(\"mailto\", \"http://www.somemailclient.com?cmd=%s\", \"Some Mail Client\"); screen对象对于变成来说作用不大，用来标明客户端的能力，包括浏览器窗口外部的显示其信息等； history对象使用history.go()接受参数整数，一个url（跳到最近的该url页面）另外也可以使用history.back()/.forward(); 第九章 客户端检测能力检测目标是识别浏览器的能力， 基本模式如下： 123if(object.propertyInQuestion) &#123; //使用object.propertyInQuestion&#125; 使用方案：先检测达成目的的最常用的特性（提升效率），必须测试实际要用到的特性（判断条件要够详细） 如果是想要判断对象是否有某个属性或者支持某种方法，尽量使用typeof 怪癖（bug）检测目标是识别浏览器的特殊行为。 用户代理检测通过检测用户代理字符串来确定实际使用的浏览器。用户代理字符串作为响应头部发送，也可以通过navigator.userAgent属性访问 用户代理字符串检测技术： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var client = function() &#123; var engine = &#123; ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, ver: null &#125;; var browser = &#123; ie: 0, firefox: 0, safari: 0, konq: 0, opera: 0, chrome: 0, ver: null &#125;; var system = &#123; win: false, mac: false, x11: false， iPhone：false, ipod: false, ipad: false, ios: false, android: false, nokiaN: false, winMobile: false &#125;; //navigator.platFORM //再次检测呈现引擎、平台和设备 var ua = navigator.userAgent; if(window.opera) &#123; engine.ver = window.opera.version(); engine.opera = parseFloat(engine.ver); &#125; else if(/AppleWebKit\\/(\\S+)/.test(ua)) &#123; engine.ver = RegExp[\"$1\"]; engine.webkit = parseFloat(engine.ver); &#125; else if(（/KHTML\\/(\\S+).test(ua)) &#123; engine.ver = RegExp[\"$1\"]; engine.khtml = parseFloat(enging.ver); &#125; else if(/rv:([^\\)]+)\\) Gecho\\/d&#123;8&#125;/.test(ua)) &#123; engine.ver = RegExp[\"$1\"]; engine.gecko = parseFloat(engine.ver); &#125; else if(/MSIE ([^;]+)/.test(ua)) &#123; engine.ver = RegExp[\"$1\"]; engine.ie = parseFloat(engine.ver); &#125; return &#123; engine：engine, browser: browser, system: system &#125;;&#125;(); 可以检测用户代理、浏览器的类型和版本、系统类型和版本、移动设备 第十章 DOM节点层次HTML页面中，文档元素始终都是元素。 节点类型DOM1级定义了Node借口，由DOM中的所有节点类型实现。在JS中作为Node类型实现，除了IE，其他所有浏览器中都可以访问到这个类型。节点类型一共有12种。 使用方法： 123456if(someNode.nodeType == Node.ELEMENT_NODE) &#123; alert(\"Node is an element.\"); //不适用于IE&#125;if(someNode.nodeType == 1) &#123; alert(\"Node is an element.\"); //全部适用&#125; nodeName和nodeValue属性 对于元素节点，nodeName保存元素的标签名，nodeValue中则为null 节点关系 可以使用.childNode[]数组属性、item()方法来访问子节点： 123var firstChild = someNode.childNodes[0];var secondChild = someNode.childNodes.item(1);var count = someNode.childeNodes.length; 可以使用parentNode属性访问父节点，使用previousSibling和nextSibling属性访问兄弟节点，但是列表中第一个节点的previousSibling属性值为null，最后一个节点的nextSibling属性值也为null 可以使用firstChild和lastChild属性访问childNodes列表中第一个和最后一个节点。 操作节点 appendChild()方法新增节点：someNode.appendChild(newNode)，该方法返回新增的节点，若传入的参数节点已经存在，则该方法对该节点进行转移 insertBefore()方法插入特定位置，接受两个参数，一个是要插入的节点，第二个是参照节点 replaceChild()方法替换节点 removeChild()方法移除节点 cloneNode(一个bool参数表示是否执行深复制)、normalize()支持所有类型节点 Document类型JS中通过Document类型表示文档，document对象是HTMLDocument（继承自Document类型）的一个实例，表示整个HTML页面，也是window对象的一个属性。Document节点具有下列特征： nodeType值为9 nodeName的值”document“ parentNode的值为null nodeValue的值为null ownerDocument的值为null 文档的子节点可以通过documentElement属性（始终指向\\元素）和childNodes列表访问文档元素。 可以通过**document.body来访问\\元素，这两个属性所有浏览器均支持； 可以通过**document.doctype访问\\&lt;!DOCTYPE&gt;的引用，但是IE8之前不支持，而其他浏览器这个属性不存在在childNodes中 \\标签之外的注释也算文档的子节点，但是IE8/SAFARI/OPERA/CHROME均只为第一条注释创建节点 文档信息查找元素（最最常用）可以通过getElementById(“”)访问指定元素,ID大小写在IE7之前有要求。如果多个相同ID的元素出现，只返回第一个元素（IE7会在name等于指定id时且在这个id元素之前出现，返回有该name的元素） 可以通过getElementsByTagName(“”)访问指定元素列表，返回HTMLCollection对象，可以使用数组的下标访问，也可以通过item()方法进行访问，也可以通过该对象的namedItem(name)方法返回相同tag元素列表中指定的name元素。 可以通过getElementsByName()访问 特殊集合 document.anchors document.applets document.forms document.images document.links DOM一致性检测文档写入write()/writeln()/open()/close()是document对象的IO功能，这些函数是在加载过程当中写入的，所以加载完再运行write会导致整个页面消失： document.write(&quot;&lt;script type=\\&quot;text/javascript\\&quot; src=\\&quot;file.js\\&quot;&gt;&quot; + &quot;&lt;\\/script&gt;&quot;); Element类型要访问元素的标签名，最好使用tagName属性，但是注意这里tagName返回的是大写！ HTML元素（取得特性） 由HTMLElement类型表示，继承自Element类型，拥有id/title/lang/dir/className等属性 操作特性 操作特性的DOM方法主要有：div.getAttribute(“属性名除了style和onclick”)/div.setAttribute(“属性名”,”属性值”)/div.removeAttribute(“属性名”) attributes属性 创建元素 使用document.createElement()方法创建新元素，只接受一个参数为要创建的标签名 Text类型第十三章 事件事件流事件流描述的是从页面中接收事件的顺序。 事件冒泡 IE的事件流叫做事件冒泡：时间开始时由最具体的元素（嵌套层次最深的那个节点）接收，然后逐级向上传播直到文档根节点（window对象）。所有现代浏览器都支持事件冒泡。 事件捕获 从不太具体的节点开始接收事件，逐级到最具体的节点最后接收到事件。很少使用事件捕获。 DOM事件流 包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。 事件处理程序 HTML事件处理程序 1234&lt;form method=\"post\"&gt; &lt;input type=\"text\" name=\"username\" value=\"\"&gt; &lt;input type=\"button\" value=\"Echo Username\" onclick=\"alert(username.value)\"&gt;&lt;/form&gt; 缺点：如果调用的函数在引用之后定义，页面解析该函数之前就进行了操作会引发错误（时差问题）；不同JS引擎遵循的标识符解析规则略有差异，很可能会在访问非限定对象成员时出错。 DOM0级事件处理程序 1234var btn = document.getElementById(\"myBtn\");btn.onclick = function() &#123; alert(\"Clicked\");&#125; DOM2级事件处理程序 定义了addEventListener()和removeEventListener()用于添加和删除监听器的函数。都接受三个参数：处理事件名，事件处理函数，和一个bool值（该值为true捕获阶段调用，false冒泡阶段调用）。但是add方法添加的程序 只能用remove来删除，所以当add一个匿名函数时就无法被删除。 1234var btn = document.getElementById(\"myBtn\");btn.addEventListener(\"click\", function() &#123; alert(this.id); &#125;, false); 可添加多个事件，按顺序出发。 IE事件处理程序 IE中使用attachEvent()，事件处理程序会在全局作用域中进行，所以函数中出现的this等于window，而DOM0中的函数中出现的this就是局部作用于内运行。也有detachEvent()移除函数，所以道理与DOM2级事件处理程序一样。 1234var btn = document.getElementById(\"myBtn\");btn.attachEvent(\"onclick\", function() &#123; alert(\"Clicked\"); &#125;); 跨浏览器的事件处理程序 创建addHandler()方法，接受三个参数：要操作的元素、事件名称和事件处理程序函数；目的是判断情况应该使用DOM0/DOM2/IE的哪种方法，该方法属于EventUtil对象。 事件对象 DOM中的事件对象 兼容DOM的浏览器会将一个event对象传入到事件处理程序中。 1234567var btn = document.getElementById(\"myBtn\");btn.onclick = function(event) &#123; alert(event.type); //\"click\"&#125;;btn.addEventListener(\"click\", function(event) &#123; alert(event.type); //\"click\" &#125;, false) 事件处理程序内部的this永远都是currentTarget，也就是现在事件作用的目标（按钮、window等）； 一个函数处理多个事件，可以使用switch(event.type)函数；阻止特定时间的默认行为，可以使用preventDefault()方法；停止事件在DOM层次中传播停止事件的捕获和冒泡，可以调用stopPropagation()： 12345678var btn = document.getElementById(\"myBtn\");btn.onclick = function(event) &#123; alert(\"Clicked\"); event.stopPropagation(); //避免了下面body上的事件触发&#125;;document.body.onclick = function(event) &#123; alert(\"Body clicked\");&#125;; 事件对象的eventPhase属性可以用来确定事件当前正位于事件流的哪个阶段。捕获阶段调用程序为1，程序正在目标对象上为2，在冒泡阶段调用程序为3 IE中的事件对象 12345var btn = document.getElementById(\"myBtn\");btn.onclick = function() &#123; var event = window.event; alert(event.type); //\"click\"&#125; 由于事件处理程序的作用域在IE下是全局，在DOM下是局部作用域，所以提供event.srcElement来判断this的指向： 1234567var btn = document.getElementById(\"myBtn\");btn.onclick = function() &#123; alert(window.event.srcElement === this); //true&#125;;btn.attachEvent(\"onclick\", function(event) &#123; alert(event.srcElement === this); //false &#125;); 若想要取消时间的默认行为，可以通过设置window.event.returnValue = false进行； 若想要阻止时间的冒泡（IE只支持事件冒泡），可以通过设置window.event.cancelBubble = true; 跨浏览器的事件对象 事件类型 UI事件 load(html中可以给标签添加onload unload abort error select resize scroll 焦点事件 blur focus focusin focusout 鼠标与滚轮事件 click dbclick mousedown mouseenter mouseleave mousemove mouseout mouseover mouseup 键盘与文本事件 keydown keypress keyup 复合事件 compositionstart compositionupdate compositionend HTML5事件 contextmenu beforeunload DOMContentLoaded readystatechange pageshow/pagehide hashchange","categories":[{"name":"Document","slug":"Document","permalink":"http://keefe.wang/categories/Document/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://keefe.wang/tags/基础知识/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://keefe.wang/tags/JavaScript/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://keefe.wang/tags/读书笔记/"}]},{"title":"JavaScript中的原型与继承-继承篇","slug":"2017-04-13-JavaScript-Prototype-and-Inheritance-2","date":"2017-04-13T04:00:00.000Z","updated":"2020-10-20T08:54:59.265Z","comments":true,"path":"2017/04/13/2017-04-13-JavaScript-Prototype-and-Inheritance-2.html","link":"","permalink":"http://keefe.wang/2017/04/13/2017-04-13-JavaScript-Prototype-and-Inheritance-2.html","excerpt":"原型链原型链是实现继承的主要方法，基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。回顾构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型的内部指针。 此时我们令原型对象成为另一个对象的实例，该原型对象将包含一个指向另一个原型对象的指针，若是这样层层递进，就会构成一条实例和原型的链条，这就是原型链的基本概念。","text":"原型链原型链是实现继承的主要方法，基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。回顾构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型的内部指针。 此时我们令原型对象成为另一个对象的实例，该原型对象将包含一个指向另一个原型对象的指针，若是这样层层递进，就会构成一条实例和原型的链条，这就是原型链的基本概念。 由上图可以看出，原型链中，每个对象都有一个内部指针指向原型对象，而原型对象内部也会有指针指向另一个原型对象。图中新创建的Fruit和继承Fruit的Apple和Banana这样的对象的原型对象，首先会追溯到Object，而通过JavaScript的控制台使用Object.getPrototypeOf(obj)的方法得出Object的原型是function，而function的原型又会指向到Object，最后Object的原型最终会是null，到此为止null再也不会有原型对象。 这幅图也能很形象地展示出之前讲到过的原型搜索机制，即，当以读取模式访问一个实例属性时，1）首先搜索实例；2）搜索该实例的原型对象；3）搜索该实例的原型对象的原型对象；以此类推，直到找到null。需要注意的是： 所有引用类型都默认继承了Object； 通过instanceof操作符来确定原型和实例之间的关系； 由于子类继承过程中需要重写父类中的某些方法或者添加不存在的方法，给原型添加方法的代码一定要放在原型继承的语句之后； 在通过原型链实现继承时，不能使用对象字面量创建原型方法； 由于原型的实例都共享原型中的属性和方法，所以会导致原型中可能包含的引用类型（Function、Array）也被迫同步给每一个实例，所以需要一些解决办法。 继承继承方式经典继承123456789101112function SuperType() &#123; this.colors = [\"red\", \"blue\", \"green\"];&#125;function SubType() &#123; //继承了SuperType SuperType.call(this);&#125;var instance1 = new SubType();instance1.colors.push(\"blaack\");alert(instance1.colors); //\"red,blue,green,black\"var instance2 = new SubType();alert(instance2.colors); //\"red,blue,green\" 该方法，子类中使用call函数调用了父类中的函数，当然也可以向其中传入相应的参数。然而这个方法需要将所有的方法都在构造函数中定义，造成了函数复用无法实现。 组合继承（原型链+构造函数）参考上一篇文章中的“原型对象的缺点”以及上一点“经典继承”，结合起来就是组合继承的方法。 12345678910111213141516function SuperType(name) &#123; this.name = name; this.colors = [\"red\", \"blue\", \"green\"];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;function SubType(name, age) &#123; SuperType.call(this.name); this.age = age;&#125;SubType.prototype = new SuperType();SubType.prototype.constructor = SubType; //这一步是必须的吗？SubType.prototype.sayAge = function() &#123; alert(this.age);&#125;; 然而，组合继承也有一定的缺陷，即，无论何种情况下进行继承，都会调用量词父类的构造函数（一次是创建子类原型，其次是子类构造函数内部） 原型式继承原理是使用一个函数将一个对象进行复制，具体代码如下： 123456//将传入的对象o进行复制，副本传给一个新的构造函数function object(o) &#123; function F()&#123;&#125; F.prototype = 0; return new F();&#125; 而ES5中新增了Object.create()方法来规范原型式继承，该方法接受两个参数，第一个是所要复制的对象，第二个是属性描述符定义的属性和属性值。（不支持IE8及以下浏览器） 同样的，原型式继承也存在新创建的实例都必须默认共享原型对象的属性和方法，对于引用类型的属性是存在缺陷的。 寄生式继承寄生式继承的思路与寄生构造函数和工厂模式类似，即，创建一个仅用于封装继承过程的函数，该函数返回集成之后的对象。 1234567function createAnother(originalObj) &#123; var cloneObj = object(originalObj); clone.sayHi = function() &#123; alert(\"Hi\"); &#125;; return cloneObj;&#125; 寄生组合式继承为了解决组合继承中必须调用两次父类对象的构造函数这一问题，提出了寄生组合式继承。寄生组合式继承的思路是，通过借用构造函数来几成熟型，通过原型链的混成形式来继承方法。本质上，是使用寄生式继承来继承超类型的原型，再将结果指定给子类型的原型。其基本模式如下： 12345function inheritPrototype(subType, superType) &#123; var prototype = Object.create(superType.prototype); //创建父类副本 prototype.constructor = subType; //加强副本对象 subType.prototype = prototype; //完成原型继承父类副本&#125; 该方式之调用一次SuperType的构造函数，与此同时，原型链仍保持不变（仍能够使用instanceof和isPrototypeOf()方法确定继承关系），所以该方法目前来说是引用类型最理想的继承方式。 关于原型与继承的总结在JavaScript的编程过程中，需要考虑创建的对象是否需要被继承，如果有这样的需要，我们应当及时地使用组合模式（构造函数创建包含引用类型的属性，原型来创建该对象的函数方法）来创建该对象（构造函数）；在继承的过程中，最好采用寄生组合式继承的方法来进行对象的继承，以达到提高效率且保护原型链的目的。 在考虑原型和继承的过程中，需要牢记实例、对象（构造函数）和原型三者之间的关系。","categories":[{"name":"Document","slug":"Document","permalink":"http://keefe.wang/categories/Document/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://keefe.wang/tags/基础知识/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://keefe.wang/tags/JavaScript/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://keefe.wang/tags/读书笔记/"},{"name":"原型","slug":"原型","permalink":"http://keefe.wang/tags/原型/"},{"name":"继承","slug":"继承","permalink":"http://keefe.wang/tags/继承/"}]},{"title":"JavaScript正则表达式学习笔记[上]","slug":"2017-03-20-JavaScript-RegExpression-learning-note","date":"2017-04-12T04:00:00.000Z","updated":"2020-10-20T08:54:51.669Z","comments":true,"path":"2017/04/12/2017-03-20-JavaScript-RegExpression-learning-note.html","link":"","permalink":"http://keefe.wang/2017/04/12/2017-03-20-JavaScript-RegExpression-learning-note.html","excerpt":"正则表达式 Regular Expression正则表达式是由一个字符序列形成的搜索模式,可用于所有文本搜索和文本替换的操作。[^1]它的重要性就不言而喻了。本文结合《JavaScript高级程序设计》一书并整理其他资料，对正则表达式的基础进行一个学习笔记的记录。更加详细的正则表达式学习心得将在之后的笔记中进行记录。","text":"正则表达式 Regular Expression正则表达式是由一个字符序列形成的搜索模式,可用于所有文本搜索和文本替换的操作。[^1]它的重要性就不言而喻了。本文结合《JavaScript高级程序设计》一书并整理其他资料，对正则表达式的基础进行一个学习笔记的记录。更加详细的正则表达式学习心得将在之后的笔记中进行记录。 正则表达式构成正则表达式由一些普通字符和一些元字符（metacharacters）组成。普通字符包括大小写的字母和数字，而元字符（用于匹配任何单个字符）则具有特殊的含义[^2]： 元字符 元字符 描述 . 匹配除“\\r\\n”之外任何单个字符；要匹配“\\r\\n”在内的任何字符，使用“[\\s\\S]” \\0 查找NULL字符 \\b 匹配单词边界；也就是指单词和空格间的位置^3；例，“er\\b”可匹配“never”的”er” \\B 匹配非单词边界；“er\\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er” \\cX 匹配由X指明的控制字符；X的值必须为A-Z或a-z之一*；否则，视为一个原义的“c”字符 \\d 匹配一个数字字符；等价于[0-9] \\D 匹配一个非数字字符；等价于[^0-9] \\f 匹配一个换页符；等价于\\x0c和\\cL \\n 匹配一个换行符；等价于\\x0a和\\cJ \\r 匹配一个回车符；等价于\\x0d和\\cM \\s 匹配任何不可见字符；包括空格、制表符、换页符等；等价于[\\f\\n\\r\\t\\v] \\S 匹配任何可见字符；等价于[^\\f\\n\\r\\t\\v] \\t 匹配一个制表符；等价于\\x09和\\cI \\v 匹配一个垂直制表符；等价于\\x0b和\\cK \\w 匹配包括下划线的任何单词字符；该单词字符使用Unicode字符集 \\W 匹配任何非单词字符；等价于“[^A-Za-z0-9_]” \\xdd 匹配十六进制dd转义值；十六进制转义值必须为确定的两个数字长 \\n 标识一个八进制转义值或一个向后引用。如果\\n之前至少n个获取的子表达式，则n为向后引用 \\uN 匹配N，其中N是一个用四个十六进制数字表示的Unicode字符 转义字符 转义字符 描述（若字符本身要出现，需在特殊字符前面加\\） \\ 将下一个字符标记符、或一个向后引用、或一个八进制转义符 ^ 匹配输入字符串开始位置；若设置了正则表达式的mFlag，^也匹配“\\n”或“\\r”之后的位置 $ 匹配输入字符串结束位置；若设置了正则表达式的mFlag，$也匹配“\\n”或“\\r”之前的位置 * 匹配前置子表达式任意次；例，zo*能匹配“z”，“zo”以及“zoo”，等价于”o{0,}” + 匹配前置子表达式大于等于1次；例，“zo+”能匹配“zo”以及“zoo”,等价于{1,} ? 匹配前置子表达式零次或一次。例，“do(es)?”可以匹配“do”或“does”,等价于{0,1} . 匹配除“\\r\\n”之外任何单个字符；要匹配“\\r\\n”在内的任何字符，请使用像“[\\s\\S]”模式 将两个匹配条件进行逻辑“或”（Or）运算。注意：这个元字符不是所有的软件都支持的 量词类正则表达式 量词表达式 描述（若字符本身要出现，需在特殊字符前面加\\） n+ n为某pattern，匹配任何至少包含一个n的字符串 n* n为某pattern，匹配零个或者多个n的字符串 n? n为某pattern，匹配零个或者1个n的字符串 n{x} n为某pattern，匹配包含x个n的序列字符串 n{x,y} n为某pattern，匹配至少x个，最多y个n的字符串 n{x,} n为某pattern，匹配至少x个的字符串 获取/非获取以及正反向预查的正则表达式 获取/非获取RegExp 描述 (pattern) 匹配pattern并获取这一匹配；所获取的匹配可以从产生的Matches集合得到，请使用“(”或“)”匹配圆括号字符 (?:pattern) 非获取匹配；例，“industr(?:y ies)” (?=pattern) 非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95 98 NT 2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95 98 NT 2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。 (?&lt;=pattern) 非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95 98 NT 2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。 (?&lt;!pattern) 非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。 x y 匹配x或y。例如，“z food”能匹配“z”或“food”(此处请谨慎)。“[z f]ood”则匹配“zood”或“food”或” ood”。 []范围类正则表达式 []正则表达式 描述（只要[]中任意一个字符匹配就可以） [0-9] 字符范围；匹配指定范围内的任意一个数字 [xyz] 字符集合；匹配所包含的任意一个字符。例，“[abc]”可以匹配“plain”中的“a” [^xyz] 负值字符集合；匹配未包含的任意一个字符。例，“[^abc]”可以匹配“plain”中的“plin” [a-z] 字符范围；匹配指定范围内的任意一个字符 [^a-z] 负值字符范围；匹配任何不在指定范围内的任意字符 其他类型 其他表达式 描述 \\p{P} 小写p是property的意思，表示Unicode属性，用于Unicode正表达式的前缀。中括号内的“P”表示Unicode字符集七个字符属性之一：标点字符^4 \\&lt; &gt; 匹配一个word的开始（\\&lt;）和结束（&gt;） ( ) 将()内的表达式定义为“组”（group），并且将匹配这个表达式的字符保存到一个临时区域（一个正则表达式中最多可以保存9个），它们可以用\\1到\\9的符号来引用 语法 直接量语法： 1/pattern/flags; 其中//包含的内部（pattern）是正则表达式字符串的主体；最后的flags是正则表达式的修饰标志，包含属性有g，i，m三种，分别是与全局匹配，不区分大小写匹配和多行匹配三种修饰标志。 实例： 1var patt = /[bc]at/i; //匹配第一个“bat”或”cat“，不区分大小写 使用构造函数创建RegExp对象语法： 1new RegExp(pattern, attributes); 其中，pattern部分与上面直接量语法中的pattern相同，attributes是上面flags相同的标志； RegExp实例的属性和方法RegExp实例的属性RegExp的每一个实例都具有下列属性，这些属性可以获取到该实例pattern的相关信息： .global：bool值，表示是否设置了g标志 .ignoreCase：bool值，表示是否设置了i标志 .multiline：bool值，表示是否设置了m标志 .lastIndex：整数值，表示开始搜索下一个匹配项的自负位置，从0算起 .source：正则表达式的字符串表示，按照字面量形式而非传入构造参数中的字符串模式返回； RegExp实例的方法 exec()，该方法是专门为捕获组而设计的： 语法：RegExpObject.exec(testString) 参数：接受一个参数，即要应用该模式的字符串； 返回：包含第一个匹配项信息的数组（无匹配项时返回null）；且返回值含有两个额外属性，index表示匹配项在字符串中的位置/input表示应用正则表达式的字符串； 12345678var testString = \"mom and dad and baby\";var pattern = /mom( and dad( and baby)?)?/gi;var matches = pattern.exec(testString);alert(matches.index); //0alert(matches.input); //\"mom and dad and baby\"alert(matches.[0]); //\"mom adn dad and baby\"alert(matches.[1]); //\" and dad and baby\"alert(matches.[2]); //\" and baby\" 上述示例代码中，可以看到，返回的数组第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串。关于“组”的相关内容请参考上一章节的表格中的/()/项。 有关全局和非全局模式当pattern为全局模式时，每次调用exec()进行匹配时会返回下一个匹配项，即exec()调用过后，matches.index可能会增加，pattern.lastIndex也是同样会增加；如果pattern为非全剧模式时，每次调用exec()进行匹配时都会返回第一个匹配项。 test()，简单匹配。在不知道要进行匹配的文本内容情况下使用改方法比较好： 语法：RegExpObject.test(testString)； 参数：接受一个参数，即要进行匹配的文本字符串； 返回：如果字符串testString中含有与RegExpObject匹配的文本的话，就返回true，否则返回false； RegExp构造函数属性RegExp构造函数包含一些属性，这些属性适用于作用与众的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。这些属性分别有一个长属性名和一个短属性名（Opera不支持短属性名）： 长属性名 短属性名 说明 input $_ 最近一次要匹配的字符串 lastMatch $&amp; 最近一次的匹配项 lastParen $+ 最近一次要匹配的捕获组 leftContext $` input字符串中lastMatch之前的文本 multiline $* 布尔值，表示是否所有表达式都是用多行模式 rightContext $’ input字符串中lastMatch之后的文本 其中，前三项是Opera没有实现的属性。使用这些属性能够从exec()和test()执行的操作中提取更具体的信息。 [^1]:From http://www.runoob.com/js/js-regexp.htm[^2]:From http://baike.baidu.com/item/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F?sefr=enterbtn","categories":[{"name":"Document","slug":"Document","permalink":"http://keefe.wang/categories/Document/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://keefe.wang/tags/基础知识/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://keefe.wang/tags/JavaScript/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://keefe.wang/tags/读书笔记/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://keefe.wang/tags/正则表达式/"}]},{"title":"JavaScript中的原型与继承-原型篇","slug":"2017-04-12-JavaScript-Prototype-and-Inheritance-1","date":"2017-04-12T04:00:00.000Z","updated":"2020-10-20T08:54:55.736Z","comments":true,"path":"2017/04/12/2017-04-12-JavaScript-Prototype-and-Inheritance-1.html","link":"","permalink":"http://keefe.wang/2017/04/12/2017-04-12-JavaScript-Prototype-and-Inheritance-1.html","excerpt":"原型构造函数模式下，对象中的方法作用域只在对象中，对象的不同实例的同名函数都是不相等的。为了解决这个问题，js中创建的每一个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所由实例共享的属性和方法。","text":"原型构造函数模式下，对象中的方法作用域只在对象中，对象的不同实例的同名函数都是不相等的。为了解决这个问题，js中创建的每一个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所由实例共享的属性和方法。 原型对象JavaScript中并没有提供类的实现，虽然在ES2015/ES6之中引入了class关键字，但是JavaScript仍然是基于原型的。而JavaScript中创建对象的方法有：new Object()方法、字面量方法、工厂模式、构造函数方法和原型模式。其中，使用原型模式创建对象可以令所有实例共享方法，减少内存消耗，有利于对象继承。 JavaScript中的继承则是体现在一种结构上——对象，所有的对象都是由Object衍生的对象，所有的对象都继承了Object.prototype的方法和属性（也有可能被覆盖）。每一个对象都有一个内部链接到另一个对象，这个对象成为它的原型（prototype）。而且，该原型对象也有自己的原型，直到追溯到一个以null为原型的对象，因为null是没有原型的，所以可以作为这个原型链（prototype chain中的最终链接。 只要创建了一个新函数，就会为该函数创建一个prototype属性，这个属性指向函数的原型对象。所有原型对象都自动获得一个constructor属性，这个属性包含一个指向prototype属性所在函数的指针。 原型对象的创建1234567891011121314function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; &#125; Person.prototype.sayName = function() &#123; alert(this.name); &#125; var person1 = new Person(\"Nicholas\", 29, \"Lawyer\"); var person2 = new Person(\"Katie\", 30 \"Account\"); var person3 = new Person(\"Nicholas\", 29, \"Lawyer\"); person1.sayName(); //\"Nicholas\" person2.sayName(); //\"Katie\" alert(person1.sayName == person3.sayName); //true 更加简单的原型对象创建语法： 123456789function Person()&#123;&#125;Person.prototype = &#123; name : \"Nicholas\", age : 29, job : \"Software Engineer\", sayName : function() &#123; alert(this.name) &#125; &#125;; 代码搜索某属性的路径： 上面代码中出现了Person.prototype,通过该形式可以获得原型对象，并且可以为其添加属性和方法。这段代码也展示了对象属性和方法搜索的路径：每当代码读取某个对象的某个属性时，进行目标为该属性的名字，搜索首先从实例（person1）本身开始，若有该名字的属性则返回该属性，若没有则继续搜索该实例中原型指针指向的原型对象，在原型对象中查找该名字的属性。所以说实例是共享原型中保存的属性和方法。 实例的属性，原型的属性？ 一个对象的所有实例尽管可以共享该原型对象的所有属性和方法，但是却无法重写原型对象中的属性和方法，只能通过利用同名属性和方法来覆盖和屏蔽原型对象中的属性和方法；若想把实例中覆盖的属性还原，可以通过delete操作。使用hasOwnProperty()方法可以检测一个属性是存在于实例中还是存在于原型中。 怎样获得原型对象: 下面的代码展示了Object.getPrototypeOf(obj)方法和proto属性的使用： 12Object.getPrototypeOf(person1) === Person.prototype; //true person1.__proto__ === Person.prototype; //true 可以看到，Object.getPrototypeOf(obj)是获取obj对象的原型对象的方法，这个方法将在利用原型实现继承的情况中发挥非常重要的作用。obj.proto 也是如此，是每一个对象都拥有的属性，但是proto并不是一个规范的属性（当使用Object.create()方法创建对象时，proto 并不能指向该对象的原型对象），其对应的标准属性应当是[[Prototype]]。 原型对象和构造函数对于对象Person来说，它的构造函数是Person()，它的原型对象为Person.prototype；而Person.prototype.constructor又会指回Person。而对象Person的实例person1和person2都包含有一个属性[[Prototype]]（也就是上面提到的proto）它们都指向Person.prototype；同时，person1和person2也可以通过isprototypeOf(）方法来确定是否与确定对象之间有这种关系： alert(Person.prototype.isPrototypeOf(person1)); //true 原型与in操作符 in操作符单独使用的情况 in操作符单独使用会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是在原型中： 1234//接上面Person对象代码 var person4 = new Person(); alert(person4.hasOwnproperty(\"name\")); //由于person4实例没有覆盖原型中的name所以返回false alert(\"name\" in person4); //true for-in循环 该种方式是返回所有能够通过对象访问的、可枚举的属性，包括实例和原型中的属性，并且屏蔽了原型中不可枚举（[[Enumerable]]）的属性（仅在IE8及更早版本中有不可枚举的属性）： 12345678910var o = &#123; toString : function() &#123; return \"my Object\" &#125; &#125; for (var prop in o) &#123; if (prop == \"toString\") &#123; alert(\"Found toString\"); //IE中无法显示 &#125; &#125; 若想获取对象中所有可枚举的实例属性，可以使用Object.keys(),该函数接受一个对象或实例作为参数（当然也可以是原型对象），返回一个包含所有可枚举属性的字符串数组。示例代码如下： 123456789//接Person对象代码 var keys = Object.keys(person.prototype); var person5 = new Person(); person5.name = \"Rob\"; person5.age = 31; alert(keys); alert(Object.keys(person5)); var keys2 = Object .getOwnPropertyNames(Person.prototype); alert(keys2); 上述代码中出现的Object.getOwnPropertyNames(Person.prototype)方法可以得到所有的可枚举/不可枚举的实例属性（列入constructor）。 原型的动态性由于从原型中查找值的过程试一次搜索，因此对原型对象所做的任何修改都能从实例上反映出来。即，可以先创建实例，再修改原型对象中的属性或函数，实例依旧可以访问该属性和函数： 123456//接person对象代码 var friend = new Person(); Person.prototype.sayHi = function() &#123; alert(\"hi!\"); &#125;; friend.sayHi(); //返回”hi” 尽管像以上代码中所看到的可以为原型添加属性或方法，但是如果重写整个原型对象，就会切断实例的构造函数与最初原型对象之间的联系。这是因为实例中的指针仅指向原型，而非构造函数。 原生对象的原型不仅是自定义的对象，JavaScript中所有原生的引用类型，都是采用这种模式创建的原生对象。通过原生对象的原型可以取得所有默认方法的引用，也可以自己添加新的方法。 原型对象的缺点 由于原型中所有属性都是可以被实例共享，而对于原型中含有引用类型值的属性来说就会发生问题： 123456//接person对象代码 Person.prototype.friends = [\"Shelby\", \"Court\"]; var person6 = new Person(); person6.friends.push(\"Van\"); alert(person6.friends); alert(person1.friends); //此时两个Person的实例拥有相同的朋友，很可能发生错误 可以看到，由于原型的属性可以被共享的这一特性，原型对象中包含的引用类型值很可能被修改之后导致实例的属性也发生错误，必须要在实例属性中覆盖才可以。所以为了解决这个问题，提出了以下组合构造函数模式和原型模式的方法来创建对象： 123456789101112131415//改写上面的Person对象 //首先使用构造函数模式创建对象Person并加入容易被修改的属性name，age，job function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.friends = [\"Shelby\", \"Court\"]; &#125; //再使用原型模式创建构造函数和不容易被修改的属性和函数，这样可以发挥原型的共享机制并减少内存消耗 Person.prototype = &#123; constructor : Person, //将构造函数放入原型中 sayName : function() &#123; alert(this.name); &#125; &#125;","categories":[{"name":"Document","slug":"Document","permalink":"http://keefe.wang/categories/Document/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://keefe.wang/tags/基础知识/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://keefe.wang/tags/JavaScript/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://keefe.wang/tags/读书笔记/"},{"name":"原型","slug":"原型","permalink":"http://keefe.wang/tags/原型/"},{"name":"继承","slug":"继承","permalink":"http://keefe.wang/tags/继承/"}]},{"title":"CSS中的伪类与伪元素","slug":"2017-03-10-pseudoCSS-part1-pseudoElement-pseudoClass-note","date":"2017-03-10T04:00:00.000Z","updated":"2020-10-20T08:54:52.622Z","comments":true,"path":"2017/03/10/2017-03-10-pseudoCSS-part1-pseudoElement-pseudoClass-note.html","link":"","permalink":"http://keefe.wang/2017/03/10/2017-03-10-pseudoCSS-part1-pseudoElement-pseudoClass-note.html","excerpt":"简介[^1]样式表中的选择器是控制网页样式输出的非常重要的工具之一，也是css通过DOM树来控制其样式的最好的方式之一。而除了标签选择器、类选择器、ID选择器、属性选择器以及元素关系选择器（父子、兄弟等选择器），CSS3为我们提供了一种更为复杂同时也是更为方便设计者的选择方式-伪类（Pseudo-Classes）和伪元素（Pseudo-Elements）。 伪类和伪元素通常由冒号（colon）引导，而CSS3重新规定伪元素之前需要由两个冒号引导，但是为了使旧版本网站也能够统一使用和显示（IE8及以下浏览器无法理解双冒号的语法），浏览器则仍支持单冒号引导的伪元素方式（除了少数特定的伪元素之外）。","text":"简介[^1]样式表中的选择器是控制网页样式输出的非常重要的工具之一，也是css通过DOM树来控制其样式的最好的方式之一。而除了标签选择器、类选择器、ID选择器、属性选择器以及元素关系选择器（父子、兄弟等选择器），CSS3为我们提供了一种更为复杂同时也是更为方便设计者的选择方式-伪类（Pseudo-Classes）和伪元素（Pseudo-Elements）。 伪类和伪元素通常由冒号（colon）引导，而CSS3重新规定伪元素之前需要由两个冒号引导，但是为了使旧版本网站也能够统一使用和显示（IE8及以下浏览器无法理解双冒号的语法），浏览器则仍支持单冒号引导的伪元素方式（除了少数特定的伪元素之外）。 伪类和伪元素的区别[^2]CSS中的伪类根据元素的编码或动态状态等来选择HTML文档中特定部分，即选择HTML文档中的某元素（通过用户的干预或者随着时间的变化而产生动态改变状态），CSS2又将该特性扩展到了DOM树的某些“虚拟组件”和可推断部分（例如first-child），可以出现在选择器链条中的任何位置； CSS中的伪元素是用来强调某些元素的子部分，允许选择并改变那些除DOM中指定的元素之外的部分的样式（对DOM树中未包含的逻辑元素进行选择和改变样式）(可以用来展示比如头字母大写等常见的排版效果)；伪元素有一些使用的限制条件： 不允许出现在中的in-line样式（只能出现在外部样式表或位于的样式中）； 在选择器的链条中只能出现在最后一位（即要位于任何类和ID选择之后）； 每个选择器中只能出现一个伪元素（若要在单个元素结构中城县多个伪元素的选择，必须使用多个选择器/样式声明）； 伪类伪类就像是class一样，以冒号引导（e.g. :hover等），可以以标签:伪类和类:伪类的形式存在于CSS样式表中。 动态伪类链接样式的动态伪类针对链接，用户可以无任何操作、将光标移至链接上、点击、点击后放开光标，将光标从链接上移走等操作。 a:link选择用户还未进行过任何操作的链接； a:visited选择用户已经点击过的链接； a:hover选择用户将鼠标移至上方的链接；同时，:hover伪类也可以用在除链接以外的元素上（e.g. 或是）； a:active选择用户使用鼠标正在点击（按下）的链接； 样例代码：1234.example a:link &#123;color:gray;&#125; /*链接没被访问时为灰色*/.example a:visited &#123;color:maroon;&#125; /*链接被访问过后前景色为红色*/.example a:hover &#123;color:blue;&#125; /*鼠标悬浮在链接上时前景色为蓝色*/.example a:active &#123;color:darkblue;&#125; /*鼠标按下链接前景色为深蓝色*/ 这里需要特别注意的是，这四个动态伪类在样式表中定义的顺序是不可以任意排序的，而是要遵循唯一的一个顺序，即LOVE/HATE原则，即以a:link/a:visited/a:hover/a:active的顺序来定义。这是因为在CSS样式表中针对同一个元素的样式定义要从一般到特殊。一个链接在用户未进行操作的时候可能同时拥有:link、:visited和:hover三种样式属性，而无论如何:hover都会覆盖前面两种样式，所以:hover要在前面两种样式之后定义，而:link又是最一般的样式，所以要放在第一位来进行定义；最后:active则能覆盖所有之前三种属样式，所以放在最后一位进行定义。一句话来总结这一特性，越容易被覆盖的样式越先定义，覆盖越多的样式要越晚定义。 表单样式的动态伪类常对于输入类的表单进行选择并展示或修改其样式的动态伪类； :focus与链接中的:hover的作用类似，是当用户将光标的注意力集中到某元素而改变其样式，多用于用户在网页上的表单进行输入的元素进行选择（e.g. \\或\\）。 UI元素状态伪类(IE8及以下不支持该伪类)： :enabled选择可以进行输入和选择等操作的表单元素进行样式的声明； :disabled选择不能进行输入和选择等操作的表单元素进行样式的声明； :checked选择已经选择的表单元素（type为radio或checkbox元素）进行样式声明； :unchecked选择还未进行选择的表单元素进行样式声明； 子选择器（:nth选择器）CSS原本提供了后代选择器（descendant selector），但是针对于某些特定的场景，例如列表和表格制定行列的样式改变，CSS又提供了伪类选择器来为这些子类选择器提供服务。 :first-child选择指定元素中第一个子元素； :last-child选择指定元素中最后一个子元素； :nth-child(parameter)选择某个元素的一个或多个特定的子元素，参数可以是自然数，也可以是像2n，3n+1，-n+3这样的公式进行有规律的子元素选择； :nth-last-child()与:nth-child()作用相同，但是是从选定元素的最后一个子元素开始算起； :nth-of-type()与:nth-child()作用相同，但是可以选择指定类别的子元素； :nth-last-of-type()与:nth-nth-of-type()作用相同，但是是从选定元素的最后一个子元素开始算起； :first-of-type与:first-child作用相同，只是可以选择子元素的类型； :last-of-type与:last-child作用相同，只是可以选择子元素的类型； :only-child当指定元素只有一个子元素时，选择该子元素； :only-of-type当指定元素只有一个指定类型的子元素时，选择该子元素； :empty当制定元素中没有任何内容时； 特殊伪类选择器 :target该伪类类似于HTML中的锚，指向文档中某个具体的元素，常用于点击出现某些指定元素样式的改变（点击按钮，某元素由display:none变为display:block;这样的出现效果）； :not也被称作negation pseudo-class，也就是否定取反。当使用类似于 1p:not(.exampleStyle)&#123;color:green&#125; 时，意为选择所有不包含。exampleStyle类的p元素进行选择改变字体颜色为green。 伪元素::before和::after ::before可以在某给定元素上添加提前展示的内容： 1.tip::before &#123;content: \"HOT TIP!\" &#125; ::after可以在某给定元素上添加提前展示的内容： 1.tip::after &#123;content: \"HOT TIP!\" &#125; 文字排版常见的::first-line和::first-letter ::first-line选择制定元素的第一行（例如改变每个段落的第一行文本样式）； ::first-letter选择制定文本块的第一个字母进行样式设置，多用于进行段落排版； 光标选中文本样式::selection::selection用来改变浏览网页选中文本的默认效果； [^1]: 《CSS, The Missing Manual, 4th Edition》[^2]: Difference between a pseudo-class and a pseudo-element","categories":[{"name":"Document","slug":"Document","permalink":"http://keefe.wang/categories/Document/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://keefe.wang/tags/基础知识/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://keefe.wang/tags/读书笔记/"},{"name":"CSS3","slug":"CSS3","permalink":"http://keefe.wang/tags/CSS3/"},{"name":"Selector","slug":"Selector","permalink":"http://keefe.wang/tags/Selector/"}]},{"title":"Node-js基础学习笔记","slug":"2016-12-13-nodejs-basic-learning-note","date":"2016-12-13T04:00:00.000Z","updated":"2020-10-20T08:54:42.867Z","comments":true,"path":"2016/12/13/2016-12-13-nodejs-basic-learning-note.html","link":"","permalink":"http://keefe.wang/2016/12/13/2016-12-13-nodejs-basic-learning-note.html","excerpt":"Node.js基础学习笔记在前端的学习过程当中，不可避免地要学习到一定的后台服务器的技术。之前一直都沉浸在servlet中无法自拔，所以Java一度成为自己还比较熟悉的后台语言，但是相对于本身比较熟悉的JavaScript来说，当然是尽量用JS来处理后台最好不过了，所以Node.js顺其自然成为了学习路上必要的一道关卡。 略过安装、配置和创建第一个应用，想必很多Node.js相关网站都可以找到相应的教程，本文仅记录在学习Node.js基础知识中一些关键点技术。","text":"Node.js基础学习笔记在前端的学习过程当中，不可避免地要学习到一定的后台服务器的技术。之前一直都沉浸在servlet中无法自拔，所以Java一度成为自己还比较熟悉的后台语言，但是相对于本身比较熟悉的JavaScript来说，当然是尽量用JS来处理后台最好不过了，所以Node.js顺其自然成为了学习路上必要的一道关卡。 略过安装、配置和创建第一个应用，想必很多Node.js相关网站都可以找到相应的教程，本文仅记录在学习Node.js基础知识中一些关键点技术。 Node.js应用Node.js 应用是由下面几部分组成的： 引入 required 模块：我们可以使用 require 指令来载入 Node.js 模块。 创建服务器：服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。 接收请求与响应请求 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。 创建一个服务器： 1234567891011var http = require('http');http.createServer(function (request, response) &#123; // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); // 发送响应数据 \"Hello World\" response.end('Hello World\\n');&#125;).listen(8888);// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); 回调函数Node.js是单进程单线程应用程序，但是通过事件和回调支持并发和异步。 Node的所有API都支持回调函数，并作为一个独立线程运行，完美支持异步处理大量的请求。回调函数作为最后一个参数传入异步函数，而回调函数的第一个参数为错误对象： 123456789var fs = require(\"fs\");fs.readFile('input.txt', function (err, data) &#123; if (err)&#123; console.log(err.stack); return; &#125; console.log(data.toString());&#125;);console.log(\"程序执行完毕\"); 事件循环Node.js使用事件驱动模型，所有的事件机制都是用设计模式中观察者模式实现。代码中引入events模块，通过实例化EventEmitter类来绑定和监听事件： 12345678var events = require('events'); // 引入 events 模块var eventEmitter = new events.EventEmitter(); // 创建 eventEmitter 对象event.on('some_event', function() &#123; // 绑定事件，function中可添加多参数 console.log('some_event 事件触发'); &#125;); setTimeout(function() &#123; // 触发事件 event.emit('some_event'); &#125;, 1000); events模块下只有一个对象：events.EventEmitter，其核心就是事件触发与事件监听两者的封装。EventEmitter的每个事件都由一个事件名（一个字符串）和若干参数构成。一般来说，不会直接使用EventEmitter，而是在对象中继承它，包括fs、net、http在内都是EventEmitter的子类（为了符合事件语义，并且符合JS的原型对象机制）。 EventEmitter对象的属性 .addListener(event, listener)：为指定事件添加一个监听器到监听器数组的尾部 .on(event, listener)：为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数 .once(event, listener):为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器 .removeListener(event, listener)：移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称 .removeAllListeners([event])：移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器 setMaxListeners(n)：默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息；setMaxListeners 函数用于提高监听器的默认限制的数量 listeners(event)：返回指定事件的监听器数组。 emit(event, [arg1], [arg2], […])：按参数的顺序执行每个监听器，如果事件有注册监听返回 true，否则返回 false。 缓冲区由于JS中不支持二进制数据类型，所以在处理像TCP流或文件流时，Node.js提供了Buffer类，用来创建一个专门存放二进制数据的缓存区（一个Buffer类类似于一个整数数组）。创建Buffer实例有多种方法： 123+ 以字节数量创建：var buf = new Buffer(10);+ 以数组创建：var buf = new Buffer([10, 20, 30, 40, 50]);+ 以字符串创建：var buf = new Buffer(&quot;www.runoob.com&quot;, &quot;utf-8&quot;); 写入缓冲区：buf.write(string[, offset[, length]][, encoding]);参数分别为必须的写入缓冲区的字符串，可选的开始写入索引值（默认为0）、写入字节数（默认buffer.length）、使用的编码（默认为utf8）。该写入的方法会返回实际写入的大小 读缓冲区：buf.toString([encoding[, start[, end]]]); 将Buffer实例转换为JSON对象：buf.toJSON() 缓冲区合并：Buffer.concat(bufArray[, totalLength]);其中bufArray是需要进行合并的Buffer实例数组 缓冲区比较：buf.compare(otherBuffer);返回负数表示buf在前，0表示相同，正数表示buf在后 拷贝缓冲区：buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]]);其中buf是被复制的，targetBuffer是复制的目标缓冲区 缓冲区裁剪：buf.slice([start[, end]]);返回一个新的缓冲区，与旧缓冲区指向同一块内存，索引不同 缓冲区长度：buf.length;返回缓冲区所占内存长度 Stream是一个抽象接口，流类型有四种： 1234+ Readable：可读操作+ Writable：可写操作+ Duplex：可读可写操作+ Transform：操作被写入数据，然后读出结果 所有的Stream对象都是EventEmitter的实例，所以可以绑定的常用事件有data（有数据可读时触发）、end（没有更多数据可读时触发）、error（接收和写入过程发生错误时触发）、finish（所有数据写入到底层系统时触发）。 Node中又有很多对象实现了这个接口，例如对http服务器发起请求的request对象就是一个Stream，stdout（标准输出）也是一个Stream。 读取流 1234567891011121314var fs = require(\"fs\");var data = '';var readerStream = fs.createReadStream('input.txt');//创建可读流readerStream.setEncoding('UTF8');// 处理流事件 --&gt; data, end, and errorreaderStream.on('data', function(chunk) &#123; //此处的data并不是读取结果字符串 data += chunk;&#125;);readerStream.on('end',function()&#123; console.log(data);&#125;);readerStream.on('error', function(err)&#123; console.log(err.stack);&#125;); 写入流 1234567891011var fs = require(\"fs\");var data = '菜鸟教程官网地址：www.runoob.com';var writerStream = fs.createWriteStream('output.txt');//创建写入流writerStream.write(data,'UTF8');writerStream.end(); // 标记文件末尾writerStream.on('finish', function() &#123; console.log(\"写入完成。\");&#125;);writerStream.on('error', function(err)&#123; console.log(err.stack);&#125;);","categories":[{"name":"Document","slug":"Document","permalink":"http://keefe.wang/categories/Document/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://keefe.wang/tags/基础知识/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://keefe.wang/tags/JavaScript/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://keefe.wang/tags/Nodejs/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://keefe.wang/tags/读书笔记/"}]},{"title":"Jena学习笔记","slug":"2015-11-20-jena-learning-note","date":"2015-09-21T04:00:00.000Z","updated":"2020-10-20T08:54:45.535Z","comments":true,"path":"2015/09/21/2015-11-20-jena-learning-note.html","link":"","permalink":"http://keefe.wang/2015/09/21/2015-11-20-jena-learning-note.html","excerpt":"Jena初步了解JenaAPI的框架如下图：","text":"Jena初步了解JenaAPI的框架如下图： 如上图所示，利用Jena进行语义网处理应用的开发有通过HTTP和Servlet响应的B/S模式，还有通过JenaAPI进行Java编程来处理本体数据。 RDF API：Jena提供了对RDF文件的创建、读/写以及一些基本操作的接口（方法）； SPARQL API：Jena提供一套对本体的三元组的query机制，类似于SQL语言对于数据库的操作，SPARQL对于本体的查询也可以通过简单的查询语句达到目的，这也为B/S模式的本体展示和交互提供了基础； Ontology API： Fuseki RDF API名词解释 Blank Node：一阶逻辑中表示一个无URI的resource Literal：可作为一个property的值（value） Object：the resource or literal pointed to by the arc（箭头指向的一端） Subject：the resource from which the arc leaves（箭头离开的一端） Triple： Predicate：三元组中的属性部分（关系）（the property that labels the arc） Property：一个resource的属性，指三元组中的关系 Resouce：实体，通常由URI命名的资源 Statement：指一个fact，即一个三元组（Each arc in an RDF Model） 对RDF的操作（JavaAPI） Create graph 123456789101112// some definitionsstatic String personURI = \"http://somewhere/JohnSmith\";static String fullName = \"John Smith\";// create an empty ModelModel model = ModelFactory.createDefaultModel();// create the resourceResource johnSmith = model.createResource(personURI);// add the property johnSmith.addProperty(VCARD.FN, fullName); Create resource and add the property 12//Resouce exampleResource johnSmith = model.createResource(personURI).addProperty(VCARD.FN, fullName); 123456789101112131415161718// some definitionsString personURI = \"http://somewhere/JohnSmith\";String givenName = \"John\";String familyName = \"Smith\";String fullName = givenName + \" \" + familyName;// create an empty ModelModel model = ModelFactory.createDefaultModel();// create the resource// and add the properties cascading styleResource johnSmith = model.createResource(personURI) .addProperty(VCARD.FN, fullName) .addProperty(VCARD.N, model.createResource() .addProperty(VCARD.Given, givenName) .addProperty(VCARD.Family, familyName)); Manipulate the stmt 123456789101112131415161718192021// list the statements in the ModelStmtIterator iter = model.listStatements();// print out the predicate, subject and object of each statementwhile (iter.hasNext()) &#123; Statement stmt = iter.nextStatement(); // get next statement Resource subject = stmt.getSubject(); // get the subject Property predicate = stmt.getPredicate(); // get the predicate RDFNode object = stmt.getObject(); // get the object System.out.print(subject.toString()); System.out.print(\" \" + predicate.toString() + \" \"); if (object instanceof Resource) &#123; System.out.print(object.toString()); &#125; else &#123; // object is a literal System.out.print(\" \\\"\" + object.toString() + \"\\\"\"); &#125; System.out.println(\" .\");&#125; 由于object可以是Resource或者Literal，所以object的类型为RDFNode。 Writing RDF 1234// now write the model in XML form to a filemodel.write(System.out);model.write(System.out, \"RDF/XML-ABBREV\"); // write the model in XML form to a filemodel.write(System.out, \"N-TRIPLES\"); // write the model in N-TRIPLES form to a file Reading RDF 123456789101112131415// create an empty model Model model = ModelFactory.createDefaultModel(); // use the FileManager to find the input file InputStream in = FileManager.get().open( inputFileName );if (in == null) &#123; throw new IllegalArgumentException( \"File: \" + inputFileName + \" not found\");&#125;// read the RDF/XML filemodel.read(in, null);// write it to standard outmodel.write(System.out); SPARQL API需要保存在.rq文件中进行使用。 Basic query： 1SELECT ?xWHERE&#123; ?x&lt;http://www.w3.org/2001/vcard-rdf/3.0#FN&gt; &quot;JohnSmith&quot; &#125; 其中&lt;&gt;中为URI，“”中为literal，？x为查询变量 Basic pattern 1234WHERE &#123; ?y &lt;http://www.w3.org/2001/vcard-rdf/3.0#Family&gt; &quot;Smith&quot; . ?y &lt;http://www.w3.org/2001/vcard-rdf/3.0#Given&gt; ?givenName . &#125; basic patterns：是一组三元组的模式；prefix and blanknodes： 1234567PREFIX vcard: &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt;SELECT ?y ?givenNameWHERE &#123; ?y vcard:Family &quot;Smith&quot; . ?y vcard:Given ?givenName . &#125; Filters 1234567PREFIX vcard: &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt;SELECT ?gWHERE&#123; ?y vcard:Given ?g . FILTER regex(?g, &quot;r&quot;, &quot;i&quot;) &#125; 上面的加粗为FILTER，其中最后一个“”中的i表示case-insensitive Optionals（表示如果有这个属性那么就显示在结果中，如果没有就不显示） 123456789PREFIX info: &lt;http://somewhere/peopleInfo#&gt;PREFIX vcard: &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt;SELECT ?name ?ageWHERE&#123; ?person vcard:FN ?name . OPTIONAL &#123; ?person info:age ?age &#125;&#125; optionals with filters： 123456789PREFIX info: &lt;http://somewhere/peopleInfo#&gt;PREFIX vcard: &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt;SELECT ?name ?ageWHERE&#123; ?person vcard:FN ?name . OPTIONAL &#123; ?person info:age ?age . FILTER ( ?age &gt; 24 ) &#125;&#125; Unions： 12345678PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;PREFIX vCard: &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt;SELECT ?nameWHERE&#123; &#123; [] foaf:name ?name &#125; UNION &#123; [] vCard:FN ?name &#125;&#125; 相当于FILTER ( ?p = foaf:name || ?p = vCard:FN)如果是分开资源那么只要分别用不同变量标注即可： 12345SELECT ?name1 ?name2WHERE&#123; &#123; [] foaf:name ?name1 &#125; UNION &#123; [] vCard:FN ?name2 &#125;&#125; SPARQL result forms： SELECT – Return a table of results. CONSTRUCT – Return an RDF graph, based on a template in the query. DESCRIBE – Return an RDF graph, based on what the query processor is configured to return. ASK – Ask a boolean query.","categories":[{"name":"Document","slug":"Document","permalink":"http://keefe.wang/categories/Document/"}],"tags":[{"name":"JenaAPI","slug":"JenaAPI","permalink":"http://keefe.wang/tags/JenaAPI/"},{"name":"API","slug":"API","permalink":"http://keefe.wang/tags/API/"},{"name":"Ontology","slug":"Ontology","permalink":"http://keefe.wang/tags/Ontology/"},{"name":"基础知识","slug":"基础知识","permalink":"http://keefe.wang/tags/基础知识/"}]},{"title":"Ontology本体基础知识总结整理","slug":"2015-09-21-ontology-concepts-conclusion","date":"2015-09-21T04:00:00.000Z","updated":"2020-10-20T08:54:46.248Z","comments":true,"path":"2015/09/21/2015-09-21-ontology-concepts-conclusion.html","link":"","permalink":"http://keefe.wang/2015/09/21/2015-09-21-ontology-concepts-conclusion.html","excerpt":"本体的概念共享概念模型的明确的形式化规范说明。包括四个主要的方面： 概念化（conceptualization）：客观世界的现象的抽象模型； 明确（explicit）：概念及它们之间联系都被精确定义； 形式化（formal）：精确的数学描述； 共享（share）：本体中反映的知识是其使用者共同认可的。","text":"本体的概念共享概念模型的明确的形式化规范说明。包括四个主要的方面： 概念化（conceptualization）：客观世界的现象的抽象模型； 明确（explicit）：概念及它们之间联系都被精确定义； 形式化（formal）：精确的数学描述； 共享（share）：本体中反映的知识是其使用者共同认可的。 本体构成要素 类：集合（sets）、概念、对象类型或者说事物的种类； 关系：关系代表了在领域中类之间的交互作用。形式上定义为n 维笛卡儿乘积的子集： R ： C1 ×C2×⋯×Cn 。 如：子类关系( subclass-of)； 函数： 函数是一类特殊的关系。在这种关系中前n - 1 个元素可以惟一决定第n 个元素。形式化的定义如下： F ： C1 ×C2 ×⋯×Cn-1→Cn 。例如Mother-of 关系就是一个函数，其中Mother-of ( x ， y) 表示y 是x 的母亲，显然x 可以惟一确定他的母亲y； 公理：公理代表永真断言，比如概念乙属于概念甲的范围； 实例：实例代表元素，即某个类中的第一个对象； 专家系统 知识库： 推理机：本体按照是否具备推理功能可以分为轻量级本体、中级本体和重量级本体；技术构成库应该属于可以识别一阶谓词逻辑表达式的中级本体 本体语言 本体语言目前成为标准的是OWL； Cyc和loom两种语言具有较强的推理能力； 领域本体的知识库构建 本体构建原则：清晰、一致、可扩展性、编码偏好程度最小、本体约定最小； 两种模式： 利用现有文献和领域专家使用手工的方式创建概念关联； 将已有的叙词表改造成本体，或者采用学习机制，进行自动或自动化的本体构建。 本体手工构建方法：骨架法、企业建模法、Methontology、KACTUS、循环获取法、IDEF-5、七步法； 七步法： 确定本体的专业领域与范畴； 考查复用现有本体的可能性； 列出本体中的重要术语； 定义类和类的等级关系； 定义类的属性； 定义属性的分面(Facets)； 创建实例。 领域本体知识库架构三个层次： 表示层：表示层是用户与系统交互的接口，用户通过浏览器或其他界面访问系统，用户界面负责接收查询请求， 并将服务端的检索结果回显给用户； 业务逻辑层：业务逻辑层为主要应用逻辑层，实现系统知识的检索。它由本体管理组件、语义分析组件、推理引擎、查 询组件和信息获取组件5个部分组成； 数据层：数据层包括3个部分：本体库、资源描述库、资源数据库。它是知识库的存储介质，创建并提炼出结构化 的知识本体，是知识检索的直接来源；","categories":[{"name":"Document","slug":"Document","permalink":"http://keefe.wang/categories/Document/"}],"tags":[{"name":"Ontology","slug":"Ontology","permalink":"http://keefe.wang/tags/Ontology/"},{"name":"基础知识","slug":"基础知识","permalink":"http://keefe.wang/tags/基础知识/"},{"name":"Knowledge Base","slug":"Knowledge-Base","permalink":"http://keefe.wang/tags/Knowledge-Base/"}]},{"title":"Markdown","slug":"2014-12-25-markdown-programming-language","date":"2014-12-24T16:31:00.000Z","updated":"2020-10-20T08:55:23.857Z","comments":true,"path":"2014/12/25/2014-12-25-markdown-programming-language.html","link":"","permalink":"http://keefe.wang/2014/12/25/2014-12-25-markdown-programming-language.html","excerpt":"本篇文章是关于本站博客文章的Markdown格式的文档。","text":"本篇文章是关于本站博客文章的Markdown格式的文档。 段落元素 p和br 标题 段落引用 列表 代码 Horizontal Rules 表格 段内元素 链接 强调 代码 图片 混杂模式 自动链接 Backslash Escapes 内联HTML Block ElementsParagraphs and Line Breaks段落HTML标签: &lt;p&gt; 在一段后进行回车空出一行可以达到该效果。 代码: This will be inline. This is second paragraph. 预览: This will beinline. This is second paragraph. HeadersMarkdown支持两种方式的标题：Setext/atx. SetextHTML标签: &lt;h1&gt;, &lt;h2&gt; 使用等号‘=’在标题下划线代表&lt;h1&gt;， 使用连字符‘-’在标题下划线表示 &lt;h2&gt;，其中符号的数量可以不做限制. 代码: This is an H1 ============= This is an H2 ------------- 预览: This is an H1This is an H2 atxHTML标签: &lt;h1&gt;, &lt;h2&gt;, &lt;h3&gt;, &lt;h4&gt;, &lt;h5&gt;, &lt;h6&gt; 使用1到6个‘#’号来表示标题标签 &lt;h1&gt; - &lt;h6&gt;. 代码: # This is an H1 ## This is an H2 ###### This is an H6 预览: This is an H1This is an H2This is an H6 atx格式的标题可以进行闭合如### This is an H3 ######，可见两端的‘#’号数量不需要相等。 BlockquotesHTML标签: &lt;blockquote&gt; 需要再每一个段落之前加‘&gt;’符号来形成段落引用。 Code: &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, &gt; &gt; This is nested blockquote. &gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; &gt; id sem consectetuer libero luctus adipiscing. Preview: This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, This is nested blockquote. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse ListsMarkdown支持有序和无序列表。 无序列表HTML标签: &lt;ul&gt; 无序列表可以使用‘*’、‘+’、‘-’三种符号开头并在符号后添加一个空格。 代码: * Red + Green — Blue 预览: Red Green Blue OrderedHTML标签: &lt;ol&gt; 有序列表通过数字和点符号‘.’以及空格开头来表示，前面的数字是几无所谓，会自动解析成从小到大的顺序。 代码: 1. Bird 22. McHale 3. Parish 44\\. Cat 预览: Bird McHale Parish44. Cat 缩进段落级别的缩进使用tab添加在段落之前即可。 Code BlocksHTML标签: &lt;pre&gt; 代码的每一行都缩进至少‘4个空格’和‘1个tab’，代码结束是以第一个不缩进的段落为止。 代码: This is a normal paragraph: This is a code block. 代码: This is a normal paragraph: This is a code block. 包裹代码可以使用`*3后跟语法名称来进行代码的包裹，从而避免每一行的缩进并可以进行语法高亮。 代码: Here&apos;s an example: 123function test() &#123; console.log(\"notice the blank line before this function?\");&#125; 预览: 123function test() &#123; console.log(&quot;notice the blank line before this function?&quot;);&#125; Horizontal RulesHTML Tag: &lt;hr /&gt;分界线可以使用’*‘、’-‘、’_’ 代码: * * * *** ***** - - - --------------------------------------- ___ 预览: - - - TableHTML标签: &lt;table&gt; 表格使用‘|’、‘:’、‘-’三种符号进行构造，其中‘-’符号必须有至少3个才能构造表格。代码: 12345678| Left | Center | Right ||:-----|:------:|------:||aaa |bbb |ccc ||ddd |eee |fff |A |B--|--12|45 预览: Left Center Right aaa bbb ccc ddd eee fff A B 12 45 Span ElementsLinksHTML标签: &lt;a&gt; Markdown支持两种类型的链接：内联在段落中和引用模式. 内联内联在段落中[Link Text](URL &quot;Title&quot;)，如果是在本站的网址，可以使用相对地址进行访问。 代码: This is [an example](http://example.com/ &quot;Title&quot;) inline link. See my [About](/about/) page for details. 预览: This is an example inline link. See my About page for details. 参考引用参考链接的形式如此：[id]: URL &quot;Title&quot; 代码: [id]: http://example.com/ &quot;Optional Title Here&quot; This is [an example][id] reference-style link. 预览: This is an example reference-style link. EmphasisHTML标签: &lt;em&gt;, &lt;strong&gt; Markdown使用‘*’、‘_’符号进行斜体的标注，‘**’、‘__’符号进行粗体的标注，如果直接使用‘*’符号可以加‘\\’进行转义。 代码: *single asterisks* _single underscores_ **double asterisks** __double underscores__ 预览: single asterisks single underscores double asterisks double underscores CodeHTML标签: &lt;code&gt; 使用‘`’来对内联的代码进行包裹，backtick quotes (`). Code: Use the `printf()` function. Preview: Use the printf() function. ImagesHTML标签: &lt;img /&gt; Markdown支持内联和参考引用两种方式进行图片的添加。 内联内联图片代码如此： ![Alt text](URL &quot;Title&quot;)，其中title是可选的一项。 代码: ![Alt text](/path/to/img.jpg) ![Alt text](/path/to/img.jpg &quot;Optional title&quot;) Reference参考引用方式的代码如此： ![Alt text][id] 代码: [img id]: url/to/image &quot;Optional title attribute&quot; ![Alt text][img id] MiscellaneousAutomatic Links使用‘&lt; &gt;’符号将链接包裹形成自动链接。 代码: &lt;http://example.com/&gt; &lt;address@example.com&gt; 预览: http://example.com/ &#x61;&#100;&#100;&#114;&#x65;&#x73;&#x73;&#x40;&#x65;&#x78;&#97;&#109;&#112;&#108;&#x65;&#x2e;&#x63;&#x6f;&#109; Backslash Escapes使用反斜线来进行某些符号的转义 代码: \\*literal asterisks\\* 预览: *literal asterisks* 支持以下符号: Code: \\ backslash ` backtick * asterisk _ underscore {} curly braces [] square brackets () parentheses # hash mark + plus sign - minus sign (hyphen) . dot ! exclamation mark Inline HTML如果需要一些HTML中的标签而Markdown中没有的，可以直接使用HTML标签进行包裹使用。 代码: This is a regular paragraph. &lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; This is another regular paragraph. 预览: This is a regular paragraph. Foo This is another regular paragraph.","categories":[{"name":"Document","slug":"Document","permalink":"http://keefe.wang/categories/Document/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://keefe.wang/tags/Markdown/"}]}]}