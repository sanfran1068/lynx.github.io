{"meta":{"title":"Lynx-Blog","subtitle":null,"description":null,"author":"Keefe Wang","url":"http://keefe.wang"},"pages":[{"title":"Categories","date":"2017-05-15T01:58:51.000Z","updated":"2017-10-09T07:13:05.000Z","comments":true,"path":"categories/index.html","permalink":"http://keefe.wang/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2017-05-15T02:02:29.000Z","updated":"2017-10-09T07:13:05.000Z","comments":true,"path":"about/index.html","permalink":"http://keefe.wang/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-05-15T01:54:35.000Z","updated":"2017-10-09T07:13:05.000Z","comments":true,"path":"tags/index.html","permalink":"http://keefe.wang/tags/index.html","excerpt":"","text":""},{"title":"welcome","date":"2017-05-18T14:44:39.000Z","updated":"2017-10-09T07:13:05.000Z","comments":true,"path":"welcome/index.html","permalink":"http://keefe.wang/welcome/index.html","excerpt":"","text":""}],"posts":[{"title":"ES6入门必须了解的知识（上）","slug":"2017-08-02-ES6-Must-Know-Keypoint-Note","date":"2017-08-02T04:00:00.000Z","updated":"2017-10-09T07:13:05.000Z","comments":true,"path":"2017/08/02/2017-08-02-ES6-Must-Know-Keypoint-Note.html","link":"","permalink":"http://keefe.wang/2017/08/02/2017-08-02-ES6-Must-Know-Keypoint-Note.html","excerpt":"最近一段时间的实习期间，团队进行了一次ESLint规范的调整和文档改进，里面涉及到了非常多ES6的内容，而在之前热力图项目中也用到了像Promise对象、async函数等的知识，所以专门参考阮一峰写的《ECMAScript6入门》一书对ES6的一些重要知识点进行一次整理。","text":"最近一段时间的实习期间，团队进行了一次ESLint规范的调整和文档改进，里面涉及到了非常多ES6的内容，而在之前热力图项目中也用到了像Promise对象、async函数等的知识，所以专门参考阮一峰写的《ECMAScript6入门》一书对ES6的一些重要知识点进行一次整理。 Babel转码器Babel是可以将ES6代码转为ES5代码的转码器。 配置文件 .babelrc 该配置文件是使用Babel工具和模块必须的，存放在项目的根目录下，用来设置转码规则和插件，基本格式如下 1234&#123; \"presets\": [], \"plugins\": []&#125; 其中presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。一般安装最新的的规则集 npm install --save-dev babel-preset-latest ，然后，配置文件应该如下 12345678&#123; \"presets\": [ \"latest\", \"react\", \"stage-2\" ], \"plugins\": []&#125; 命令行转码babel-cli 安装命令： npm install --global babel-cli 基本用法（全局环境下）： 转码结果输出到标准输出： babel example.js 转码结果写入一个文件： babel example.js --out-file compiled.js 整个目录转码： babel src --out-dir lib 建议将babel-cli安装在项目目录下 安装命令： npm install --save-dev babel-cli; 改写package.json 12345678&#123; \"devDependencies\": &#123; \"babel-cli\": \"^6.0.0\" &#125;, \"scripts\": &#123; \"build\": \"babel src -d lib\" &#125;&#125; 转码命令（在项目目录下）： npm run build; ES6的REPL环境babel-node： babel-node随babel-cli工具安装，执行 babel-node 进入REPL环境可以直接运行命令了 babel-register babel-register木块改写require命令，可以使文档中使用require加载的.js/.jsx/.es/.es6后缀的文件先进行babel转码： 局部安装： npm install --save-dev babel-register 使用（前必须先加载babel-register）： 12require(\"babel-register\");require(\"./index.js\"); babel-core：当代码需要调用Babel的API进行转码时 安装： npm install babel-core --save 项目中调用： 123456789101112131415161718var babel = require('babel-core'); // 字符串转码babel.transform('code();', options);// =&gt; &#123; code, map, ast &#125; // 文件转码（异步）babel.transformFile('filename.js', options, function(err, result) &#123; result; // =&gt; &#123; code, map, ast &#125;&#125;); // 文件转码（同步）babel.transformFileSync('filename.js', options);// =&gt; &#123; code, map, ast &#125; // Babel AST转码babel.transformFromAst(ast, code, options);// =&gt; &#123; code, map, ast &#125; babel-polyfill Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。如果想让这个方法运行，必须使用babel-polyfill Traceus转码器 直接插入网页 在线转换 命令行转换 常量和变量除了ES5提出的var和function两种声明变量的方法，ES6提出了let和const命令，以及import命令和class命令。所以ES6中一共有六种声明变量的方法。 let和const命令 let命令 ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 基本用法：特别适合在for循环计数器中使用，而且循环体是循环语句的自作用域： 123456789101112var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 可以避免闭包中只能读取最后一个值 for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc'; console.log(i);&#125; // abc 特点 不存在变量提升（变量提升是指变量在声明之前可以使用但是值为undefined） 暂时性死区：只要块中有let声明变量语句，该变量在该块中就必须服从let语句的规则（const也是如此），所以typeof也是不安全的 不允许重复声明：包括在相同作用域内禁止重复声明同一个变量（只要出现let就不允许，包括var），以及函数内部重新声明参数 块级作用域 由于内层变量可能会覆盖外层变量，用来计数的循环变量泄露成为全局变量。 let实际上为JavaScript新增了块级作用域： 1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; 特点 块级作用域可以任意嵌套，但是外层作用域无法读取内层作用域的变量 内层作用域可以定义外层作用域的同名变量 实际上让立即执行函数表达式不再必要（直接将需要立即执行的函数内部代码写在{}块级作用域中即可） 块级作用域与函数声明 ES6明确允许在块级作用域中声明函数（在ES5中函数声明只能在函数作用域或全局作用域中进行），且块级作用域中的函数声明行为类似于let，，但必须在有大括号的情况下成立，且在块级作用域外不可引用。 但是浏览器不遵守上述规定，有自己的行为方式： 允许在块级作用域内声明函数 函数声明类似于var，即会提升到全局作用域或函数作用域的头部 同时，函数声明还会提升到所在的块级作用域的头部 所以尽量不要在块级作用域内声明函数，若非要声明，也应该写成函数表达式而非函数声明语句。 do表达式 块级作用域内的let声明的变量无法在作用域外被访问，所以提出了do表达式，可以使块级作用域表现为表达式并有返回值： 1234let x = do &#123; let t = f(); t * t + 1;&#125;; const命令 声明一个只读的常量，声明之后该值不能改变。所以一旦声明必须赋值！ 特点： 不会被提升； 存在暂时性死区 将一个引用变量声明为常量需要小心（该常量指向引用变量的地址，但是里面的内容是可以修改的，所以对象常量不可以被重新赋值为新的引用变量） 如果想让对象以及对象里的内容只读，那么需要使用 const foo = Object.freeze({}); 顶层对象的属性 顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。但是这样存在很多问题： 没法在编译时报出变量未声明的错误（只能运行时报错） 容易莫名其妙创建全局变量 顶层对象可以随处读写，不利于模块化编程 所以ES6提出了： var命令和function命令声明的全局变量依旧是顶层对象的属性 let命令、const命令和class命令声明的全局变量不属于顶层对象的属性： 12let b = 1;window.b // undefined global对象 ES5中的顶层对象，在浏览器中是window，浏览器和WebWorker里面self也指向顶层对象，在Node里面是global 对于this变量来说，ES5全局环境this返回顶层对象；Node和ES6模块返回当前模块；函数作为对象的方法运行指向对象，否则指向顶层对象，严格模式下返回undefined； 变量的解构赋值 数组的解构赋值 用法： let[a, b, c] = [1, 2, 3]; 只要两边的数组结构模式相同，那么就可以使用这种数组解构赋值。 两种特殊情况： 左边模式变量多于右边数组元素变量，解构不成功，返回undefined 左边模式变量少于右边数组元素变量，解构成功 等号右边不是数组（严格讲，可遍历的数据结构），报错 事实上，只要具有Iterator解构的数据结构，都可以采用数组的形式进行解构赋值，例如 let [x, y, z] = Set([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]); , 默认值：解构赋值允许指定默认值，使用表达式来赋值，但是默认值对应的数组中的位置如果不是严格等于undefined，默认值不会生效： 12let [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 默认值是一个惰性求值的表达式，只有右边数组中没有或者undefined时才会求值 123456789function f() &#123; console.log('aaa');&#125;let [x = f()] = [1]; //此处f()不会求值，因为右边已经赋值成功 let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError 对象的解构赋值 按照对象的同名属性可以进行正确得解构赋值 123456let &#123; bar, foo &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo // \"aaa\"bar // \"bbb\" let &#123; baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz // undefined 其真正的机制为： let { foo: foo, bar: bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; 注意冒号后面的才是真正的变量 所以 let { foo: baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; 中baz才被赋值 这里需要注意的是由let进行声明，不可以重新声明，可以使用var替换，也可以试用一下的方式： 1234567891011let foo;(&#123;foo&#125; = &#123;foo: 1&#125;); // 成功，圆括号必须有，否则会认为是一个代码块而非赋值语句let baz;(&#123;bar: baz&#125; = &#123;bar: 1&#125;); // 成功// 错误的写法let x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error, &#123;&#125;会被理解成一个代码块 // 正确的写法(&#123;x&#125; = &#123;x: 1&#125;); 解构赋值失败会返回undefined，与数组相同，对象也可以用于嵌套结构，牢记冒号前的一般为模式，要分清模式和真正的变量；对象也可以有默认值，默认值的表达式也是惰性求值（任何非undefined的值都会对默认值进行覆盖），常用例子： let { log, sin, cos } = Math; 数组本质是特殊的对象，所以对象解构赋值等号右边可以是一个数组。 字符串的解构赋值 字符串分解为数组： const [a, b, c, d, e] = &#39;hello&#39;; 字符串（是一个对象）属性解构赋值：let {length : len} = &#39;hello&#39;; 数值和布尔值的解构赋值 由于Number和Bool值都是值类型，所以解构赋值前需要转换为引用类型，比如可以使用toString方法： 12let &#123;toString: s&#125; = 123;s === Number.prototype.toString // true 由于undefined和null无法转为对象，所以无法进行解构赋值 函数参数的解构赋值 函数参数的解构赋值就是在函数的参数位置进行解构赋值，可以使用上面提到的数组解构赋值、对象解构赋值、字符串解构赋值等，支持默认值（默认值是当解构失败会返回的值），也可以直接传入数组、对象 1234567891011121314151617function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125; //该处为x,y指定默认值 move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125; //该处为函数的参数指定默认值，这里要进行深入研究 move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] 圆括号问题：尽量不要再解构赋值的模式（等号左边的一堆）中放置圆括号 不能使用圆括号的三种情况 变量声明语句中模式不能带有圆括号 函数参数中模式不能带有圆括号 赋值语句中，不能在模式外/嵌套模式中的一层套圆括号 可以使用圆括号的情况 只有一种：赋值语句的非模式部分可以使用圆括号 解构赋值的用途 交换变量的值 123let x = 1;let y = 2;[x, y] = [y, x]; 从函数返回多个值 1234567891011121314// 返回一个数组function example() &#123;return [1, 2, 3];&#125;let [a, b, c] = example(); // 返回一个对象function example() &#123;return &#123; foo: 1, bar: 2&#125;;&#125;let &#123; foo, bar &#125; = example(); 函数参数的定义 1234567// 参数是一组有次序的值function f([x, y, z]) &#123; /*...*/ &#125;f([1, 2, 3]); // 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; /*...*/ &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取JSON数据（都支持嵌套结构） 12345678910let jsonData = &#123; id: 42, status: \"OK\", data: [867, 5309]&#125;; let &#123; id, status, data: number &#125; = jsonData; console.log(id, status, number);// 42, \"OK\", [867, 5309] 函数参数默认值 1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;; 遍历Map结构 12345678910111213141516171819var map = new Map();map.set('first', 'hello');map.set('second', 'world'); for (let [key, value] of map) &#123; console.log(key + \" is \" + value);&#125;// first is hello// second is world // 获取键名for (let [key] of map) &#123;// ...&#125; // 获取键值for (let [,value] of map) &#123;// ...&#125; 输入模块的指定方法：const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;); 字符串的扩展 字符的Unicode表示法 ES5只限制采用码点在\\u0000~\\uFFFF之间的字符，ES6规定只要将码点放入大括号，就能正确解读（最后JS有z \\z \\172 \\x7A \\u007A \\u{7A}六种表示字符方法）： 1234567891011\"\\u&#123;20BB7&#125;\"// \"𠮷\" \"\\u&#123;41&#125;\\u&#123;42&#125;\\u&#123;43&#125;\"// \"ABC\" let hello = 123;hell\\u&#123;6F&#125; // 123 '\\u&#123;1F680&#125;' === '\\uD83D\\uDE80'// true codePointAt() JS内部字符以UTF-16的格式储存，每个字符固定为2个字节。大于2个字节的字符，charAt()和charCodeAt()都不能读取整个字符，所以引入了codePointAt()，返回十进制码点。想返回十六进制，可以.toString(16) String.fromCodePoint() 可识别大于0xFFFF的字符，与上面的codePointAt()方法正好相反 字符串遍历器接口 ES6可以使用for a of b结构对字符串循环遍历： 1234567891011var text = String.fromCodePoint(0x20BB7); for (let i = 0; i &lt; text.length; i++) &#123;console.log(text[i]);&#125;// 无法识别0xFFFF的码点 for (let i of text) &#123;console.log(i);&#125;// \"𠮷\" .at() 使用垫片库实现&#39;𠮷&#39;.at(0)对0xFFFF字符进行charAt()操作 .normalize() 用来将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。 1234'\\u01D1'.normalize() === '\\u004F\\u030C'.normalize()// true /*该函数可以接收NFC(合成形式)/NFD(分解形式)/NFKC/NFKD作为参数*/ .includes(), .startsWith(), .endsWith() 都是找字符串中是否是包含、以…开始、以…结束的，均返回bool值，接收两个参数，第一个参数为寻找的子串，第二个参数为开始（end是结束）寻找的父串的下标： 12345var s = 'Hello world!'; s.startsWith('world', 6) // true，这里要注意s.endsWith('Hello', 5) // trues.includes('Hello', 6) // false .repeat() 接收一个参数作为重复次数n（n&gt;-1），返回一个重复n次的新字符串： .padStart(), .padEnd() 接收两个参数，一个是指定字符串长度，第二个是用来补全的”补丁字符串”（若补丁字符串超出长度则截取，若第二个参数省略用空格补全，不想要的话使用.trim()）： 12'x'.padStart(5, 'ab') // 'ababx''x'.padEnd(4, 'ab') // 'xaba' 模板字符串 ES6引入模板字符串，使用反引号（`）来标识（可嵌套），可以当做普通字符串，也可以用来定义多行字符串（多行字符串中的空格和缩进都会保留在输出之中）： 12345678910111213141516// 普通字符串`In JavaScript '\\n' is a line-feed.` // 多行字符串`In JavaScript this isnot legal.` console.log(`string text line 1string text line 2`); // 字符串中嵌入变量使用$&#123;表达式、对象属性甚至调用函数等&#125;，牢记&#123;&#125;中最后返回的都是字符串var name = \"Bob\", time = \"today\";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` //字符串里出现`需要转义var greeting = `\\`Yo\\` World!`; 模板编译 标签模板 模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。 当模板字符串里有变量，会将模板字符串先处理成多个参数，再调用函数 处理结果是(stringArray, value1, value2)，处理过程是将所有非变量的部分存在一个字符串数组中，剩下的变量依次一个个排在后面: 1234567891011121314151617var total = 30;var msg = passthru`The total is $&#123;total&#125; ($&#123;total*1.05&#125; with tax)`; function passthru(literals) &#123;var result = '';var i = 0; while (i &lt; literals.length) &#123; result += literals[i++]; if (i &lt; arguments.length) &#123; result += arguments[i]; &#125;&#125;return result;&#125; msg // \"The total is 30 (31.5 with tax)\" “标签模板”重要应用： 过滤HTML字符串，防止用户输入恶意内容 多语言转换（国际化处理） 嵌入其他语言 String.raw() 用来充当模板字符串的处理函数，返回一个斜杠都被转义（斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串，源码如下： 123456789String.raw = function (strings, ...values) &#123; var output = \"\"; for (var index = 0; index &lt; values.length; index++) &#123; output += strings.raw[index] + values[index]; &#125; output += strings.raw[index] return output;&#125; 该函数接受第一个参数是有raw数组属性的的对象 模板字符串的限制：默认会将字符串转义，所以无法嵌入其他语言（例如LaTeX），但是标签模板可以 正则的扩展 RegExp构造函数 ES5中，RegExp构造函数如下： 参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）var regex = new RegExp(&#39;xyz&#39;, &#39;i&#39;); 参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝var regex = new RegExp(/xyz/i); ES6允许有第二个参数（flag）：var regex = new RegExp(/xyz/ig, &#39;i&#39;);，且第二个参数会覆盖表达式中的修饰符 字符串的正则方法： 字符串对象共有4个方法，可以使用正则表达式：match()、replace()、search()和split()。ES6将这4个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。 String.prototype.match 调用 RegExp.prototype[Symbol.match]，以此类推… u修饰符 含义为Unicode模式，处理大于\\uFFFF的Unicode字符 点字符：对于码点大于0xFFFF的Unicode字符，点字符不能识别，必须加上u修饰符 1234var s = '𠮷'; /^.$/.test(s) // false/^.$/u.test(s) // true Unicode字符表示法：使用大括号表示的unicode字符需要加u修饰符/\\u{20BB7}/u.test(&#39;𠮷&#39;) 预定义模式 i修饰符：添加u才能够识别非规范的字母 y修饰符 粘连修饰符，y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。 123456789var s = 'aaa_aa_a';var r1 = /a+/g;var r2 = /a+/y; r1.exec(s) // [\"aaa\"]r2.exec(s) // [\"aaa\"] r1.exec(s) // [\"aa\"]r2.exec(s) // null sticky属性 flags属性 RegExp.escape() s修饰符：dotAll模式 后行断言 Unicode属性类 数值的扩展 二进制和八进制的表示法 二进制0b/0B，八进制0o/0O Number.isFinite(Number), Number.isNaN(Number) 分别检查一个数值是否为有限的、是否为NaN Number.parseInt(Number), Number.parseFloat(Number) 分别将参数（字符串）转换为int和float数据类型 Number.isInteger() 用来判断一个值是否为整数（3和3.0都可以返回true） Number.EPSILON() 一个极小的常量，用来设置一个误差范围来精确浮点数计算： 12345function withinErrorMargin (left, right) &#123; return Math.abs(left - right) &lt; Number.EPSILON;&#125;withinErrorMargin(0.1 + 0.2, 0.3) // truewithinErrorMargin(0.2 + 0.2, 0.3) // false 安全证书和Number.isSafeInteger() JavaScript能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。 Math对象的扩展 Math.trunc方法用于去除一个数的小数部分，返回整数部分,可以接收数字和数字字符串 Math.sign方法用来判断一个数到底是正数、负数、还是零 Math.cbrt方法用于计算一个数的立方根 Math.clz32方法返回一个数的32位无符号整数形式有多少个前导0 Math.imul方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数 Math.fround方法返回一个数的单精度浮点数形式 Math.hypot方法返回所有参数的平方和的平方根 Math.expm1(x)返回ex - 1，即Math.exp(x) - 1 Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x) Math.log10(x)返回以10为底的x的对数 Math.log2(x)返回以2为底的x的对数。如果x小于0，则返回NaN ES6新增了6个三角函数方法： Math.sinh(x) 返回x的双曲正弦（hyperbolic sine） Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine） Math.tanh(x) 返回x的双曲正切（hyperbolic tangent） Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine） Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine） Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent） Math.signbit() Math.signbit()方法判断一个数的符号位是否设置了 指数运算符 两个乘号代表指数运算符 数组的扩展 扩展运算符扩展运算符（spread）是三个点（…），可将一个数组转为用逗号分隔的参数序列。所以该运算符可以用来代替apply调用函数的方式,apply方法是将数组展开为函数的参数，扩展运算符也可以达到此目的。 扩展运算符的应用主要有： 合并数组：[...arr1, ...arr2, ...arr3] 与解构赋值结合：const [first, ...rest] = [1, 2, 3, 4, 5]; 函数返回多个值； 将字符串转化为数组：能够正确识别32位的Unicode字符，最好使用扩展运算符； 实现了Iterator接口的对象： Map、Set解构和Generator函数都可以使用扩展运算符 Array.from() Array.from方法用于将两类对象转为真正的数组：类似数组的对象（DOM操作返回的NodeList集合以及函数内部arguments对象）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map），第一个参数接受一个类数组对象，第二个参数接受一个类map方法对对象进行操作。 12345678910111213141516171819// arguments对象function foo() &#123; var args = Array.from(arguments); // ...&#125;``` 也可以用来进行对数组的复制`arrayCopy = Array.from([1,2,3]);` 扩展运算符（...）也可以将某些数据结构转为数组（必须是部署了Symbol.iterator遍历器接口的对象）： ```javascript// arguments对象function foo() &#123; var args = [...arguments];&#125; // NodeList对象[...document.querySelectorAll('div')] Array.of() ES5中，Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于2个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。 Array.of方法用于将一组值，转换为数组。 1234Array.of() // []Array.of(undefined) // [undefined]Array.of(1) // [1]Array.of(1, 2) // [1, 2] 数组实例的copyWithin() 它接受三个参数，start和end指定要复制的子串，target指定从哪里开始替换:[1, 2, 3, 4, 5].copyWithin(0, 3) // [4, 5, 3, 4, 5] target（必需）：从该位置开始替换数据。 start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数（加数组长度即可）。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 数组实例的find()和findIndex() 数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 123[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10 1findIndex()与find()用法相同，返回寻找到的成员下标 数组实例的fill() fill方法使用给定值，填充一个数组： 12['a', 'b', 'c'].fill(7) // [7, 7, 7]['a', 'b', 'c'].fill(7, 1, 2) // ['a', 7, 'c'] 数组实例的entries(), key()和values() ES6提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 数组实例的includes() Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。该方法属于ES7，但Babel转码器已经支持。 数组的空位 数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。空位不是undefined，undefined是属于有值的！ 函数的扩展 函数参数的默认值 1234567function Point(x = 0, y = 0) &#123; this.x = x; this.y = y;&#125; var p = new Point();p // &#123; x: 0, y: 0 &#125; 如果参数默认值是变量，那么参数就不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。 123456789let x = 99;function foo(p = x + 1) &#123; console.log(p);&#125; foo() // 100 x = 100;foo() // 101 与解构赋值默认值结合使用 1234function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y); &#125;foo(&#123;x: 1&#125;) // 1, 5 **在某些情况下，传入undefined时才会触发参数默认值** 函数的length属性：指函数预期传入参数的个数，返回没有指定默认值时的参数的个数（指定了默认值后length属性失真，从指定默认值的那以为开始失真，而之前没有指定默认值的还是会计入length）：(function (a, b = 1, c) {}).length // 返回1 参数默认值和作用域 一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。 1234567891011121314151617181920212223242526272829var x = 1;function f(x, y = x) &#123; console.log(y);&#125;f(2) // 由于参数初始化自己形成单独作用域，所以y=x=2，不考虑函数外的全局变量let a = 1;function f(b = a) &#123;let a = 2;console.log(b);&#125;f() // 在这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x``` 这个参数默认值的作用域有一个非常不错的应用途径：指定某参数不可忽略，否则抛出错误提示：```javascriptfunction throwIfMissing() &#123; throw new Error('Missing parameter');&#125;function foo(mustBeProvided = throwIfMissing()) &#123; return mustBeProvided;&#125;foo() rest参数 rest参数使用…扩展运算符将多余参数放入数组中，形式为(a, …b),所以该函数可以传入任意数目的参数，该参数也可以使用所有数组特有的方法： 123456789const sortNumbers = (...numbers) =&gt; numbers.sort();function push(array, ...items) &#123; items.forEach(function(item) &#123; array.push(item); console.log(item); &#125;);&#125;var a = [];push(a, 1, 2, 3) 需要注意的是，rest参数之后不能再有其他的参数，函数的length属性也不适用于rest参数。 函数内部严格模式 在ES5中，函数内部可以使用严格模式，在ES2016中则规定只要函数参数使用了默认值、解构赋值、扩展运算符，那么函数内部就不能显式设定严格模式（这是因为函数内部严格模式适用于函数体和函数参数，由于函数执行是先执行函数参数继而执行函数体，所以在函数参数执行的时候无法获知是否使用严格模式，导致报错）。 如果非要在有默认值、解构赋值或扩展运算符在函数参数中出现并需要再函数内设定严格模式，那么可以使用： 全局性的严格模式 使用无参数的立即执行函数将所需函数包含进去，并在立即执行函数中使用严格模式 函数的name属性：返回该函数的函数名 1234var f = function () &#123;&#125;;f.name // \"f\"const bar = function baz() &#123;&#125;;bar.name // \"baz\" 上面代码中显示，函数表达式中如果赋值的是匿名函数，则函数名返回该变量的变量名，若赋值的是具名函数，则返回该具名函数的函数名。 需要注意两点： Function构造函数返回的函数实例，name属性的值为anonymous，(new Function).name // &quot;anonymous&quot; bind返回的函数，name属性值会加上bound前缀(function(){}).bind({}).name // &quot;bound &quot; 箭头函数：var f = v =&gt; console.log(v); 箭头函数是定义函数的简单方法，相当于匿名函数，‘=&gt;’符号左边是函数的参数（如果不需要参数或者需要多个参数，可以直接使用()代替参数），右边是函数体（多余一条语句的代码块需要用{}括起来，如果返回的是一个对象，则该对象需要使用()括起来）。 12//将上面sort函数改进为可以按照大小排序的方法var result = values.sort((a, b) =&gt; a - b); 需要注意的是： 1. 箭头函数体内this对象是定义时所在对象，而非使用时所在对象2. 箭头函数不可以当做构造函数，不可以使用new命令3. 不能使用arguments对象，但是可以使用rest参数代替4. 不能使用yield命令，因此箭头函数不能用作Generator函数 箭头函数还可以进行嵌套： 123456const pipeline = (...funcs) =&gt; val =&gt; funcs.reduce((a, b) =&gt; b(a), val);const plus1 = a =&gt; a + 1;const mult2 = a =&gt; a * 2;const addThenMult = pipeline(plus1, mult2);addThenMult(5)// 12 上述代码显示，箭头前的（输出）作为箭头后的输入 绑定this：该语法是ES7的一个提案，函数绑定运算符是并排的两个冒号::，左边为一个对象，右边为一个函数，功能是将函数绑定在左边对象的上下文环境中（当前this指向左边的对象）；由于绑定之后返回的仍然是对象，所以可以链式写法： 12345678910111213141516171819202122232425 foo::bar; // 相当于 bar.bind(foo); foo::bar(...arguments); // 等同于 bar.apply(foo, arguments); ``` - 尾调用优化：尾调用是指某个函数的最后一步是调用另一个函数`function f(x)&#123;return g(x);&#125;`- 尾递归优化：对于尾递归来说，只存在一个调用帧，永远不会发生“栈溢出”的错误，但是必须在严格模式下才可以生效： ```javascript //非尾递归： function Fibonacci (n) &#123; if ( n &lt;= 1 ) &#123;return 1&#125;; return Fibonacci(n - 1) + Fibonacci(n - 2); &#125; //尾递归： function Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123; if( n &lt;= 1 ) &#123;return ac2&#125;; return Fibonacci2 (n - 1, ac2, ac1 + ac2); &#125;","categories":[{"name":"Document","slug":"Document","permalink":"http://keefe.wang/categories/Document/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://keefe.wang/tags/基础知识/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://keefe.wang/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://keefe.wang/tags/ES6/"}]},{"title":"LESS官方文档学习笔记","slug":"2017-05-10-LESS-document-note","date":"2017-08-02T04:00:00.000Z","updated":"2017-10-09T09:16:16.000Z","comments":true,"path":"2017/08/02/2017-05-10-LESS-document-note.html","link":"","permalink":"http://keefe.wang/2017/08/02/2017-05-10-LESS-document-note.html","excerpt":"LESS是一种动态样式语言。LESS将CSS赋予了动态语言的特性，如变量，继承，运算，函数。LESS既可以在客户端上运行 (支持IE 6+，Webkit， Firefox)，也可以借助Node.js或者Rhino在服务端运行。","text":"LESS是一种动态样式语言。LESS将CSS赋予了动态语言的特性，如变量，继承，运算，函数。LESS既可以在客户端上运行 (支持IE 6+，Webkit， Firefox)，也可以借助Node.js或者Rhino在服务端运行。 使用方式 客户端使用 在页面顶端加入下面代码，在服务器环境下可以使用less文件： 12&lt;link rel=\"stylesheet/less\" type=\"text/css\" href=\"styles.less\"&gt;&lt;script src=\"less.js\" type=\"text/javascript\"&gt;&lt;/script&gt; 注意，LESS文件引入时rel的值为stylesheet/less；less.js一定要在LESS文件引用之后的位置。 在服务器端使用 使用npm工具管理器在服务器端安装LESS，之后可以在Node中调用编译器，类似于： 1234var less = require('less');less.render('.class &#123; width: 1 + 1 &#125;', function (e, css) &#123; console.log(css);&#125;); 可以通过向解析器传递参数对LESS进行配置： 1234567var parser = new(less.Parser)(&#123; paths: ['.', './lib'], // Specify search paths for @import directives filename: 'style.less' // Specify a filename, for better error messages&#125;);parser.parse('.class &#123; width: 1 + 1 &#125;', function (e, tree) &#123; tree.toCSS(&#123; compress: true &#125;); // Minify CSS output&#125;); 也可以通过命令行的方式调用LESS解析器对LESS文件进行解析或编译： 12$ lessc styles.less$ lessc styles.less &gt; styles.css 语法注释完全支持CSS中的注释方法。 变量LESS中的变量是完全的“常量”，由@符号引导，且只能够定义一次： 123456789@nice-blue: #5B83AD;@light-blue: @nice-blue + #111; @fnord: \"I am fnord.\";@var: 'fnord';.text&#123; color: light-blue; content: @@var;&#125; 混合LESS中定义好通用的class属性集之后，可以在另一个属性集中调用： 12345678.bordered &#123; border-top: dotted 1px black; border-bottom: solid 2px black;&#125;.post a &#123; color: red; .bordered;&#125; 带参数混合 可以像函数的参数一样为样式属性集合名称中添加带默认值的参数（参数可设置多个，使用逗号进行分割，可以使用@arguments代替所有参数出现在样式属性集合体之中），该混合方法最适合隐藏某属性集合但需要引用该属性集合时使用。 12345678910111213141516171819202122/*带有参数的混合方法*/.border-radius (@radius: 5px) &#123; border-radius: @radius; -moz-border-radius: @radius; -webkit-border-radius: @radius;&#125;#header &#123; .border-radius(4px);&#125;/* 使用@arguments代替所有参数进行表达 其中传参个数可以少于参数数量，但是参 数的位置必须对应，中间参数位置不可空*/.box-shadow (@x: 0, @y: 0, @blur: 1px, @color: #000) &#123; box-shadow: @arguments; -moz-box-shadow: @arguments; -webkit-box-shadow: @arguments;&#125;.special-box-shadow &#123; .box-shadow(2px, 5px);&#125; 模式匹配和导引表达是 模式匹配 如果想根据传入的参数来改变混合的默认呈现，可以使用模式匹配方式（相当于将第一个参数设置为可变参数，该参数可以设置switch的选项来启动相应的模式）： 123456789101112131415.mixin (dark, @color) &#123; color: darken(@color, 10%);&#125;.mixin (light, @color) &#123; color: lighten(@color, 10%);&#125;/*接受任意值，相当于默认值*/.mixin (@_, @color) &#123; display: block;&#125;@switch: light; .someClass &#123; .mixin(@switch, #888);&#125; 引导 当我们想根据表达式进行匹配，而非根据值和参数匹配时，导引就显得非常有用。如果你对函数式编程非常熟悉，那么你很可能已经使用过导引。 导引中可以用的比较运算符有：&gt;、&gt;=、=（这里相当于==）、=&lt;、&lt; 12345678910111213/* 使用when语句判断条件，lightness()是一个 判断颜色亮度的函数。*/.mixin (@a) when (lightness(@a) &gt;= 50%) &#123; background-color: black;&#125;.mixin (@a) when (lightness(@a) &lt; 50%) &#123; background-color: white;&#125;.mixin (@a) &#123; color: @a;&#125; when后面所跟的条件，值为布尔true时才会执行解析，而LESS中的除去上面的**比较结果返回值**以及**关键词true**以外的值都视为布尔false： 12345/*下面两个语句含义相同*/.truth (@a) when (@a) &#123; color: black; &#125;.truth (@a) when (@a = true) &#123; color: black; &#125;/*下面一句是不会匹配任何条件，也不执行*/.someClass &#123; .truth(255); &#125; 导引之后可以有**多个条件**，一般使用`(condition1),(condition2),...`的形式来表示。符合其中的任意一个条件，匹配就可以成功，属性集才会被执行，这个形式相当于使用关键词*or*来连接条件实现或门。另外，可以使用关键词*and*实现与门，使用*when not*关键词实现非门。 导引语句when之后的判断条件中可以是**不含参数**的判断条件，也可以是对多个参数的比较等： 1234.mixin (@a) when (@media = mobile) &#123; ... &#125;.mixin (@a) when (@media = desktop) &#123; ... &#125;.max (@a, @b) when (@a &gt; @b) &#123; width: @a &#125;.max (@a, @b) when (@a &lt; @b) &#123; width: @b &#125; 其中判断语句中可以使用一些判断函数，如常见的类型判断：`iscolor()`，`isnumber()`，`isstring()`，`iskeyword()`，`isurl()`；常见的单位量判断：`ispixel()`，`ispercentage()`，`isem()`。 嵌套规则此处的嵌套，指的是对上级重复的派生选择器进行嵌套方式的简写，例如： 12345678910#header &#123; color: black; &#125;#header .navigation &#123; font-size: 12px;&#125;#header .logo &#123; width: 300px; &#125;#header .logo:hover &#123; text-decoration: none;&#125; 可以简写为： 12345678910#header &#123; color: black; .navigation &#123; font-size: 12px; &#125; .logo &#123; width: 300px; &amp;:hover: text-decoration: none; &#125;&#125; 这里需要注意的是，对于:hover和:focus这样的伪类等，需要使用串联选择器而非后代选择器时（串联选择器之间无空格，后代选择器有）应该使用&amp;符号置于前面： 12345678.bordered &#123; &amp;.float &#123; float: left; &#125; /*输出的是.bordered.float选择器*/ .top &#123; margin: 5px; &#125; /*输出的是.bordered .top选择器*/&#125; 运算数字、颜色或者变量都可以参与运算，且支持并向下兼容带有单位的数值： 12345678@base: 5%;@filler: @base * 2; /*返回10%*/@other: @base + @filler; /*返回15%*/color: #888 / 4;background-color: @base-color + #111;height: 100% / 2 + @filler;@var: 1px + 5; /*输出结果是6px*/width: (@var + 5) * 2; 函数LESS中提供了非常丰富且方便使用的函数，包括有color函数、字符串函数、数学函数等等，下面主要介绍一下color函数，其余的函数可以在官方的API中查询使用^1 Color函数LESS提供的颜色运算函数，本质是先把RGB格式转化成HSL（就是色调、饱和度和亮度三维空间）色彩空间，然后再通道级别进行操作： 123456789101112131415161718hue(@color); /* 返回该颜色的hue通道值 */saturation(@color); /* 返回该颜色的饱和度值 */lightness(@color); /* 返回颜色的亮度值 */lighten(@color, 10%); /* 颜色亮度提高10% */darken(@color, 10%); /* 颜色亮度降低10% */saturate(@color, 10%); /* 颜色饱和度提高10% */desaturate(@color, 10%); /* 颜色饱和度降低10% */fadein(@color, 10%); /* 颜色透明度降低10% */fadeout(@color, 10%); /* 颜色透明度提高10% */fade(@color, 50%); /* 颜色透明度变为50% */spin(@color, 10); /* 在色轮上顺时针旋转10°spin(@color, -10); /* 在色轮上逆时针旋转10°mix(@color1, @color2); /* 两种颜色的混色 命名空间为了对CSS进行更好的封装，可以将一些变量或混合模式打包起来，如： 123456789101112131415#bundle &#123; .button () &#123; display: block; border: 1px solid black; background-color: grey; &amp;:hover &#123; background-color: white &#125; &#125; .tab &#123; ... &#125; .citation &#123; ... &#125;&#125;/* 使用&gt;符号来进行引入 */#header a &#123; color: orange; #bundle &gt; .button;&#125; 作用域LESS中的作用域类似于JS中原型链，首先会从本地查找变量或者混合模块，如果没找到的话会去父级作用域中查找，直到找到为止. importing可以通过@import “less-file-name.less”，其中.less的后缀是可选的。 字符串插值变量可以通过使用@{someName}的方式来将变量放入字符串中，例如： 12@base-url: \"http://assets.fnord.com\";background-image: url(\"@&#123;base-url&#125;/images/bg.png\"); 避免编译当我们需要让一些语句失去作用，避免编译这些语句时，可以在语句字符串前面加上~，例如： 123.class &#123; filter: ~\"ms:alwaysHasItsOwnSyntax.For.Stuff()\";&#125; 在LESS中使用JavaScript通过反单引号``的形式包围： 12@str: \"hello\";@var: ~`\"@&#123;str&#125;\".toUpperCase() + '!'`;","categories":[{"name":"Document","slug":"Document","permalink":"http://keefe.wang/categories/Document/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://keefe.wang/tags/基础知识/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://keefe.wang/tags/读书笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://keefe.wang/tags/JavaScript/"}]},{"title":"使用Leaflet插件在浏览器加载地图","slug":"2017-06-12-using-leaflet-to-load-map","date":"2017-06-12T04:00:00.000Z","updated":"2017-10-09T07:13:05.000Z","comments":true,"path":"2017/06/12/2017-06-12-using-leaflet-to-load-map.html","link":"","permalink":"http://keefe.wang/2017/06/12/2017-06-12-using-leaflet-to-load-map.html","excerpt":"在公司实习的第一个项目就与地图和数据可视化相关，这让从来没有接触过地图API、加载工具以及相关开发的我一开始都有些手足无措。之后技术路线慢慢定下来，在浏览器中加载腾讯地图的瓦片地图，并在该地图上添加热力图等可视化图表。 在经过一番简单的调研之后，在浏览器加载地图无非是采用相应地图公司开发的JavaScript API，或者加载在线/离线瓦片地图。后者由于要使用第三方的插件或者自己开发的工具进行加载，所以实现起来较为复杂，而前者实现起来就比较傻瓜了。本文中主要使用腾讯地图作为实例使用地图，同时也会简单提及其他公司开发的地图。","text":"在公司实习的第一个项目就与地图和数据可视化相关，这让从来没有接触过地图API、加载工具以及相关开发的我一开始都有些手足无措。之后技术路线慢慢定下来，在浏览器中加载腾讯地图的瓦片地图，并在该地图上添加热力图等可视化图表。 在经过一番简单的调研之后，在浏览器加载地图无非是采用相应地图公司开发的JavaScript API，或者加载在线/离线瓦片地图。后者由于要使用第三方的插件或者自己开发的工具进行加载，所以实现起来较为复杂，而前者实现起来就比较傻瓜了。本文中主要使用腾讯地图作为实例使用地图，同时也会简单提及其他公司开发的地图。 使用JavaScript API加载腾讯地图使用JavaScript API在浏览器加载腾讯地图，方式非常简单，最重要就是在页面中加载相应的API的js文件，并初始化地图组件即可： 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt; &lt;title&gt;简单地图&lt;/title&gt; &lt;style type=\"text/css\"&gt; #container&#123; min-width:600px; min-height:767px; &#125; &lt;/style&gt; &lt;script charset=\"utf-8\" src=\"http://map.qq.com/api/js?v=2.exp\"&gt;&lt;/script&gt; &lt;script&gt; window.onload = function()&#123; function init() &#123; //初始化地图函数，自定义函数名init //定义map变量，调用qq.maps.Map()构造函数，获取地图显示容器 var map = new qq.maps.Map(document.getElementById(\"container\"), &#123; // 地图的中心地理坐标： center: new qq.maps.LatLng(39.916527,116.397128), zoom:8 &#125;); &#125; //调用初始化函数地图 init(); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--定义地图显示容器--&gt; &lt;div id=\"container\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 瓦片地图目前的流行的互联网瓦片地图种类有两种，一种是栅格地图瓦片，另一种是矢量地图瓦片。 栅格地图瓦片较为传统，是将矢量数据渲染成为256×256像素大小的图片，例如百度地图、高德地图、天地图和腾讯地图等，这些地图可以使用leaflet框架进行瓦片的加载。矢量地图瓦片是以json格式分块传输，在浏览器端利用前端框架将地图展示出来，mapbox和腾讯地图中的3D地图就是矢量地图瓦片，支持三维旋转等。 使用leaflet.js各个地图公司的产品本身拥有还比较完善的API和相关的插件和工具，比如除了地图加载之外的标志叠加、热力图叠加等。但是地图瓦片的加载目前比较流行和完善的工具就是leaflet.js工具,它通过下载特定地图产品的瓦片（一般是256x256px大小），将相应的x、y坐标对应起来，展示在html文档的容器中。之前在网上搜资料，腾讯地图瓦片的资料也是凤毛麟角，跟公司地图部门的同学了解之后便开始了这个地图应用的开发。下面就用leaflet工具加载腾讯地图瓦片作为例子来展示如何进行地图瓦片的操作。 废话不多说，先上代码： 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt; &lt;title&gt;简单地图&lt;/title&gt; &lt;style type=\"text/css\"&gt; #container&#123; min-width:600px; min-height:767px; &#125; &lt;/style&gt; &lt;script charset=\"utf-8\" src=\"\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--定义地图显示容器--&gt; &lt;div id=\"mapid\"&gt;&lt;/div&gt; &lt;script&gt; var mymap = L.map('mapid').setView([39.90469, 116.40717], 12); L.tileLayer('https://rt&#123;s&#125;.map.gtimg.com/realtimerender?z=&#123;z&#125;&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;type=vector&amp;style=0', &#123; subdomains: [\"0\",\"1\",\"2\",\"3\"], tms: true, maxZoom:18, minZoom:1, detectRetina: true, attribution: '&amp;copy 滴滴出行' &#125;).addTo(mymap); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上面代码中展示的就是在div容器中加载地图瓦片的实例，其中，最重要的就是腾讯地图瓦片的下载地址https://rt{s}.map.gtimg.com/realtimerender?z={z}&amp;x={x}&amp;y={y}&amp;type=vector&amp;style=0，其中{s}是指subdomains，是地图瓦片的集群编号，可以传入字符串或数组，此处我们传入的是[“0”, “1”, “2”, “3”]；其次是{x}、{y}、{z}三个参数分别指的是瓦片的横坐标、纵坐标以及缩放等级。地图实例通过L.map(容器ID)来进行声明，通过L.tileLayer().addTo(地图实例)方法来进行加载，该方法中需要传入一个地图瓦片URL和一个参数对象作为参数。其中参数对象中的参数配置可以参考leaflet官网的文档进行配置。 地图加载完毕之后，可以在加载好的地图图层上继续添加所需要的标志、热力图等等。我们这里展示leaflet工具自带的热力图加载方法： 123456789101112L.heatLayer(data,&#123; minOpacity: 0.6, maxZoom: 18, max: 500, radius: 12, blur: 0, gradient: &#123; 1: '#00ffe4', 0.7: '#0078ff', 0.5:'#4285ff' &#125;&#125;).addTo(mymap); 同样是在一样的容器里添加图层，参数有热力数据和参数对象两个，其中热力数据的数据结构是[纬度, 经度, 热度]该热力图可以通过设置透明度（minOpacity）、渐变色（gradient）、扩展度（blur）来改变热力图的样式。 在本文最基础的使用leaflet工具来加载腾讯地图瓦片之后，相信会接触更多有关地图网页应用的项目，之后也会不断地更新地图相关技术博客文章。","categories":[{"name":"Toolkit","slug":"Toolkit","permalink":"http://keefe.wang/categories/Toolkit/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://keefe.wang/tags/JavaScript/"},{"name":"Leaflet","slug":"Leaflet","permalink":"http://keefe.wang/tags/Leaflet/"},{"name":"Map","slug":"Map","permalink":"http://keefe.wang/tags/Map/"},{"name":"腾讯地图","slug":"腾讯地图","permalink":"http://keefe.wang/tags/腾讯地图/"}]},{"title":"JavaScript高级程序设计笔记整理","slug":"2017-05-08-JavaScript-Professional-JavaScript-for-Web-Developer-notebook","date":"2017-05-09T04:00:00.000Z","updated":"2017-10-09T09:15:53.000Z","comments":true,"path":"2017/05/09/2017-05-08-JavaScript-Professional-JavaScript-for-Web-Developer-notebook.html","link":"","permalink":"http://keefe.wang/2017/05/09/2017-05-08-JavaScript-Professional-JavaScript-for-Web-Developer-notebook.html","excerpt":"第三章 基本概念语法： 区分大小写：ECMAScript中的一切都区分大小写 标识符：变量、函数、属性、函数参数等的名字，由字母，下划线，一个美元符号开头 注释：//单行注释，/ /多行注释（尽量少用该种注释方法） 严格模式：在脚本顶部或者某函数内顶部添加”use strict”,支持IE10+,Firefox4+，Safari5.1+，Opera12+，Chrome；","text":"第三章 基本概念语法： 区分大小写：ECMAScript中的一切都区分大小写 标识符：变量、函数、属性、函数参数等的名字，由字母，下划线，一个美元符号开头 注释：//单行注释，/ /多行注释（尽量少用该种注释方法） 严格模式：在脚本顶部或者某函数内顶部添加”use strict”,支持IE10+,Firefox4+，Safari5.1+，Opera12+，Chrome； 语句由分号结尾，多条语句以花括号包围形成代码块，有以下几种语句类型： if 语句：与Java中的条件判断语句语法相同 do-while 语句：相同条件下会比while循环语句少执行一次 while 语句：与Java中的条件判断语句语法相同 for 语句：与Java中的条件判断语句语法相同 for-in 语句：支持任何有迭代属性的对象（Object、Array、Set、Map等）进行枚举循环操作 label 语句：添加标签一般与循环语句配合使用，使用break或continue语句引用 1234567891011var temp=0; start: for(var i=0; i&lt;5; i++) &#123; for(var m=0; m&lt;5; m++) &#123; if(m==1) &#123; break start; //输出1，若去掉start将输出5 &#125; temp++; &#125; &#125; alert(temp); break 和 continue 语句：后面可引用label with 语句：将代码作用域设置到一个特定对象中，避免多次编写同一个对象的工作 12345with(someObject) &#123; var qs = search.substring(1); //如果没有使用with语句，这个表达式应该是var qs = someObject.search.substring(1); var hostName = hostname; var url = href;&#125; switch 语句:与Java中的条件判断语句语法相同，注意使用break语句 数据类型和变量 关键字和保留字：表达式和代码块中出现关键字和保留字一定要留意是否可用 变量： ECMAScript中变量为松散类型，var定义局部变量，可以不赋值（此时为undefined类型） 无var关键词时定义的是全局变量（但是严格模式下会抛出错误） 数据类型：由typeof操作符可以显示给定变量的数据类型，有Undefined、Boolean、String、Number、Object（Array、Null）、Function六中数据类型； Undefined：未声量变量使用typeof操作符时显示undefined，而且对未声明变量使用alert()方法会报错； Boolean：true&amp;false，注意各种数据类型对应boolean值得转换规则； Number：八进制0开头，十六进制0x开头；NaN不等于任何值（包括NaN本身）；非数值转换为数值的三个函数：number(),parseInt(“10”,进制基数)，parseFloat()；数值转换（true:1，false:0，null:0，undefined:NaN）；字符串转换规则（只包含有效数字转化为非0开头数值，空字符串转化为0，字符串包含除有效数字之外的转换为NaN）； String：字符串不可变，改变时会将原来的变量值销毁再重新赋值；数值、布尔值、对象和字符串值都有toString()方法； Object：都有Constructor、hasOwnproperty(propertyName)、isPrototypeOf(object)、propertyIsEnumerable(propertyName)、toLocaleString()、toString()、valueOf(); Null：对值为null的变量使用typeof时返回object，因为null表示一个空对象指针；null==undefined总是返回true； 操作符： 一元：++、–、+、-、~位、!逻辑、 二元：&amp;位、|位、^、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;、&amp;&amp;逻辑、||逻辑、+、-、*、/、%、&gt;、&lt;、&gt;=、&lt;=、==、!=、===、!==、 三元：boolean_expression？true_value:false_value; 赋值：=、+=、-=、*=、/=、%=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;= 运算符优先级：.、[]、()先于delete、new、typeof、+（一元）、—（一元）、！、~先于*、/、%先于+、-先于&gt;=、&lt;=、&gt;、&lt;先于===、!==先于&amp;&amp;先于||先于?: 函数：使用function关键词声明函数，参数类似数组并可省略，参数（和js中的基本类型）都是传值而非传引用（例如string对象）；名字相同的函数只有后定义的函数可以使用； 第四章 变量、作用域和内存问题基本类型和引用类型： 除Object之外的基本类型都是按值访问，对象则是通过访问内存中对象的引用； 基本类型无法添加和改变属性； 复制基本类型值会产生一个独立副本，而复制引用类型值时两者是指向同一个对象的指针； 检测基本类型值时使用typeof，检测引用类型值 时使用instanceof。另外，除了instanceof之外还可以使用return somevar.proto.constructor==sometype或者Object.prototype.toString.call(somevar)。 执行环境和作用域： 局部执行环境（某个函数、let绑定代码块等）：某个执行环境中的所有代码执行完后，该环境被销毁，其中的所有变量和函数定义也随之消失； 全局执行环境：Web浏览器中，全局执行环境被认为是window对象； 每个函数也都有自己的执行环境，执行流（ECMAScript）进入函数，该函数环境被推入一个环境栈； 代码在一个环境中执行，会创建一个作用域链，用途是保证对执行环境有权访问的所有变量和函数有序访问； 延长作用域链：try-catch语句中的catch以及with语句 js中 没有块级作用域（任何花括号中的代码块），例如在if和for中的变量可以在if和for之外访问： 声明变量：使用var声明的变量自动被添加到最接近的环境中，没有用var声明会被添加到全局环境； 查询标识符：某环境中出现一个标识符时，要通过搜索确定该标识符代表什么，从作用域链前端开始，向上逐级查询，匹配到的第一个停止搜索，变量就绪；若全局中都没找到，则算未声明； 垃圾回收：js具有自动垃圾收集机制 标记清除：变量进入某环境，标记该变量，离开环境时进行离开标记，释放内存； 引用计数：声明某变量并将引用类型值赋给该变量，该值引用次数为1，每被赋给一次就加1；若包含对这个值引用的变量取得另外一个值，则减1，该值变成0时就释放内存空间； 管理内存：为了占用最少内存达到更好性能，要将不再使用的变量赋值为null来释放其引用； 第五章 引用类型Object类型 创建对象时首选字面量创建方法： 12345var person = &#123; \"name\" : \"Nicholas\", \"age\" : 29, 5 : true&#125;; Array类型 定义：var color = new Array(3); 访问：采用数组下标[]的方式进行访问，使用.length得到数组长度； 检测：value instanceof Array(不推荐),Array.isArray(somearrayvalue)(推荐)； 转换：toLocaleString()/toString()/valueOf(),均生成 逗号分隔 的字符串其中，toLocaleString()方法转换时每一项都是使用toLocaleString()转换的，toString()也是Array.join(someJointSymbol)，默认用逗号连接； 插入/删除：除了直接用下标添加删除，最好用栈方法LIFO-push(任意项参数)在尾部增加任意数量参数，pop()删除最后一项；同时还有队列方法FIFO,在栈方法基础上增加shift()可删除第一项，unshift()可以在前端添加任意项； 排序：sort()升序排列（转化为字符串进行比较，数字比较会出错，需要在参数中提供比较函数compare()）；reverse()反转数组顺序； 操作方法 连接：somearray.concat(otherarrays)返回连接所有数组的副本； 删除：somearray.splice(起始位置，删除项数，插入项)-splice(0,2)删除前两项，splice(2,0,”red”,”green”)在当前数组位置2插入两项，splice(2,1,”red”,”green”)删除第二项并插入； 位置方法：获取数组中元素的位置，indexOf()和lastIndexOf(),返回数组下表对应元素，否则返回-1； 迭代方法：有5个迭代方法，参数都是两个，每一项上运行的函数和运行该函数的作用域对象every(someFunction)；对每一项进行函数操作，每一项返回true则最后返回true；filter(someFunction):对每一项运行给定函数，返回每次调用该函数值为true的项的数组forEach(someFunction):对每一项运行给定函数，无返回值map(someFunction):对每一项运行给定函数，返回每次调用该函数结果的数组some(someFunction):对每一项运行给定函数，只要有一项使函数返回true，则整个返回true； 缩小方法：reduce(给每项调用的函数(可选)，缩小基础初始值)/reduceRight(给每项调用的函数(可选)，缩小基础初始值)，其中，参数中的函数需要传入4个参数，分别是前一项，当前项，项索引，数组对象；reduceRight是相反方向； 禁忌：[， ， ， ，]不可以出现数组最后一项是，的情况 Date类型 定义：`var now = new Date(); 特定时间：var someDate = new Date(Date.parse(“May 25, 2004”));但是不用date.parse也会默认转换； 继承的方法 toLocaleString()按照与浏览器设置的地区相适应的格式返回日期和时间 toString()返回带有时区信息的日期和时间 valueOf()返回日期的毫秒表示 日期格式化方法 toDateString():以特定于实现的格式返回日年月日星期 toTimeString():以特定于实现的格式返回时区、时分秒 toLocaleDateString():以特定于地区的格式返回年月日星期 toLocaleTimeString():以特定于实现的格式显示时分秒 toUTCString():以特定于实现的格式完整的UTC日期 日期时间组件方法￼ ￼ RegExp类型： 定义： 12var pattern = new RegExp(“pattern”, “flags”);var expression = /pattern/ flags; 其中flags有一下几种模式： g:全剧模式，模式应用于所有字符串而非在发现第一个匹配项时立即停止； i:不区分大小写模式； m:多行模式，到达一行末尾还会查找下一行是否有匹配项 元字符转义：( { [ \\ ^ $ | ) ? + . ] } e.g.匹配第一个”[bc]at”:var patter = /\\[bc\\]at/i; 实例属性 .global:bool是否设置g标志 .ignoreCase:bool是否设置了i标志 .lastIndex:整数，表示开始搜索下一个匹配项的自负位置，0算起 .multiline:bool，表示是否设置了m标志 .source:该正则的字符串表示 实例方法：.exec() 构造函数属性： 模式的局限性： Function类型函数是对象，因此函数名实际上也是一个指向函数对象的指针，可以使用多个指针指向同一个函数。 声明： 123function sum(num1, num2)&#123; return num1 + num2;&#125; 特征 没有重载:因为JS中的函数名就像指针一样，所以当为一个函数名（就是一个变量）赋予新的函数时，会覆盖之前的函数； 声明位置和表达式: JS中有函数声明提升过程，所以声明和调用不强调先后顺序。但是！如果把函数放进一个初始化语句中而非函数声明时,会出现先后问题的错误； 作为值的函数:函数名可作为变量像值一样传入另一个函数；函数内也可以返回一个函数的计算结果等等； 函数属性和方法: 函数作为对象有两个属性: length（表示函数希望接受的命名参数的个数） prototype（保存引用类型的所有实例的方法，是不可枚举的） 函数作为对象有两个方法: apply()：接受两个参数，一个是其中运行函数的作用域，另一个是参数数组（可以使arguments对象或者是真实的一个数组） call()：接受this参数以及来自函数的每一个参数都要写进去而非传入数组），这两个函数都是在特定的作用域中调用函数，相当于设置函数体内this对象的值 函数内部对象及环境的属性 两个特殊对象 arguments：包含传入函数的所有参数，并且有一个callee的属性指向拥有这个arguments对象的函数，其实就是这个函数，另一个caller的属性返回引用本函数的函数 this：引用的是函数执行的环境对象，网页的全局就是window 基本包装类型String、Boolean、Number（Object、Null、Undefined、Array） String： 方法： 下标相关 所指的单字符串charAt() 所指字符的编码charCodeAte() 字符串位置indexOf(substr) 最后一个字符串位置lastIndexOf(substr) 字符串操作 连接concat(String str1, String str2) 截取slice(startPos(, endPos)) 截取substr(startPos(, length)) 截取substring(startPos(, endPos))，当输入负数的index时，slice将负数和字符串长度相加，substr将第一个负参数加字符串长度第二个负参数转换为0，substring将所有负参数转化为0； 格式化字符串方法trim(string)创建一个副本并删除前后所有空格 大小写相关 转小写toLowerCase() 转本地语言toLocaleLowerCase() toUpperCase() toLocaleUpperCase() 字符串模式匹配方法match()详见正则表达式，search()返回第一个匹配项索引否则返回-1 replace(新字符串，需要替换的字符串) split(simbol)，由simbol分隔字符串，返回一个字符串数组 string1.localeCompare(string2)返回：string1在string2之前-1，相等0，之后1 fromCharCode()静态方法，接收一或多个字符编码，然后转换成一个字符串 单体内置对象 Global对象 在js中，不属于任何其他对象的属性和方法，都是它的属性和方法。所有在全局作用域中定义的属性和函数都是它的属性和函数。例如isNaN()/isFinite()/parseInt()/parseFloat()/encodeURI()只编码空格/encodeURIComponet()编码所有非字母数字字符/decodeURI()/decodeURICompoment()/eval()接收一个js语句字符串，若是函数则不会被提升，需要按照声明顺序进行调用，严格模式下外部不能访问该函数中的函数或变量 第六章 面向对象的程序设计对象就是无序属性的集合，其属性可以包含基本值、对象或者函数。创建对象的基础方法： 创建Object实例： 123456var person = new Object();person.name = \"Nicholas\";person.age = 29;person.sayName = function()&#123; alert(\"this.name\")&#125; 对象字面量语法： 1234567var person = &#123; person.name = \"Nicholas\"; person.age = 29; person.sayName = function()&#123; alert(\"this.name\") &#125;&#125; 理解对象 属性类型： ECMAScript中有两种属性：数据属性 和 访问器属性。 数据属性：包含一个数据值的位置，在此位置可读取和写入值，有以下特性： [[Configurable]]默认值为true，表示能否通过delete删除属性 [[Enumerable]]默认值为true，表示能否通过for-in循环返回属性 [[Writable]]默认值为true，表示能否修改属性的值 [[Value]]默认值为undefined，包含这个属性的数据值 要修改上述属性，必须通过Object.defineProperty(属性所在对象，属性名，描述符对象)方法： 12345var person = &#123;&#125;;Object.defineProperty(person, \"name\", &#123; writable: false, value: \"Nicholas\"&#125;) 访问器属性：不包含数据值，只包含getter和setter函数（这两个函数并非必需），访问器属性具有如下特征： [[Configurable]]默认值为true，表示能否通过delete删除属性 [[Enumerable]]默认值为true，表示能否通过for-in循环返回属性 [[Get]]默认值为undefined，读取属性时调用的函数 [[Set]]默认值为undefined，写入属性时调用的函数 访问器属性也必须使用Object.defineProperty()方法来进行定义： 12345678910111213141516171819202122232425262728293031323334353637var book = &#123; _year: 2004, edition: 1&#125;;Object.defineProperty(book, \"year\", &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if(newValue &gt; 2004)&#123; this._year = newValue; this.edition = newValue - 2004; &#125; &#125;&#125;);//若想定义多个属性或对应的方法时，可以这样写：Object.defineProperty(book, &#123; //这里定义了两个数据属性 _year: &#123; value: 2004 &#125;, edition: &#123; value: 1 &#125;, //这里定义了一个访问器属性 year: &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if(newValue &gt; 2004)&#123; this._year = newValue; this.edition = newValue - 2004; &#125; &#125; &#125;&#125;); * 如果想读取属性的特征，则要通过Object.getOwnPropertyDescriptor()函数来访问： 123var descriptor = Object.getOwnPropertyDescriptor(book, \"_year\");alert(descriptor.value);alert(typeof descriptor.get); //\"function\" 创建对象创建类和对象名要使用大写字母开头，构造函数也是，而非构造函数则由小写字母开头。 工厂模式：抽象了创建具体对象的过程，用函数来封装以特定接口创建对象的细节： 1234567891011function createPerson(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o;&#125;var person1 = createPerson(\"Nicholas\", 29, \"Software Engineer\"); 其实就是把一个完整的由Object实例来创建对象的过程放在一个函数中； 构造函数模式： 123456789function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; alert(this.name); &#125;;&#125;var person1 = new Person(\"Nicholas\", 29, \"Software Engineer\"); 可以看到，构造函数模式中 没有显式地创建对象，直接将属性和方法赋给了this对象，没有return语句 。 构造函数模式相较于工厂模式的一个优点是，它创建的构造函数可以将它的实例标识为一种特定的类型，即对象也是Object也是Person的实例。 将构造函数当做函数： 任何函数，只要通过new操作符来调用，就可以作为构造函数。 原型模式 JavaScript中并没有提供类的实现，虽然在ES2015/ES6之中引入了class关键字，但是JavaScript仍然是基于原型的。而JavaScript中创建对象的方法有：new Object()方法、字面量方法、工厂模式、构造函数方法和原型模式。其中，使用原型模式创建对象可以令所有实例共享方法，减少内存消耗，有利于对象继承。 JavaScript中的继承则是体现在一种结构上——对象，所有的对象都是由Object衍生的对象，所有的对象都继承了Object.prototype的方法和属性（也有可能被覆盖）。每一个对象都有一个内部链接到另一个对象，这个对象成为它的原型（prototype）。而且，该原型对象也有自己的原型，直到追溯到一个以null为原型的对象，因为null是没有原型的，所以可以作为这个原型链（prototype chain) 中的最终链接。 只要创建了一个新函数，就会为该函数创建一个prototype属性，这个属性指向函数的原型对象。所有原型对象都自动获得一个constructor属性，这个属性包含一个指向prototype属性所在函数的指针。 原型对象的创建： 1234567891011121314function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job;&#125;Person.prototype.sayName = function() &#123; alert(this.name);&#125;;var person1 = new Person(\"Nicholas\", 29, \"Lawyer\");var person2 = new Person(\"Katie\", 30 \"Account\");var person3 = new Person(\"Nicholas\", 29, \"Lawyer\");person1.sayName(); //\"Nicholas\"person2.sayName(); //\"Katie\"alert(person1.sayName == person3.sayName); //true 更加简单的原型对象创建语法： 12345678910function Person() &#123;&#125;Person.prototype = &#123; name : \"Nicholas\", age : 29, job : \"Software Engineer\", sayName : function() &#123; alert(this.name) &#125;&#125;; 寄生构造函数模式 与工厂模式没有本质上的区别，只是在创建新的实例的时候，工厂模式不需要new，而寄生构造函数需要加new。这种模式不能够以来instanceof操作符来确定对象类型，所以建议在能够使用其他模式创建对象时尽量不要使用这种模式。 稳妥构造函数模式 JavaScript中的稳妥对象是指，没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些禁止使用this和new的安全环境中使用，防止被Mashup等的应用程序改动。 稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建的对象的实例方法不引用this；二是不适用new操作符调用构造函数。 1234567function Person(name, age, job) &#123; var o = new Object(); o.sayName = function() &#123; alert(name); &#125;; return o;&#125; 继承原型链 代码搜索某属性的路径（原型链）： 上面代码中出现了Person.prototype,通过该形式可以获得原型对象，并且可以为其添加属性和方法。这段代码也展示了对象属性和方法搜索的路径：每当代码读取某个对象的某个属性时，进行目标为该属性的名字，搜索首先从实例（person1）本身开始，若有该名字的属性则返回该属性，若没有则继续搜索该实例中原型指针指向的原型对象，在原型对象中查找该名字的属性。所以说实例是共享原型中保存的属性和方法。 实例的属性，原型的属性？ 一个对象的所有实例尽管可以共享该原型对象的所有属性和方法，但是却无法重写原型对象中的属性和方法，只能通过利用同名属性和方法来覆盖和屏蔽原型对象中的属性和方法；若想把实例中覆盖的属性还原，可以通过delete操作。使用hasOwnProperty()方法可以检测一个属性是存在于实例中还是存在于原型中。 怎样获得原型对象 下面的代码展示了Object.getPrototypeOf(obj)方法和proto属性的使用： 12Object.getPrototypeOf(person1) === Person.prototype; //trueperson1.__proto__ === Person.prototype; //true 可以看到，Object.getPrototypeOf(obj)是获取obj对象的原型对象的方法，这个方法将在利用原型实现继承的情况中发挥非常重要的作用。obj.proto 也是如此，是每一个对象都拥有的属性，但是proto并不是一个规范的属性（当使用Object.create()方法创建对象时，proto 并不能指向该对象的原型对象），其对应的标准属性应当是[[Prototype]]。 原型对象和构造函数 对于对象Person来说，它的构造函数是Person()，它的原型对象为Person.prototype；而Person.prototype.constructor又会指回Person。而对象Person的实例person1和person2都包含有一个属性[[Prototype]]（也就是上面提到的proto）它们都指向Person.prototype；同时，person1和person2也可以通过isprototypeOf(）方法来确定是否与确定对象之间有这种关系： 1alert(Person.prototype.isPrototypeOf(person1)); //true 原型与in操作符 in操作符单独使用的情况 in操作符单独使用会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是在原型中： 1234//接上面的代码var person4 = new Person();alert(person4.hasOwnproperty(\"name\")); //由于person4实例没有覆盖原型中的name所以返回falsealert(\"name\" in person4); //true for-in循环 该种方式是返回所有能够通过对象访问的、可枚举的属性，包括实例和原型中的属性，并且屏蔽了原型中不可枚举（[[Enumerable]]）的属性（仅在IE8及更早版本中有不可枚举的属性）： 12345678910var o = &#123; toString : function() &#123; return \"my Object\" &#125;&#125;for (var prop in o) &#123; if (prop == \"toString\") &#123; alert(\"Found toString\"); //IE中无法显示 &#125;&#125; 若想获取对象中所有可枚举的实例属性，可以使用Object.keys(),该函数接受一个对象或实例作为参数（当然也可以是原型对象），返回一个包含所有可枚举属性的字符串数组。示例代码如下： 123456789//接Person对象代码var keys = Object.keys(person.prototype);var person5 = new Person();person5.name = \"Rob\";person5.age = 31;alert(keys);alert(Object.keys(person5));var keys2 = Object.getOwnPropertyNames(Person.prototype); alert(keys2); 上述代码中出现的Object.getOwnPropertyNames(Person.prototype)方法可以得到所有的可枚举/不可枚举的实例属性（列入constructor）。 原型的动态性由于从原型中查找值的过程试一次搜索，因此对原型对象所做的任何修改都能从实例上反映出来。即，可以先创建实例，再修改原型对象中的属性或函数，实例依旧可以访问该属性和函数： 123456//接person对象代码var friend = new Person();Person.prototype.sayHi = function() &#123; alert(\"hi!\");&#125;;friend.sayHi(); //返回”hi” 尽管像以上代码中所看到的可以为原型添加属性或方法，但是如果重写整个原型对象，就会切断实例的构造函数与最初原型对象之间的联系。这是因为实例中的指针仅指向原型，而非构造函数。 原生对象的原型不仅是自定义的对象，JavaScript中所有原生的引用类型，都是采用这种模式创建的原生对象。通过原生对象的原型可以取得所有默认方法的引用，也可以自己添加新的方法。 原型对象的缺点 由于原型中所有属性都是可以被实例共享，而对于原型中含有引用类型值的属性来说就会发生问题： 123456//接person对象代码Person.prototype.friends = [\"Shelby\", \"Court\"];var person6 = new Person();person6.friends.push(\"Van\");alert(person6.friends);alert(person1.friends); //此时两个Person的实例拥有相同的朋友，很可能发生错误 可以看到，由于原型的属性可以被共享的这一特性，原型对象中包含的引用类型值很可能被修改之后导致实例的属性也发生错误，必须要在实例属性中覆盖才可以。所以为了解决这个问题，提出了以下组合构造函数模式和原型模式的方法来创建对象： 123456789101112131415//改写上面的Person对象//首先使用构造函数模式创建对象Person并加入容易被修改的属性name，age，jobfunction Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.friends = [\"Shelby\", \"Court\"];&#125;//再使用原型模式创建构造函数和不容易被修改的属性和函数，这样可以发挥原型的共享机制并减少内存消耗Person.prototype = &#123; constructor : Person, sayName : function() &#123; alert(this.name); &#125;&#125; 第七章 函数表达式函数的定义有两种方法：一种是函数声明，另一种是函数表达式 。 函数声明： 123function functionName(arg0, arg1, arg2) &#123; //函数体\\&#125; Firefox、Safari、Chrome和Opera都给函数定义了一个非标准的name属性，可以访问到给函数指定的名字alert(functionName.name);同时我们还需要注意的是，函数有函数声明提升的重要特征，所以函数声明可以放在函数调用语句之后。 函数表达式： 123var functionName = function(arg0, arg1, arg2) &#123; //函数体&#125;; 这种情况下创建的函数叫做匿名函数f，所以函数的name属性是空字符串，而且根据赋值语句的特性，调用一定要在函数赋值语句之后。既然函数可以赋值给变量，同时函数也可以作为其他函数的返回值。 递归 概念 递归函数是在一个函数通过名字调用自身的情况下构成的。 1234567function factorial(num) &#123; if (num &lt;= 1) &#123; return 1; &#125;else&#123; return num * factorial(num - 1); &#125;&#125; 这是一个经典递归阶乘函数，但是存在以下的问题： 123var anotherFactorial = factorial;factorial = null;alert(anotherFactorial(4)); //出错 上面调用出错的原因是，当factorial的引用被替换之后，在anotherFactorial调用时还是会用到factorial，这时候就会发生错误。这种情况可以使用arguments.callee可以解决这个问题。 arguments.callee是一个指向正在执行的函数的指针。所以用这个指针对递归调用能够解决这个问题，例如： 1234567function factorial(num) &#123; if(num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num - 1); &#125;&#125; 如果是严格模式下，callee模式会导致错误，最好使用命名函数表达式来达到相同的目的： 1234567var factorial = (function f(num) &#123; if(num &lt;= 1) &#123; return 1; &#125; else &#123; return num * f(num - 1); &#125;&#125;); 闭包 概念：闭包是指有权访问另一个函数作用域中的变量的函数。 创建闭包：常见方式是在一个函数内部创建另一个函数。 理解闭包 要理解闭包的细节，必须理解如何创建作用域链以及作用域链的作用以及理解函数第一次被调用的时候发生了什么。 当某函数第一次被调用时，会创建一个执行环境以及相应的作用域链，并把作用域链赋值给一个特殊的内部属性（[[Scope]])，然后可以使用this、arguments和其他命名参数的值来初始化函数的活动对象。在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数活动对象处于第三位，直至作为作用域链重点的全局执行环境。 所以说，当函数执行完毕之后，据不活动对象（this、arguments）就会被销毁，内存中也仅保存全局作用域。而引入闭包之后情况就会好转： 在另一个函数内部定义的函数会将包含函数（外部函数）的活动对象添加到它的作用域链中。当调用该函数时，函数执行完毕之后，其活动对象也不会被销毁，因为其中的匿名函数的作用域链仍然在引用这个活动对象，除非使用null来销毁该函数解除对匿名函数的引用，释放内存。 闭包与变量 作用域链的机制有一个副作用：闭包只能取得包含函数中任何变量的最后一个值。闭包所保存的是整个变量的对象，而不是某个特殊的变量。 这是因为匿名函数始终都在内存中保存着作用域链中该函数的活动对象，所以其实所有新建的函数都使用着同一个变量。除非在该匿名函数中再写一个匿名函数才能强制让闭包的行为符合预期。 this对象 在闭包中使用this对象也会出现问题：匿名函数的执行环境具有全局性，因此匿名函数的this对象通常指向window（全局变量）。这是因为内部匿名函数在搜索变量时，根据作用域链进行搜索，所以存在在对象属性的变量是无法访问到的（只有函数才有作用域，还是因为外部函数没有显示声明this对象？），内部函数只能找到全局，所以如果想要闭包的函数中访问到外部函数的this对象，必须要将this对象保存在外部函数中。 内存泄漏 IE9之前的版本中，如果闭包的作用域链中保存着一个HTML元素，那么该元素无法被销毁。 避免发生”循环引用“的情况。 模仿块级作用域JavaScript中没有块级作用域的概念，所有的块语句中定义的变量都存在于函数中的作用域。所以以下代码是可以正常访问的： 123456function outputNumbers(count)&#123; for(var i = 0;i &lt; count;i++)&#123; alert(i); &#125; alert(i); //返回count计数&#125; 就算在最后一个alert(i)之前重新定义声明变量i也不会改变i的值。所以JS从来不会提醒是否多次声明了同一个变量，有可能会导致问题的产生。所以这时候需要匿名函数来模仿块级作用域来避免这个问题: 123(function()&#123; //这里就是块级作用域&#125;)(); 以上代码定义并立即调用了一个匿名函数，前一个括号是函数表达式声明，后一个括号是指立即调用这个函数。需要注意的是，函数表达式后面可以跟圆括号，而函数声明后面是不可以加圆括号的。 私有变量JS中没有私有成员的概念，对象属性和函数都是共有的，但是有一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量。所以利用函数的闭包就可以创建用于访问私有变量的公有方法。该方法成为”特权方法”，创建方式有以下两种： 基本模式 12345678910function MyObject()&#123; var privateVariable = 10; function privateFunction()&#123; return false; &#125; this.publicMethod = function()&#123; privateVariable++; return privateFunction(); &#125;;&#125; 静态私有变量在构造函数中定义特权方法也有一个缺点，那就是必须使用构造函数模式来达到该目的，可是构造函数模式的缺点就是每个实例都会创建同样一组新方法。而使用静态私有变量来实现特权方法就可以避免这个问题。 通过在私有作用域中定义私有变量或函数，同样也可以创建特权方法： 123456789101112(function()&#123; var privateVariable = 10; function privateFunction()&#123; return false; &#125; MyObject = function()&#123; &#125;; //严格模式下未经声明的变量赋值会导致错误 MyObject.prototype.publicMethod = function()&#123; privateVariable++; return privateFunction(); &#125;;&#125;)(); 模块模式单例 是指只有一个实例的对象，通常JavaScript是用对象字面量的方式来创建单例对象。 而模块模式正是专门为单例创建私有变量和特权方法的方式： 12345678910111213var singleton = function()&#123; var privateVariaable = 10; function privateFunction()&#123; return false; &#125; return &#123; publicProperty: true, publicMethod: function()&#123; privateVariable++; return privateFunction(); &#125; &#125;;&#125;(); 这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时时非常有用的。单例经常被用在Web应用程序中来管理应用程序级的信息。 另外还有 增强的模块模式 第八章 BOM如果在Web中使用JavaScript，那么BOM才是真正的核心。 window对象BOM的核心对象是window，它表示浏览器的一个实例。在浏览器中，window对象不仅是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象。 全局作用域 在JavaScript中，全局作用域中声明的变量、函数都会变成window对象的属性和方法。然而定义全局变量和在window对象上直接定义属性仍有一点区别：全局变量无法通过delete操作符删除（IE&lt;9抛错，其他浏览器返回false），而window对象上的属性可以。 窗口关系及框架 如果页面中包含frame，则每一个框架都拥有自己的window对象，并保存在frames集合中。 窗口位置 用来确定和修改window对象位置的属性和方法： IE、Safari、Opera和Chrome都提供screenLeft和screenTop属性；Chrome和Safari以及Firefox则支持screenX和screenY属性： 12var leftPos = (typeof window.screenLeft == \"number\") ? window.screenLeft : window.screenX;var topPos = (typeof window.screenTop == \"number\") ? window.screenTop : window.screenY; 上述代码对浏览器进行选择并获取窗口的位置。默认返回左上角原点（0，0）。 通过winow.moveBy(横坐标长度，纵坐标长度)，window.moveTo(横坐标，纵坐标)，可以移动窗口，但是可能会被浏览器禁用。 窗口大小 IE9+/Firefox/Safari/Opera/Chrome均提供4个属性：innerWidth/innerHeight/outerWidth/outerHeight。其中在IE9+/Safari/Firefox中，outerwidth和outerHeight返回浏览器窗口本身吃葱，Opera中则是表示页面视图容器的大小。而innerWidth、innerHeight是表示该容器中页面视图去的大小。Chrome中内外两对属性返回相同值-viewport大小。 另外，还可以使用window.resizeTo(width,height)/window.resizeBy(widthtoformer,lengthtoformer) 导航和打开窗口 window.open()方法可以导航到特定URL或打开新浏览器窗口。 12window.open(\"http://www.wrox.com/\",topFrame,\"someString\",\"1\")//四个参数分别是网站的url、窗口目标（或者_self/_parent/_top/_blank），特性字符串，是否取代当前页面的bool 如果该方法中第二个参数不存在，就会根据在第三个参数为止传入的字符串创建一个新窗口，有“fullscreen=yes、height=100”等参数，该参数字符串中不允许出现空格。该方法可以按照下面的方式赋值给变量并进行一些操作： 123456var wroxWin = window.open(\"http://www.wrox.com/\",\"wroxWindow\",\"height=400,width=400,top=10,left=10,resizable=yes\");alert(wroxWin.opener == window); //truewroxWin.resizeTo(500,500);wroxWin.moveTo(20,20);wroxWin.close;alert(wroxWin.closed); //true 鉴于有很多网站有很多弹窗广告的窗口，所以为了屏蔽这些窗口，网站的代码中可以 间歇调用和超时调用 JS是单线程语言，但是允许通过设置超时值和间歇时间值（毫秒）来调度代码在特定时刻执行。其中，超时值是在指定时间过后执行代码，后者是每隔指定时间就执行一次代码。 12345678setTimeout(function() &#123; alert(\"Hello world!\");&#125;, 1000);//第一个参数可以是字符串格式的代码，但是不推荐使用，会导致性能损失setInterval(function()&#123; alert(\"Hello World!\");&#125;,10000);//每10000毫秒执行一次代码 该方法也可以赋值给变量，然后通过clearTimeout(timeoutVar)/clearinterval(intervalVaar) 系统对话框 浏览器通过alert(),confirm(),prompt()方法可以调用系统对话框向用户显示消息。其中confirm()方法有OK和cancel两个按钮，prompt()会提示用户输入一个参数。另外还有window.print()打印对话框和window.find()查找对话框。 location对象location是最有用的BOM对象之一，提供了与当前窗口中加载的文档有关的信息和导航功能，还将URL解析为独立片段来通过不同属性访问这些片段。 location既是window对象的一个属性，又是document对象的属性，即window.location=document.location。下面是location的所有属性： hash（#contents）、host（www.wrox.com:80）、hostname（www.wrox.com）、href（http://www.wrox.com）、pathname（/WileyCDA）、port（8080）、protocol（http:）、search（?q=javascript）; 查询字符串参数（对search属性进行字符串解析） 位置操作 通过location.assign(&quot;http://www.wrox.com&quot;);可以打开新的URL，与window.location=&quot;http://www.wrox.com&quot;;以及location.href=&quot;http://www.wrox.com&quot;;相同 如果要禁止将页面存入浏览记录（防止后退到前一个页面），可以使用location.replace(URL); navigator对象 检测插件 navigator.plugins是一个数组，其中每一项都包括name, description, filename, length 但是IE中检测插件需要使用ActiveXObject类型： 123456789function hasIEPlugin(name) &#123; try&#123; new ActivXOBject(name); return true; &#125; catch(e) &#123; return false; &#125;&#125;alert(hasIEPlugin(\"shockwaveFlash.ShockwaveFlash\")); 注册处理程序 navigator对象有registerContentHandler()和registerProtocolHandler()方法； registerContentHandler()接受三个参数：要处理的协议（mailto或ftp），处理该协议的页面URL和应用程序的名称： 1navigator.registerProtocolHandler(\"mailto\", \"http://www.somemailclient.com?cmd=%s\", \"Some Mail Client\"); screen对象对于变成来说作用不大，用来标明客户端的能力，包括浏览器窗口外部的显示其信息等； history对象使用history.go()接受参数整数，一个url（跳到最近的该url页面）另外也可以使用history.back()/.forward(); 第九章 客户端检测能力检测目标是识别浏览器的能力， 基本模式如下： 123if(object.propertyInQuestion) &#123; //使用object.propertyInQuestion&#125; 使用方案：先检测达成目的的最常用的特性（提升效率），必须测试实际要用到的特性（判断条件要够详细） 如果是想要判断对象是否有某个属性或者支持某种方法，尽量使用typeof 怪癖（bug）检测目标是识别浏览器的特殊行为。 用户代理检测通过检测用户代理字符串来确定实际使用的浏览器。用户代理字符串作为响应头部发送，也可以通过navigator.userAgent属性访问 用户代理字符串检测技术： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var client = function() &#123; var engine = &#123; ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, ver: null &#125;; var browser = &#123; ie: 0, firefox: 0, safari: 0, konq: 0, opera: 0, chrome: 0, ver: null &#125;; var system = &#123; win: false, mac: false, x11: false， iPhone：false, ipod: false, ipad: false, ios: false, android: false, nokiaN: false, winMobile: false &#125;; //navigator.platFORM //再次检测呈现引擎、平台和设备 var ua = navigator.userAgent; if(window.opera) &#123; engine.ver = window.opera.version(); engine.opera = parseFloat(engine.ver); &#125; else if(/AppleWebKit\\/(\\S+)/.test(ua)) &#123; engine.ver = RegExp[\"$1\"]; engine.webkit = parseFloat(engine.ver); &#125; else if(（/KHTML\\/(\\S+).test(ua)) &#123; engine.ver = RegExp[\"$1\"]; engine.khtml = parseFloat(enging.ver); &#125; else if(/rv:([^\\)]+)\\) Gecho\\/d&#123;8&#125;/.test(ua)) &#123; engine.ver = RegExp[\"$1\"]; engine.gecko = parseFloat(engine.ver); &#125; else if(/MSIE ([^;]+)/.test(ua)) &#123; engine.ver = RegExp[\"$1\"]; engine.ie = parseFloat(engine.ver); &#125; return &#123; engine：engine, browser: browser, system: system &#125;;&#125;(); 可以检测用户代理、浏览器的类型和版本、系统类型和版本、移动设备 第十章 DOM节点层次HTML页面中，文档元素始终都是元素。 节点类型DOM1级定义了Node借口，由DOM中的所有节点类型实现。在JS中作为Node类型实现，除了IE，其他所有浏览器中都可以访问到这个类型。节点类型一共有12种。 使用方法： 123456if(someNode.nodeType == Node.ELEMENT_NODE) &#123; alert(\"Node is an element.\"); //不适用于IE&#125;if(someNode.nodeType == 1) &#123; alert(\"Node is an element.\"); //全部适用&#125; nodeName和nodeValue属性 对于元素节点，nodeName保存元素的标签名，nodeValue中则为null 节点关系 可以使用.childNode[]数组属性、item()方法来访问子节点： 123var firstChild = someNode.childNodes[0];var secondChild = someNode.childNodes.item(1);var count = someNode.childeNodes.length; 可以使用parentNode属性访问父节点，使用previousSibling和nextSibling属性访问兄弟节点，但是列表中第一个节点的previousSibling属性值为null，最后一个节点的nextSibling属性值也为null 可以使用firstChild和lastChild属性访问childNodes列表中第一个和最后一个节点。 操作节点 appendChild()方法新增节点：someNode.appendChild(newNode)，该方法返回新增的节点，若传入的参数节点已经存在，则该方法对该节点进行转移 insertBefore()方法插入特定位置，接受两个参数，一个是要插入的节点，第二个是参照节点 replaceChild()方法替换节点 removeChild()方法移除节点 cloneNode(一个bool参数表示是否执行深复制)、normalize()支持所有类型节点 Document类型JS中通过Document类型表示文档，document对象是HTMLDocument（继承自Document类型）的一个实例，表示整个HTML页面，也是window对象的一个属性。Document节点具有下列特征： nodeType值为9 nodeName的值”document“ parentNode的值为null nodeValue的值为null ownerDocument的值为null 文档的子节点可以通过documentElement属性（始终指向\\元素）和childNodes列表访问文档元素。 可以通过**document.body来访问\\元素，这两个属性所有浏览器均支持； 可以通过**document.doctype访问\\&lt;!DOCTYPE&gt;的引用，但是IE8之前不支持，而其他浏览器这个属性不存在在childNodes中 \\标签之外的注释也算文档的子节点，但是IE8/SAFARI/OPERA/CHROME均只为第一条注释创建节点 文档信息查找元素（最最常用）可以通过getElementById(“”)访问指定元素,ID大小写在IE7之前有要求。如果多个相同ID的元素出现，只返回第一个元素（IE7会在name等于指定id时且在这个id元素之前出现，返回有该name的元素） 可以通过getElementsByTagName(“”)访问指定元素列表，返回HTMLCollection对象，可以使用数组的下标访问，也可以通过item()方法进行访问，也可以通过该对象的namedItem(name)方法返回相同tag元素列表中指定的name元素。 可以通过getElementsByName()访问 特殊集合 document.anchors document.applets document.forms document.images document.links DOM一致性检测文档写入write()/writeln()/open()/close()是document对象的IO功能，这些函数是在加载过程当中写入的，所以加载完再运行write会导致整个页面消失： document.write(&quot;&lt;script type=\\&quot;text/javascript\\&quot; src=\\&quot;file.js\\&quot;&gt;&quot; + &quot;&lt;\\/script&gt;&quot;); Element类型要访问元素的标签名，最好使用tagName属性，但是注意这里tagName返回的是大写！ HTML元素（取得特性） 由HTMLElement类型表示，继承自Element类型，拥有id/title/lang/dir/className等属性 操作特性 操作特性的DOM方法主要有：div.getAttribute(“属性名除了style和onclick”)/div.setAttribute(“属性名”,”属性值”)/div.removeAttribute(“属性名”) attributes属性 创建元素 使用document.createElement()方法创建新元素，只接受一个参数为要创建的标签名 Text类型第十三章 事件事件流事件流描述的是从页面中接收事件的顺序。 事件冒泡 IE的事件流叫做事件冒泡：时间开始时由最具体的元素（嵌套层次最深的那个节点）接收，然后逐级向上传播直到文档根节点（window对象）。所有现代浏览器都支持事件冒泡。 事件捕获 从不太具体的节点开始接收事件，逐级到最具体的节点最后接收到事件。很少使用事件捕获。 DOM事件流 包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。 事件处理程序 HTML事件处理程序 1234&lt;form method=\"post\"&gt; &lt;input type=\"text\" name=\"username\" value=\"\"&gt; &lt;input type=\"button\" value=\"Echo Username\" onclick=\"alert(username.value)\"&gt;&lt;/form&gt; 缺点：如果调用的函数在引用之后定义，页面解析该函数之前就进行了操作会引发错误（时差问题）；不同JS引擎遵循的标识符解析规则略有差异，很可能会在访问非限定对象成员时出错。 DOM0级事件处理程序 1234var btn = document.getElementById(\"myBtn\");btn.onclick = function() &#123; alert(\"Clicked\");&#125; DOM2级事件处理程序 定义了addEventListener()和removeEventListener()用于添加和删除监听器的函数。都接受三个参数：处理事件名，事件处理函数，和一个bool值（该值为true捕获阶段调用，false冒泡阶段调用）。但是add方法添加的程序 只能用remove来删除，所以当add一个匿名函数时就无法被删除。 1234var btn = document.getElementById(\"myBtn\");btn.addEventListener(\"click\", function() &#123; alert(this.id); &#125;, false); 可添加多个事件，按顺序出发。 IE事件处理程序 IE中使用attachEvent()，事件处理程序会在全局作用域中进行，所以函数中出现的this等于window，而DOM0中的函数中出现的this就是局部作用于内运行。也有detachEvent()移除函数，所以道理与DOM2级事件处理程序一样。 1234var btn = document.getElementById(\"myBtn\");btn.attachEvent(\"onclick\", function() &#123; alert(\"Clicked\"); &#125;); 跨浏览器的事件处理程序 创建addHandler()方法，接受三个参数：要操作的元素、事件名称和事件处理程序函数；目的是判断情况应该使用DOM0/DOM2/IE的哪种方法，该方法属于EventUtil对象。 事件对象 DOM中的事件对象 兼容DOM的浏览器会将一个event对象传入到事件处理程序中。 1234567var btn = document.getElementById(\"myBtn\");btn.onclick = function(event) &#123; alert(event.type); //\"click\"&#125;;btn.addEventListener(\"click\", function(event) &#123; alert(event.type); //\"click\" &#125;, false) 事件处理程序内部的this永远都是currentTarget，也就是现在事件作用的目标（按钮、window等）； 一个函数处理多个事件，可以使用switch(event.type)函数；阻止特定时间的默认行为，可以使用preventDefault()方法；停止事件在DOM层次中传播停止事件的捕获和冒泡，可以调用stopPropagation()： 12345678var btn = document.getElementById(\"myBtn\");btn.onclick = function(event) &#123; alert(\"Clicked\"); event.stopPropagation(); //避免了下面body上的事件触发&#125;;document.body.onclick = function(event) &#123; alert(\"Body clicked\");&#125;; 事件对象的eventPhase属性可以用来确定事件当前正位于事件流的哪个阶段。捕获阶段调用程序为1，程序正在目标对象上为2，在冒泡阶段调用程序为3 IE中的事件对象 12345var btn = document.getElementById(\"myBtn\");btn.onclick = function() &#123; var event = window.event; alert(event.type); //\"click\"&#125; 由于事件处理程序的作用域在IE下是全局，在DOM下是局部作用域，所以提供event.srcElement来判断this的指向： 1234567var btn = document.getElementById(\"myBtn\");btn.onclick = function() &#123; alert(window.event.srcElement === this); //true&#125;;btn.attachEvent(\"onclick\", function(event) &#123; alert(event.srcElement === this); //false &#125;); 若想要取消时间的默认行为，可以通过设置window.event.returnValue = false进行； 若想要阻止时间的冒泡（IE只支持事件冒泡），可以通过设置window.event.cancelBubble = true; 跨浏览器的事件对象 事件类型 UI事件 load(html中可以给标签添加onload unload abort error select resize scroll 焦点事件 blur focus focusin focusout 鼠标与滚轮事件 click dbclick mousedown mouseenter mouseleave mousemove mouseout mouseover mouseup 键盘与文本事件 keydown keypress keyup 复合事件 compositionstart compositionupdate compositionend HTML5事件 contextmenu beforeunload DOMContentLoaded readystatechange pageshow/pagehide hashchange","categories":[{"name":"Document","slug":"Document","permalink":"http://keefe.wang/categories/Document/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://keefe.wang/tags/基础知识/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://keefe.wang/tags/读书笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://keefe.wang/tags/JavaScript/"}]},{"title":"JavaScript中的原型与继承-原型篇","slug":"2017-04-12-JavaScript-Prototype-and-Inheritance-1","date":"2017-04-12T04:00:00.000Z","updated":"2017-10-09T07:13:05.000Z","comments":true,"path":"2017/04/12/2017-04-12-JavaScript-Prototype-and-Inheritance-1.html","link":"","permalink":"http://keefe.wang/2017/04/12/2017-04-12-JavaScript-Prototype-and-Inheritance-1.html","excerpt":"原型构造函数模式下，对象中的方法作用域只在对象中，对象的不同实例的同名函数都是不相等的。为了解决这个问题，js中创建的每一个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所由实例共享的属性和方法。","text":"原型构造函数模式下，对象中的方法作用域只在对象中，对象的不同实例的同名函数都是不相等的。为了解决这个问题，js中创建的每一个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所由实例共享的属性和方法。 原型对象JavaScript中并没有提供类的实现，虽然在ES2015/ES6之中引入了class关键字，但是JavaScript仍然是基于原型的。而JavaScript中创建对象的方法有：new Object()方法、字面量方法、工厂模式、构造函数方法和原型模式。其中，使用原型模式创建对象可以令所有实例共享方法，减少内存消耗，有利于对象继承。 JavaScript中的继承则是体现在一种结构上——对象，所有的对象都是由Object衍生的对象，所有的对象都继承了Object.prototype的方法和属性（也有可能被覆盖）。每一个对象都有一个内部链接到另一个对象，这个对象成为它的原型（prototype）。而且，该原型对象也有自己的原型，直到追溯到一个以null为原型的对象，因为null是没有原型的，所以可以作为这个原型链（prototype chain中的最终链接。 只要创建了一个新函数，就会为该函数创建一个prototype属性，这个属性指向函数的原型对象。所有原型对象都自动获得一个constructor属性，这个属性包含一个指向prototype属性所在函数的指针。 原型对象的创建1234567891011121314function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; &#125; Person.prototype.sayName = function() &#123; alert(this.name); &#125; var person1 = new Person(\"Nicholas\", 29, \"Lawyer\"); var person2 = new Person(\"Katie\", 30 \"Account\"); var person3 = new Person(\"Nicholas\", 29, \"Lawyer\"); person1.sayName(); //\"Nicholas\" person2.sayName(); //\"Katie\" alert(person1.sayName == person3.sayName); //true 更加简单的原型对象创建语法： 123456789function Person()&#123;&#125;Person.prototype = &#123; name : \"Nicholas\", age : 29, job : \"Software Engineer\", sayName : function() &#123; alert(this.name) &#125; &#125;; 代码搜索某属性的路径： 上面代码中出现了Person.prototype,通过该形式可以获得原型对象，并且可以为其添加属性和方法。这段代码也展示了对象属性和方法搜索的路径：每当代码读取某个对象的某个属性时，进行目标为该属性的名字，搜索首先从实例（person1）本身开始，若有该名字的属性则返回该属性，若没有则继续搜索该实例中原型指针指向的原型对象，在原型对象中查找该名字的属性。所以说实例是共享原型中保存的属性和方法。 实例的属性，原型的属性？ 一个对象的所有实例尽管可以共享该原型对象的所有属性和方法，但是却无法重写原型对象中的属性和方法，只能通过利用同名属性和方法来覆盖和屏蔽原型对象中的属性和方法；若想把实例中覆盖的属性还原，可以通过delete操作。使用hasOwnProperty()方法可以检测一个属性是存在于实例中还是存在于原型中。 怎样获得原型对象: 下面的代码展示了Object.getPrototypeOf(obj)方法和proto属性的使用： 12Object.getPrototypeOf(person1) === Person.prototype; //true person1.__proto__ === Person.prototype; //true 可以看到，Object.getPrototypeOf(obj)是获取obj对象的原型对象的方法，这个方法将在利用原型实现继承的情况中发挥非常重要的作用。obj.proto 也是如此，是每一个对象都拥有的属性，但是proto并不是一个规范的属性（当使用Object.create()方法创建对象时，proto 并不能指向该对象的原型对象），其对应的标准属性应当是[[Prototype]]。 原型对象和构造函数对于对象Person来说，它的构造函数是Person()，它的原型对象为Person.prototype；而Person.prototype.constructor又会指回Person。而对象Person的实例person1和person2都包含有一个属性[[Prototype]]（也就是上面提到的proto）它们都指向Person.prototype；同时，person1和person2也可以通过isprototypeOf(）方法来确定是否与确定对象之间有这种关系： alert(Person.prototype.isPrototypeOf(person1)); //true 原型与in操作符 in操作符单独使用的情况 in操作符单独使用会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是在原型中： 1234//接上面Person对象代码 var person4 = new Person(); alert(person4.hasOwnproperty(\"name\")); //由于person4实例没有覆盖原型中的name所以返回false alert(\"name\" in person4); //true for-in循环 该种方式是返回所有能够通过对象访问的、可枚举的属性，包括实例和原型中的属性，并且屏蔽了原型中不可枚举（[[Enumerable]]）的属性（仅在IE8及更早版本中有不可枚举的属性）： 12345678910var o = &#123; toString : function() &#123; return \"my Object\" &#125; &#125; for (var prop in o) &#123; if (prop == \"toString\") &#123; alert(\"Found toString\"); //IE中无法显示 &#125; &#125; 若想获取对象中所有可枚举的实例属性，可以使用Object.keys(),该函数接受一个对象或实例作为参数（当然也可以是原型对象），返回一个包含所有可枚举属性的字符串数组。示例代码如下： 123456789//接Person对象代码 var keys = Object.keys(person.prototype); var person5 = new Person(); person5.name = \"Rob\"; person5.age = 31; alert(keys); alert(Object.keys(person5)); var keys2 = Object .getOwnPropertyNames(Person.prototype); alert(keys2); 上述代码中出现的Object.getOwnPropertyNames(Person.prototype)方法可以得到所有的可枚举/不可枚举的实例属性（列入constructor）。 原型的动态性由于从原型中查找值的过程试一次搜索，因此对原型对象所做的任何修改都能从实例上反映出来。即，可以先创建实例，再修改原型对象中的属性或函数，实例依旧可以访问该属性和函数： 123456//接person对象代码 var friend = new Person(); Person.prototype.sayHi = function() &#123; alert(\"hi!\"); &#125;; friend.sayHi(); //返回”hi” 尽管像以上代码中所看到的可以为原型添加属性或方法，但是如果重写整个原型对象，就会切断实例的构造函数与最初原型对象之间的联系。这是因为实例中的指针仅指向原型，而非构造函数。 原生对象的原型不仅是自定义的对象，JavaScript中所有原生的引用类型，都是采用这种模式创建的原生对象。通过原生对象的原型可以取得所有默认方法的引用，也可以自己添加新的方法。 原型对象的缺点 由于原型中所有属性都是可以被实例共享，而对于原型中含有引用类型值的属性来说就会发生问题： 123456//接person对象代码 Person.prototype.friends = [\"Shelby\", \"Court\"]; var person6 = new Person(); person6.friends.push(\"Van\"); alert(person6.friends); alert(person1.friends); //此时两个Person的实例拥有相同的朋友，很可能发生错误 可以看到，由于原型的属性可以被共享的这一特性，原型对象中包含的引用类型值很可能被修改之后导致实例的属性也发生错误，必须要在实例属性中覆盖才可以。所以为了解决这个问题，提出了以下组合构造函数模式和原型模式的方法来创建对象： 123456789101112131415//改写上面的Person对象 //首先使用构造函数模式创建对象Person并加入容易被修改的属性name，age，job function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.friends = [\"Shelby\", \"Court\"]; &#125; //再使用原型模式创建构造函数和不容易被修改的属性和函数，这样可以发挥原型的共享机制并减少内存消耗 Person.prototype = &#123; constructor : Person, //将构造函数放入原型中 sayName : function() &#123; alert(this.name); &#125; &#125;","categories":[{"name":"Document","slug":"Document","permalink":"http://keefe.wang/categories/Document/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://keefe.wang/tags/基础知识/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://keefe.wang/tags/读书笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://keefe.wang/tags/JavaScript/"},{"name":"原型","slug":"原型","permalink":"http://keefe.wang/tags/原型/"},{"name":"继承","slug":"继承","permalink":"http://keefe.wang/tags/继承/"}]},{"title":"CSS中的伪类与伪元素","slug":"2017-03-10-pseudoCSS-part1-pseudoElement-pseudoClass-note","date":"2017-03-10T04:00:00.000Z","updated":"2017-10-09T07:13:05.000Z","comments":true,"path":"2017/03/10/2017-03-10-pseudoCSS-part1-pseudoElement-pseudoClass-note.html","link":"","permalink":"http://keefe.wang/2017/03/10/2017-03-10-pseudoCSS-part1-pseudoElement-pseudoClass-note.html","excerpt":"简介[^1]样式表中的选择器是控制网页样式输出的非常重要的工具之一，也是css通过DOM树来控制其样式的最好的方式之一。而除了标签选择器、类选择器、ID选择器、属性选择器以及元素关系选择器（父子、兄弟等选择器），CSS3为我们提供了一种更为复杂同时也是更为方便设计者的选择方式-伪类（Pseudo-Classes）和伪元素（Pseudo-Elements）。 伪类和伪元素通常由冒号（colon）引导，而CSS3重新规定伪元素之前需要由两个冒号引导，但是为了使旧版本网站也能够统一使用和显示（IE8及以下浏览器无法理解双冒号的语法），浏览器则仍支持单冒号引导的伪元素方式（除了少数特定的伪元素之外）。","text":"简介[^1]样式表中的选择器是控制网页样式输出的非常重要的工具之一，也是css通过DOM树来控制其样式的最好的方式之一。而除了标签选择器、类选择器、ID选择器、属性选择器以及元素关系选择器（父子、兄弟等选择器），CSS3为我们提供了一种更为复杂同时也是更为方便设计者的选择方式-伪类（Pseudo-Classes）和伪元素（Pseudo-Elements）。 伪类和伪元素通常由冒号（colon）引导，而CSS3重新规定伪元素之前需要由两个冒号引导，但是为了使旧版本网站也能够统一使用和显示（IE8及以下浏览器无法理解双冒号的语法），浏览器则仍支持单冒号引导的伪元素方式（除了少数特定的伪元素之外）。 伪类和伪元素的区别[^2]CSS中的伪类根据元素的编码或动态状态等来选择HTML文档中特定部分，即选择HTML文档中的某元素（通过用户的干预或者随着时间的变化而产生动态改变状态），CSS2又将该特性扩展到了DOM树的某些“虚拟组件”和可推断部分（例如first-child），可以出现在选择器链条中的任何位置； CSS中的伪元素是用来强调某些元素的子部分，允许选择并改变那些除DOM中指定的元素之外的部分的样式（对DOM树中未包含的逻辑元素进行选择和改变样式）(可以用来展示比如头字母大写等常见的排版效果)；伪元素有一些使用的限制条件： 不允许出现在中的in-line样式（只能出现在外部样式表或位于的样式中）； 在选择器的链条中只能出现在最后一位（即要位于任何类和ID选择之后）； 每个选择器中只能出现一个伪元素（若要在单个元素结构中城县多个伪元素的选择，必须使用多个选择器/样式声明）； 伪类伪类就像是class一样，以冒号引导（e.g. :hover等），可以以标签:伪类和类:伪类的形式存在于CSS样式表中。 动态伪类链接样式的动态伪类针对链接，用户可以无任何操作、将光标移至链接上、点击、点击后放开光标，将光标从链接上移走等操作。 a:link选择用户还未进行过任何操作的链接； a:visited选择用户已经点击过的链接； a:hover选择用户将鼠标移至上方的链接；同时，:hover伪类也可以用在除链接以外的元素上（e.g. 或是）； a:active选择用户使用鼠标正在点击（按下）的链接； 样例代码：1234.example a:link &#123;color:gray;&#125; /*链接没被访问时为灰色*/.example a:visited &#123;color:maroon;&#125; /*链接被访问过后前景色为红色*/.example a:hover &#123;color:blue;&#125; /*鼠标悬浮在链接上时前景色为蓝色*/.example a:active &#123;color:darkblue;&#125; /*鼠标按下链接前景色为深蓝色*/ 这里需要特别注意的是，这四个动态伪类在样式表中定义的顺序是不可以任意排序的，而是要遵循唯一的一个顺序，即LOVE/HATE原则，即以a:link/a:visited/a:hover/a:active的顺序来定义。这是因为在CSS样式表中针对同一个元素的样式定义要从一般到特殊。一个链接在用户未进行操作的时候可能同时拥有:link、:visited和:hover三种样式属性，而无论如何:hover都会覆盖前面两种样式，所以:hover要在前面两种样式之后定义，而:link又是最一般的样式，所以要放在第一位来进行定义；最后:active则能覆盖所有之前三种属样式，所以放在最后一位进行定义。一句话来总结这一特性，越容易被覆盖的样式越先定义，覆盖越多的样式要越晚定义。 表单样式的动态伪类常对于输入类的表单进行选择并展示或修改其样式的动态伪类； :focus与链接中的:hover的作用类似，是当用户将光标的注意力集中到某元素而改变其样式，多用于用户在网页上的表单进行输入的元素进行选择（e.g. \\或\\）。 UI元素状态伪类(IE8及以下不支持该伪类)： :enabled选择可以进行输入和选择等操作的表单元素进行样式的声明； :disabled选择不能进行输入和选择等操作的表单元素进行样式的声明； :checked选择已经选择的表单元素（type为radio或checkbox元素）进行样式声明； :unchecked选择还未进行选择的表单元素进行样式声明； 子选择器（:nth选择器）CSS原本提供了后代选择器（descendant selector），但是针对于某些特定的场景，例如列表和表格制定行列的样式改变，CSS又提供了伪类选择器来为这些子类选择器提供服务。 :first-child选择指定元素中第一个子元素； :last-child选择指定元素中最后一个子元素； :nth-child(parameter)选择某个元素的一个或多个特定的子元素，参数可以是自然数，也可以是像2n，3n+1，-n+3这样的公式进行有规律的子元素选择； :nth-last-child()与:nth-child()作用相同，但是是从选定元素的最后一个子元素开始算起； :nth-of-type()与:nth-child()作用相同，但是可以选择指定类别的子元素； :nth-last-of-type()与:nth-nth-of-type()作用相同，但是是从选定元素的最后一个子元素开始算起； :first-of-type与:first-child作用相同，只是可以选择子元素的类型； :last-of-type与:last-child作用相同，只是可以选择子元素的类型； :only-child当指定元素只有一个子元素时，选择该子元素； :only-of-type当指定元素只有一个指定类型的子元素时，选择该子元素； :empty当制定元素中没有任何内容时； 特殊伪类选择器 :target该伪类类似于HTML中的锚，指向文档中某个具体的元素，常用于点击出现某些指定元素样式的改变（点击按钮，某元素由display:none变为display:block;这样的出现效果）； :not也被称作negation pseudo-class，也就是否定取反。当使用类似于 1p:not(.exampleStyle)&#123;color:green&#125; 时，意为选择所有不包含。exampleStyle类的p元素进行选择改变字体颜色为green。 伪元素::before和::after ::before可以在某给定元素上添加提前展示的内容： 1.tip::before &#123;content: \"HOT TIP!\" &#125; ::after可以在某给定元素上添加提前展示的内容： 1.tip::after &#123;content: \"HOT TIP!\" &#125; 文字排版常见的::first-line和::first-letter ::first-line选择制定元素的第一行（例如改变每个段落的第一行文本样式）； ::first-letter选择制定文本块的第一个字母进行样式设置，多用于进行段落排版； 光标选中文本样式::selection::selection用来改变浏览网页选中文本的默认效果； [^1]: 《CSS, The Missing Manual, 4th Edition》[^2]: Difference between a pseudo-class and a pseudo-element","categories":[{"name":"Document","slug":"Document","permalink":"http://keefe.wang/categories/Document/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://keefe.wang/tags/基础知识/"},{"name":"CSS3","slug":"CSS3","permalink":"http://keefe.wang/tags/CSS3/"},{"name":"Selector","slug":"Selector","permalink":"http://keefe.wang/tags/Selector/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://keefe.wang/tags/读书笔记/"}]},{"title":"Node-js基础学习笔记","slug":"2016-12-13-nodejs-basic-learning-note","date":"2016-12-13T04:00:00.000Z","updated":"2017-10-09T07:13:05.000Z","comments":true,"path":"2016/12/13/2016-12-13-nodejs-basic-learning-note.html","link":"","permalink":"http://keefe.wang/2016/12/13/2016-12-13-nodejs-basic-learning-note.html","excerpt":"Node.js基础学习笔记在前端的学习过程当中，不可避免地要学习到一定的后台服务器的技术。之前一直都沉浸在servlet中无法自拔，所以Java一度成为自己还比较熟悉的后台语言，但是相对于本身比较熟悉的JavaScript来说，当然是尽量用JS来处理后台最好不过了，所以Node.js顺其自然成为了学习路上必要的一道关卡。 略过安装、配置和创建第一个应用，想必很多Node.js相关网站都可以找到相应的教程，本文仅记录在学习Node.js基础知识中一些关键点技术。","text":"Node.js基础学习笔记在前端的学习过程当中，不可避免地要学习到一定的后台服务器的技术。之前一直都沉浸在servlet中无法自拔，所以Java一度成为自己还比较熟悉的后台语言，但是相对于本身比较熟悉的JavaScript来说，当然是尽量用JS来处理后台最好不过了，所以Node.js顺其自然成为了学习路上必要的一道关卡。 略过安装、配置和创建第一个应用，想必很多Node.js相关网站都可以找到相应的教程，本文仅记录在学习Node.js基础知识中一些关键点技术。 Node.js应用Node.js 应用是由下面几部分组成的： 引入 required 模块：我们可以使用 require 指令来载入 Node.js 模块。 创建服务器：服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。 接收请求与响应请求 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。 创建一个服务器： 1234567891011var http = require('http');http.createServer(function (request, response) &#123; // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); // 发送响应数据 \"Hello World\" response.end('Hello World\\n');&#125;).listen(8888);// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); 回调函数Node.js是单进程单线程应用程序，但是通过事件和回调支持并发和异步。 Node的所有API都支持回调函数，并作为一个独立线程运行，完美支持异步处理大量的请求。回调函数作为最后一个参数传入异步函数，而回调函数的第一个参数为错误对象： 123456789var fs = require(\"fs\");fs.readFile('input.txt', function (err, data) &#123; if (err)&#123; console.log(err.stack); return; &#125; console.log(data.toString());&#125;);console.log(\"程序执行完毕\"); 事件循环Node.js使用事件驱动模型，所有的事件机制都是用设计模式中观察者模式实现。代码中引入events模块，通过实例化EventEmitter类来绑定和监听事件： 12345678var events = require('events'); // 引入 events 模块var eventEmitter = new events.EventEmitter(); // 创建 eventEmitter 对象event.on('some_event', function() &#123; // 绑定事件，function中可添加多参数 console.log('some_event 事件触发'); &#125;); setTimeout(function() &#123; // 触发事件 event.emit('some_event'); &#125;, 1000); events模块下只有一个对象：events.EventEmitter，其核心就是事件触发与事件监听两者的封装。EventEmitter的每个事件都由一个事件名（一个字符串）和若干参数构成。一般来说，不会直接使用EventEmitter，而是在对象中继承它，包括fs、net、http在内都是EventEmitter的子类（为了符合事件语义，并且符合JS的原型对象机制）。 EventEmitter对象的属性 .addListener(event, listener)：为指定事件添加一个监听器到监听器数组的尾部 .on(event, listener)：为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数 .once(event, listener):为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器 .removeListener(event, listener)：移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称 .removeAllListeners([event])：移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器 setMaxListeners(n)：默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息；setMaxListeners 函数用于提高监听器的默认限制的数量 listeners(event)：返回指定事件的监听器数组。 emit(event, [arg1], [arg2], […])：按参数的顺序执行每个监听器，如果事件有注册监听返回 true，否则返回 false。 缓冲区由于JS中不支持二进制数据类型，所以在处理像TCP流或文件流时，Node.js提供了Buffer类，用来创建一个专门存放二进制数据的缓存区（一个Buffer类类似于一个整数数组）。创建Buffer实例有多种方法： 123+ 以字节数量创建：var buf = new Buffer(10);+ 以数组创建：var buf = new Buffer([10, 20, 30, 40, 50]);+ 以字符串创建：var buf = new Buffer(&quot;www.runoob.com&quot;, &quot;utf-8&quot;); 写入缓冲区：buf.write(string[, offset[, length]][, encoding]);参数分别为必须的写入缓冲区的字符串，可选的开始写入索引值（默认为0）、写入字节数（默认buffer.length）、使用的编码（默认为utf8）。该写入的方法会返回实际写入的大小 读缓冲区：buf.toString([encoding[, start[, end]]]); 将Buffer实例转换为JSON对象：buf.toJSON() 缓冲区合并：Buffer.concat(bufArray[, totalLength]);其中bufArray是需要进行合并的Buffer实例数组 缓冲区比较：buf.compare(otherBuffer);返回负数表示buf在前，0表示相同，正数表示buf在后 拷贝缓冲区：buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]]);其中buf是被复制的，targetBuffer是复制的目标缓冲区 缓冲区裁剪：buf.slice([start[, end]]);返回一个新的缓冲区，与旧缓冲区指向同一块内存，索引不同 缓冲区长度：buf.length;返回缓冲区所占内存长度 Stream是一个抽象接口，流类型有四种： 1234+ Readable：可读操作+ Writable：可写操作+ Duplex：可读可写操作+ Transform：操作被写入数据，然后读出结果 所有的Stream对象都是EventEmitter的实例，所以可以绑定的常用事件有data（有数据可读时触发）、end（没有更多数据可读时触发）、error（接收和写入过程发生错误时触发）、finish（所有数据写入到底层系统时触发）。 Node中又有很多对象实现了这个接口，例如对http服务器发起请求的request对象就是一个Stream，stdout（标准输出）也是一个Stream。 读取流 1234567891011121314var fs = require(\"fs\");var data = '';var readerStream = fs.createReadStream('input.txt');//创建可读流readerStream.setEncoding('UTF8');// 处理流事件 --&gt; data, end, and errorreaderStream.on('data', function(chunk) &#123; //此处的data并不是读取结果字符串 data += chunk;&#125;);readerStream.on('end',function()&#123; console.log(data);&#125;);readerStream.on('error', function(err)&#123; console.log(err.stack);&#125;); 写入流 1234567891011var fs = require(\"fs\");var data = '菜鸟教程官网地址：www.runoob.com';var writerStream = fs.createWriteStream('output.txt');//创建写入流writerStream.write(data,'UTF8');writerStream.end(); // 标记文件末尾writerStream.on('finish', function() &#123; console.log(\"写入完成。\");&#125;);writerStream.on('error', function(err)&#123; console.log(err.stack);&#125;);","categories":[{"name":"Document","slug":"Document","permalink":"http://keefe.wang/categories/Document/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://keefe.wang/tags/基础知识/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://keefe.wang/tags/读书笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://keefe.wang/tags/JavaScript/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://keefe.wang/tags/Nodejs/"}]},{"title":"Ontology本体基础知识总结整理","slug":"2015-09-21-ontology-concepts-conclusion","date":"2015-09-21T04:00:00.000Z","updated":"2017-10-09T07:13:05.000Z","comments":true,"path":"2015/09/21/2015-09-21-ontology-concepts-conclusion.html","link":"","permalink":"http://keefe.wang/2015/09/21/2015-09-21-ontology-concepts-conclusion.html","excerpt":"本体的概念共享概念模型的明确的形式化规范说明。包括四个主要的方面： 概念化（conceptualization）：客观世界的现象的抽象模型； 明确（explicit）：概念及它们之间联系都被精确定义； 形式化（formal）：精确的数学描述； 共享（share）：本体中反映的知识是其使用者共同认可的。","text":"本体的概念共享概念模型的明确的形式化规范说明。包括四个主要的方面： 概念化（conceptualization）：客观世界的现象的抽象模型； 明确（explicit）：概念及它们之间联系都被精确定义； 形式化（formal）：精确的数学描述； 共享（share）：本体中反映的知识是其使用者共同认可的。 本体构成要素 类：集合（sets）、概念、对象类型或者说事物的种类； 关系：关系代表了在领域中类之间的交互作用。形式上定义为n 维笛卡儿乘积的子集： R ： C1 ×C2×⋯×Cn 。 如：子类关系( subclass-of)； 函数： 函数是一类特殊的关系。在这种关系中前n - 1 个元素可以惟一决定第n 个元素。形式化的定义如下： F ： C1 ×C2 ×⋯×Cn-1→Cn 。例如Mother-of 关系就是一个函数，其中Mother-of ( x ， y) 表示y 是x 的母亲，显然x 可以惟一确定他的母亲y； 公理：公理代表永真断言，比如概念乙属于概念甲的范围； 实例：实例代表元素，即某个类中的第一个对象； 专家系统 知识库： 推理机：本体按照是否具备推理功能可以分为轻量级本体、中级本体和重量级本体；技术构成库应该属于可以识别一阶谓词逻辑表达式的中级本体 本体语言 本体语言目前成为标准的是OWL； Cyc和loom两种语言具有较强的推理能力； 领域本体的知识库构建 本体构建原则：清晰、一致、可扩展性、编码偏好程度最小、本体约定最小； 两种模式： 利用现有文献和领域专家使用手工的方式创建概念关联； 将已有的叙词表改造成本体，或者采用学习机制，进行自动或自动化的本体构建。 本体手工构建方法：骨架法、企业建模法、Methontology、KACTUS、循环获取法、IDEF-5、七步法； 七步法： 确定本体的专业领域与范畴； 考查复用现有本体的可能性； 列出本体中的重要术语； 定义类和类的等级关系； 定义类的属性； 定义属性的分面(Facets)； 创建实例。 领域本体知识库架构三个层次： 表示层：表示层是用户与系统交互的接口，用户通过浏览器或其他界面访问系统，用户界面负责接收查询请求， 并将服务端的检索结果回显给用户； 业务逻辑层：业务逻辑层为主要应用逻辑层，实现系统知识的检索。它由本体管理组件、语义分析组件、推理引擎、查 询组件和信息获取组件5个部分组成； 数据层：数据层包括3个部分：本体库、资源描述库、资源数据库。它是知识库的存储介质，创建并提炼出结构化 的知识本体，是知识检索的直接来源；","categories":[{"name":"Document","slug":"Document","permalink":"http://keefe.wang/categories/Document/"}],"tags":[{"name":"Knowledge Base","slug":"Knowledge-Base","permalink":"http://keefe.wang/tags/Knowledge-Base/"},{"name":"Ontology","slug":"Ontology","permalink":"http://keefe.wang/tags/Ontology/"},{"name":"基础知识","slug":"基础知识","permalink":"http://keefe.wang/tags/基础知识/"}]},{"title":"Jena学习笔记","slug":"2015-11-20-jena-learning-note","date":"2015-09-21T04:00:00.000Z","updated":"2017-10-09T07:13:05.000Z","comments":true,"path":"2015/09/21/2015-11-20-jena-learning-note.html","link":"","permalink":"http://keefe.wang/2015/09/21/2015-11-20-jena-learning-note.html","excerpt":"Jena初步了解JenaAPI的框架如下图：","text":"Jena初步了解JenaAPI的框架如下图： 如上图所示，利用Jena进行语义网处理应用的开发有通过HTTP和Servlet响应的B/S模式，还有通过JenaAPI进行Java编程来处理本体数据。 RDF API：Jena提供了对RDF文件的创建、读/写以及一些基本操作的接口（方法）； SPARQL API：Jena提供一套对本体的三元组的query机制，类似于SQL语言对于数据库的操作，SPARQL对于本体的查询也可以通过简单的查询语句达到目的，这也为B/S模式的本体展示和交互提供了基础； Ontology API： Fuseki RDF API名词解释 Blank Node：一阶逻辑中表示一个无URI的resource Literal：可作为一个property的值（value） Object：the resource or literal pointed to by the arc（箭头指向的一端） Subject：the resource from which the arc leaves（箭头离开的一端） Triple： Predicate：三元组中的属性部分（关系）（the property that labels the arc） Property：一个resource的属性，指三元组中的关系 Resouce：实体，通常由URI命名的资源 Statement：指一个fact，即一个三元组（Each arc in an RDF Model） 对RDF的操作（JavaAPI） Create graph 123456789101112// some definitionsstatic String personURI = \"http://somewhere/JohnSmith\";static String fullName = \"John Smith\";// create an empty ModelModel model = ModelFactory.createDefaultModel();// create the resourceResource johnSmith = model.createResource(personURI);// add the property johnSmith.addProperty(VCARD.FN, fullName); Create resource and add the property 12//Resouce exampleResource johnSmith = model.createResource(personURI).addProperty(VCARD.FN, fullName); 123456789101112131415161718// some definitionsString personURI = \"http://somewhere/JohnSmith\";String givenName = \"John\";String familyName = \"Smith\";String fullName = givenName + \" \" + familyName;// create an empty ModelModel model = ModelFactory.createDefaultModel();// create the resource// and add the properties cascading styleResource johnSmith = model.createResource(personURI) .addProperty(VCARD.FN, fullName) .addProperty(VCARD.N, model.createResource() .addProperty(VCARD.Given, givenName) .addProperty(VCARD.Family, familyName)); Manipulate the stmt 123456789101112131415161718192021// list the statements in the ModelStmtIterator iter = model.listStatements();// print out the predicate, subject and object of each statementwhile (iter.hasNext()) &#123; Statement stmt = iter.nextStatement(); // get next statement Resource subject = stmt.getSubject(); // get the subject Property predicate = stmt.getPredicate(); // get the predicate RDFNode object = stmt.getObject(); // get the object System.out.print(subject.toString()); System.out.print(\" \" + predicate.toString() + \" \"); if (object instanceof Resource) &#123; System.out.print(object.toString()); &#125; else &#123; // object is a literal System.out.print(\" \\\"\" + object.toString() + \"\\\"\"); &#125; System.out.println(\" .\");&#125; 由于object可以是Resource或者Literal，所以object的类型为RDFNode。 Writing RDF 1234// now write the model in XML form to a filemodel.write(System.out);model.write(System.out, \"RDF/XML-ABBREV\"); // write the model in XML form to a filemodel.write(System.out, \"N-TRIPLES\"); // write the model in N-TRIPLES form to a file Reading RDF 123456789101112131415// create an empty model Model model = ModelFactory.createDefaultModel(); // use the FileManager to find the input file InputStream in = FileManager.get().open( inputFileName );if (in == null) &#123; throw new IllegalArgumentException( \"File: \" + inputFileName + \" not found\");&#125;// read the RDF/XML filemodel.read(in, null);// write it to standard outmodel.write(System.out); SPARQL API需要保存在.rq文件中进行使用。 Basic query： 1SELECT ?xWHERE&#123; ?x&lt;http://www.w3.org/2001/vcard-rdf/3.0#FN&gt; &quot;JohnSmith&quot; &#125; 其中&lt;&gt;中为URI，“”中为literal，？x为查询变量 Basic pattern 1234WHERE &#123; ?y &lt;http://www.w3.org/2001/vcard-rdf/3.0#Family&gt; &quot;Smith&quot; . ?y &lt;http://www.w3.org/2001/vcard-rdf/3.0#Given&gt; ?givenName . &#125; basic patterns：是一组三元组的模式；prefix and blanknodes： 1234567PREFIX vcard: &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt;SELECT ?y ?givenNameWHERE &#123; ?y vcard:Family &quot;Smith&quot; . ?y vcard:Given ?givenName . &#125; Filters 1234567PREFIX vcard: &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt;SELECT ?gWHERE&#123; ?y vcard:Given ?g . FILTER regex(?g, &quot;r&quot;, &quot;i&quot;) &#125; 上面的加粗为FILTER，其中最后一个“”中的i表示case-insensitive Optionals（表示如果有这个属性那么就显示在结果中，如果没有就不显示） 123456789PREFIX info: &lt;http://somewhere/peopleInfo#&gt;PREFIX vcard: &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt;SELECT ?name ?ageWHERE&#123; ?person vcard:FN ?name . OPTIONAL &#123; ?person info:age ?age &#125;&#125; optionals with filters： 123456789PREFIX info: &lt;http://somewhere/peopleInfo#&gt;PREFIX vcard: &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt;SELECT ?name ?ageWHERE&#123; ?person vcard:FN ?name . OPTIONAL &#123; ?person info:age ?age . FILTER ( ?age &gt; 24 ) &#125;&#125; Unions： 12345678PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;PREFIX vCard: &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt;SELECT ?nameWHERE&#123; &#123; [] foaf:name ?name &#125; UNION &#123; [] vCard:FN ?name &#125;&#125; 相当于FILTER ( ?p = foaf:name || ?p = vCard:FN)如果是分开资源那么只要分别用不同变量标注即可： 12345SELECT ?name1 ?name2WHERE&#123; &#123; [] foaf:name ?name1 &#125; UNION &#123; [] vCard:FN ?name2 &#125;&#125; SPARQL result forms： SELECT – Return a table of results. CONSTRUCT – Return an RDF graph, based on a template in the query. DESCRIBE – Return an RDF graph, based on what the query processor is configured to return. ASK – Ask a boolean query.","categories":[{"name":"Document","slug":"Document","permalink":"http://keefe.wang/categories/Document/"}],"tags":[{"name":"Ontology","slug":"Ontology","permalink":"http://keefe.wang/tags/Ontology/"},{"name":"基础知识","slug":"基础知识","permalink":"http://keefe.wang/tags/基础知识/"},{"name":"JenaAPI","slug":"JenaAPI","permalink":"http://keefe.wang/tags/JenaAPI/"},{"name":"API","slug":"API","permalink":"http://keefe.wang/tags/API/"}]},{"title":"Markdown","slug":"2014-12-25-markdown-programming-language","date":"2014-12-24T16:31:00.000Z","updated":"2017-10-09T07:13:05.000Z","comments":true,"path":"2014/12/25/2014-12-25-markdown-programming-language.html","link":"","permalink":"http://keefe.wang/2014/12/25/2014-12-25-markdown-programming-language.html","excerpt":"本篇文章是关于本站博客文章的Markdown格式的文档。","text":"本篇文章是关于本站博客文章的Markdown格式的文档。 段落元素 p和br 标题 段落引用 列表 代码 Horizontal Rules 表格 段内元素 链接 强调 代码 图片 混杂模式 自动链接 Backslash Escapes 内联HTML Block ElementsParagraphs and Line Breaks段落HTML标签: &lt;p&gt; 在一段后进行回车空出一行可以达到该效果。 代码: This will be inline. This is second paragraph. 预览: This will beinline. This is second paragraph. HeadersMarkdown支持两种方式的标题：Setext/atx. SetextHTML标签: &lt;h1&gt;, &lt;h2&gt; 使用等号‘=’在标题下划线代表&lt;h1&gt;， 使用连字符‘-’在标题下划线表示 &lt;h2&gt;，其中符号的数量可以不做限制. 代码: This is an H1 ============= This is an H2 ------------- 预览: This is an H1This is an H2 atxHTML标签: &lt;h1&gt;, &lt;h2&gt;, &lt;h3&gt;, &lt;h4&gt;, &lt;h5&gt;, &lt;h6&gt; 使用1到6个‘#’号来表示标题标签 &lt;h1&gt; - &lt;h6&gt;. 代码: # This is an H1 ## This is an H2 ###### This is an H6 预览: This is an H1This is an H2This is an H6 atx格式的标题可以进行闭合如### This is an H3 ######，可见两端的‘#’号数量不需要相等。 BlockquotesHTML标签: &lt;blockquote&gt; 需要再每一个段落之前加‘&gt;’符号来形成段落引用。 Code: &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, &gt; &gt; This is nested blockquote. &gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; &gt; id sem consectetuer libero luctus adipiscing. Preview: This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, This is nested blockquote. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse ListsMarkdown支持有序和无序列表。 无序列表HTML标签: &lt;ul&gt; 无序列表可以使用‘*’、‘+’、‘-’三种符号开头并在符号后添加一个空格。 代码: * Red + Green — Blue 预览: Red Green Blue OrderedHTML标签: &lt;ol&gt; 有序列表通过数字和点符号‘.’以及空格开头来表示，前面的数字是几无所谓，会自动解析成从小到大的顺序。 代码: 1. Bird 22. McHale 3. Parish 44\\. Cat 预览: Bird McHale Parish44. Cat 缩进段落级别的缩进使用tab添加在段落之前即可。 Code BlocksHTML标签: &lt;pre&gt; 代码的每一行都缩进至少‘4个空格’和‘1个tab’，代码结束是以第一个不缩进的段落为止。 代码: This is a normal paragraph: This is a code block. 代码: This is a normal paragraph: This is a code block. 包裹代码可以使用`*3后跟语法名称来进行代码的包裹，从而避免每一行的缩进并可以进行语法高亮。 代码: Here&apos;s an example: 123function test() &#123; console.log(\"notice the blank line before this function?\");&#125; 预览: 123function test() &#123; console.log(&quot;notice the blank line before this function?&quot;);&#125; Horizontal RulesHTML Tag: &lt;hr /&gt;分界线可以使用’*‘、’-‘、’_’ 代码: * * * *** ***** - - - --------------------------------------- ___ 预览: - - - TableHTML标签: &lt;table&gt; 表格使用‘|’、‘:’、‘-’三种符号进行构造，其中‘-’符号必须有至少3个才能构造表格。代码: 12345678| Left | Center | Right ||:-----|:------:|------:||aaa |bbb |ccc ||ddd |eee |fff |A |B--|--12|45 预览: Left Center Right aaa bbb ccc ddd eee fff A B 12 45 Span ElementsLinksHTML标签: &lt;a&gt; Markdown支持两种类型的链接：内联在段落中和引用模式. 内联内联在段落中[Link Text](URL &quot;Title&quot;)，如果是在本站的网址，可以使用相对地址进行访问。 代码: This is [an example](http://example.com/ &quot;Title&quot;) inline link. See my [About](/about/) page for details. 预览: This is an example inline link. See my About page for details. 参考引用参考链接的形式如此：[id]: URL &quot;Title&quot; 代码: [id]: http://example.com/ &quot;Optional Title Here&quot; This is [an example][id] reference-style link. 预览: This is an example reference-style link. EmphasisHTML标签: &lt;em&gt;, &lt;strong&gt; Markdown使用‘*’、‘_’符号进行斜体的标注，‘**’、‘__’符号进行粗体的标注，如果直接使用‘*’符号可以加‘\\’进行转义。 代码: *single asterisks* _single underscores_ **double asterisks** __double underscores__ 预览: single asterisks single underscores double asterisks double underscores CodeHTML标签: &lt;code&gt; 使用‘`’来对内联的代码进行包裹，backtick quotes (`). Code: Use the `printf()` function. Preview: Use the printf() function. ImagesHTML标签: &lt;img /&gt; Markdown支持内联和参考引用两种方式进行图片的添加。 内联内联图片代码如此： ![Alt text](URL &quot;Title&quot;)，其中title是可选的一项。 代码: ![Alt text](/path/to/img.jpg) ![Alt text](/path/to/img.jpg &quot;Optional title&quot;) Reference参考引用方式的代码如此： ![Alt text][id] 代码: [img id]: url/to/image &quot;Optional title attribute&quot; ![Alt text][img id] MiscellaneousAutomatic Links使用‘&lt; &gt;’符号将链接包裹形成自动链接。 代码: &lt;http://example.com/&gt; &lt;address@example.com&gt; 预览: http://example.com/ &#97;&#x64;&#100;&#x72;&#x65;&#115;&#115;&#64;&#x65;&#120;&#97;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#x6d; Backslash Escapes使用反斜线来进行某些符号的转义 代码: \\*literal asterisks\\* 预览: *literal asterisks* 支持以下符号: Code: \\ backslash ` backtick * asterisk _ underscore {} curly braces [] square brackets () parentheses # hash mark + plus sign - minus sign (hyphen) . dot ! exclamation mark Inline HTML如果需要一些HTML中的标签而Markdown中没有的，可以直接使用HTML标签进行包裹使用。 代码: This is a regular paragraph. &lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; This is another regular paragraph. 预览: This is a regular paragraph. Foo This is another regular paragraph.","categories":[{"name":"Document","slug":"Document","permalink":"http://keefe.wang/categories/Document/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://keefe.wang/tags/Markdown/"}]}]}