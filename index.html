<!DOCTYPE html>
<html lang=zh>
<head>
    <meta charset="utf-8">
    
    <title>Lynx-Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta property="og:type" content="website">
<meta property="og:title" content="Lynx-Blog">
<meta property="og:url" content="http://keefe.wang/index.html">
<meta property="og:site_name" content="Lynx-Blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lynx-Blog">
    

    
        <link rel="alternate" href="/" title="Lynx-Blog" type="application/atom+xml" />
    

    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


</head>

<body>
    <div id="progress">
        <span></span>
    </div>

    <div id="container">

        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">Lynx-Blog</span>
            </a>

            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>

            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">Home</a>
                
                    <a class="main-nav-link" href="/archives">Archives</a>
                
                    <a class="main-nav-link" href="/categories">Categories</a>
                
                    <a class="main-nav-link" href="/tags">Tags</a>
                
                    <a class="main-nav-link" href="/about">About</a>
                
            </nav>

            <!---->

        </div>
    </div>

    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">Home</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/categories">Categories</a></td>
                
                    <td><a class="main-nav-link" href="/tags">Tags</a></td>
                
                    <td><a class="main-nav-link" href="/about">About</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
    </div>

                </td>
            </tr>
        </table>
    </div>

</header>


            

<div class="slideshow-container">
    <div class="mySlides fade">
        <img src="css/images/1.jpg">
    </div>

    <div class="mySlides fade">
        <img src="css/images/2.jpg">
    </div>

    <div class="mySlides fade">
        <img src="css/images/3.jpg">
    </div>

    <a class="carousel-prev" onclick="plusSlides(-1)"><span class="fa fa-chevron-left"></span></a>
    <a class="carousel-next" onclick="plusSlides(1)"><span class="fa fa-chevron-right"></span></a>
</div>

<script>
    var slideIndex = 1;
    showSlides(slideIndex);

    function plusSlides(n) {
        showSlides(slideIndex += n);
    }

    function currentSlide(n) {
        showSlides(slideIndex = n);
    }

    function showSlides(n) {
        var i;
        var slides = document.getElementsByClassName("mySlides");

        if (n > slides.length) {slideIndex = 1}
        if (n < 1) {slideIndex = slides.length}

        for (i = 0; i < slides.length; i++) {
            slides[i].style.display = "none";
        }

        slides[slideIndex-1].style.display = "block";
    }
</script>

<div class="outer">
    <section id="main">
        
            <article id="post-2020-08-13-translate-how-browser-renders-webpage" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        <div class="article-corner"></div>
        

        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2020/08/13/2020-08-13-translate-how-browser-renders-webpage.html">[翻译]浏览器怎样渲染一个页面？—— DOM，CSSOM及其渲染</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2020/08/13/2020-08-13-translate-how-browser-renders-webpage.html">
            <time datetime="2020-08-13T14:02:03.000Z" itemprop="datePublished">2020-08-13</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Translate/">Translate</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Browser/">Browser</a>, <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>
    </div>

                    </div>
                
            </header>
        

        

        <div class="article-entry" itemprop="articleBody">

        
            
            <p>转自笔记 <a href="https://www.notion.so/DOM-CSSOM-64405971e5654db28a44c7d741a22a00" target="_blank" rel="external">https://www.notion.so/DOM-CSSOM-64405971e5654db28a44c7d741a22a00</a></p>
<p>在网页开发的过程中，影响用户体验的因素有很多，大部分归咎于资源加载速度慢、初始页面渲染时加载非必须的文件（甚至会出现没有样式的文档）等等。为了避免这些问题的产生，我们需要理解浏览器渲染一个特定的网页的整个周期和流程。</p>
<p>首先，我们需要搞清楚什么是 DOM。当一个浏览器向服务端请求一个 HTML 文档，服务器会将这个 HTML 文档以二进制形式的数据（一个带着 <code>Content-Type = &#39;text/html; charset=UTF-8&#39;</code> 的text 文件）进行响应。这其中， <code>text/html</code> 是一种 MIME 类型（MIME 能够告诉浏览器这是一个 HTML 文档，并且字符编码是 UTF-8）。有了这个信息，浏览器就能将二进制文件转换成一个可理解的文本文件，如下图所示</p>
<p><img src="%5B%E7%BF%BB%E8%AF%91%5D%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%8E%E6%A0%B7%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%9F%E2%80%94%E2%80%94%20DOM%EF%BC%8CCSSOM%E5%8F%8A%E5%85%B6%E6%B8%B2%E6%9F%93%203a2856637d5f42faa6e8af2b4ce3b433/1_Tm-HPhmGA0BL7HIj38H8Qw.png" alt="%5B%E7%BF%BB%E8%AF%91%5D%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%8E%E6%A0%B7%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%9F%E2%80%94%E2%80%94%20DOM%EF%BC%8CCSSOM%E5%8F%8A%E5%85%B6%E6%B8%B2%E6%9F%93%203a2856637d5f42faa6e8af2b4ce3b433/1_Tm-HPhmGA0BL7HIj38H8Qw.png"></p>
<p>如果这个响应头丢失，那么浏览器将无法对文件进行解析和渲染。当一切就绪，浏览器就可以对 HTML 文档进行解析。HTML 文档的样子通常如下图所示</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Rendering Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">      </div><div class="line">        <span class="comment">&lt;!-- stylesheet --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./style.css"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a sample paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">      </div><div class="line">        <span class="comment">&lt;!-- script --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在上面的 HTML 文档中，网页主要依赖 <code>style.css</code> 文件来给 HTML 元素提供样式，依赖 <code>main.js</code> 来进行一些 JavaScript 脚本代码的执行。有了 CSS 样式，我们的页面看起来会非常棒</p>
<p><img src="%5B%E7%BF%BB%E8%AF%91%5D%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%8E%E6%A0%B7%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%9F%E2%80%94%E2%80%94%20DOM%EF%BC%8CCSSOM%E5%8F%8A%E5%85%B6%E6%B8%B2%E6%9F%93%203a2856637d5f42faa6e8af2b4ce3b433/1_3bFOsAXQPJtczaQcQcVZ1A.png" alt="%5B%E7%BF%BB%E8%AF%91%5D%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%8E%E6%A0%B7%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%9F%E2%80%94%E2%80%94%20DOM%EF%BC%8CCSSOM%E5%8F%8A%E5%85%B6%E6%B8%B2%E6%9F%93%203a2856637d5f42faa6e8af2b4ce3b433/1_3bFOsAXQPJtczaQcQcVZ1A.png"></p>
<p>但我们还是没有聊到重点——浏览器是如何将一个漂亮的页面从一个简单的只充满了文本 HTML 文件渲染出来的呢？接下来我们就聊聊 DOM、CSSOM 和渲染树（Render Tree）。</p>
<h3 id="DOM（Document-Object-Model）"><a href="#DOM（Document-Object-Model）" class="headerlink" title="DOM（Document Object Model）"></a>DOM（Document Object Model）</h3><p>当浏览器解析 HTML 代码时，遇到像 html、body 和 div 等等的标签，会创建一个称作<strong>节点</strong>（Node） 的JavaScript 对象。最终，所有的 HTML 元素都会被转换成这样的节点。</p>
<p>HTML 元素都会有自己不同的属性（properties），相应的，节点对象会从不同的类被构造出来。例如 div 元素会被创建为一个 HTMLDivElement 类的节点实例（继承于 Node 类），如下图</p>
<p><img src="%5B%E7%BF%BB%E8%AF%91%5D%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%8E%E6%A0%B7%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%9F%E2%80%94%E2%80%94%20DOM%EF%BC%8CCSSOM%E5%8F%8A%E5%85%B6%E6%B8%B2%E6%9F%93%203a2856637d5f42faa6e8af2b4ce3b433/1_DmxJT96ZM3ob8TsgCFUJzw.png" alt="%5B%E7%BF%BB%E8%AF%91%5D%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%8E%E6%A0%B7%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%9F%E2%80%94%E2%80%94%20DOM%EF%BC%8CCSSOM%E5%8F%8A%E5%85%B6%E6%B8%B2%E6%9F%93%203a2856637d5f42faa6e8af2b4ce3b433/1_DmxJT96ZM3ob8TsgCFUJzw.png"></p>
<p>浏览器有很多这样内置的类，例如 HTMLDivElement、HTMLScriptElement 和 Node 类等等。</p>
<p>当浏览器解析完 HTML 文档并相应的创建出许多的节点后，还会将这些节点构建成为一个树状结构（如下图）。就想 HTML 文档中元素都是相互嵌套的，浏览器也需要相应的把这些节点构建成类似的嵌套的结构。这种结构会让浏览器更加高效的渲染和操作。</p>
<p><img src="%5B%E7%BF%BB%E8%AF%91%5D%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%8E%E6%A0%B7%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%9F%E2%80%94%E2%80%94%20DOM%EF%BC%8CCSSOM%E5%8F%8A%E5%85%B6%E6%B8%B2%E6%9F%93%203a2856637d5f42faa6e8af2b4ce3b433/1_YSA8lCfCVPn3d6GWAVokrA.png" alt="%5B%E7%BF%BB%E8%AF%91%5D%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%8E%E6%A0%B7%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%9F%E2%80%94%E2%80%94%20DOM%EF%BC%8CCSSOM%E5%8F%8A%E5%85%B6%E6%B8%B2%E6%9F%93%203a2856637d5f42faa6e8af2b4ce3b433/1_YSA8lCfCVPn3d6GWAVokrA.png"></p>
<p>DOM 树的结构就如上图所示。一棵 DOM 树由 html 元素节点开始，其中的其他元素像树枝和叶子一样被层层嵌套（在 HTML 文档解析过程中，每当遇到一个 HTML 元素，就会从相应的节点类中构造出一个 DOM 节点并添加在 DOM 树上）。</p>
<blockquote>
<p>DOM 节点并不总是 HTML 元素。当浏览器构建 DOM 树时，也会将注释、属性（attributes）和文本等保存成树上的节点。为了整个流程的简单描述，文中的节点我们都认为是由 HTML 元素创建的节点。<a href="https://www.w3schools.com/jsref/prop_node_nodetype.asp" target="_blank" rel="external">点击这里</a>查看所有的节点类型。</p>
</blockquote>
<p>你可以在谷歌浏览器的 Devtools 控制台中可视化地查看 DOM 树的层级（如下图）。</p>
<p><img src="%5B%E7%BF%BB%E8%AF%91%5D%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%8E%E6%A0%B7%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%9F%E2%80%94%E2%80%94%20DOM%EF%BC%8CCSSOM%E5%8F%8A%E5%85%B6%E6%B8%B2%E6%9F%93%203a2856637d5f42faa6e8af2b4ce3b433/1_Uo2wfq060OMSLyTTCm2zFw.png" alt="%5B%E7%BF%BB%E8%AF%91%5D%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%8E%E6%A0%B7%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%9F%E2%80%94%E2%80%94%20DOM%EF%BC%8CCSSOM%E5%8F%8A%E5%85%B6%E6%B8%B2%E6%9F%93%203a2856637d5f42faa6e8af2b4ce3b433/1_Uo2wfq060OMSLyTTCm2zFw.png"></p>
<p>JavaScript 是无法理解 DOM 是什么东西的。DOM 是浏览器为了搞笑渲染网页而向开发者暴露的 Web API，让开发者可以动态的去操作这些 DOM 元素。</p>
<blockquote>
<p>开发者能够使用 DOM API 来进行 HTML 元素的添加和删除，改变其样式，为其绑定一些事件监听器。使用 DOM API 还能够在内存中人工创建和复制一些 HTML 元素，而不受已经渲染好的 DOM 树的影响。这些特性都让开发者为了提升用户体验而更好地开发动态网页。</p>
</blockquote>
<h3 id="CSSOM（CSS-Object-Model）"><a href="#CSSOM（CSS-Object-Model）" class="headerlink" title="CSSOM（CSS Object Model）"></a>CSSOM（CSS Object Model）</h3><p>在设计一个网页时，我们会尽可能地让网页看起来更加美观。我们会在 HTML 元素中添加 CSS 样式来达到此目的。CSS 选择器让我们能够对选定的 DOM 元素设置类似 color 或 font-size 等的样式属性。</p>
<p>为元素添加样式有很多方法，有直接向 HTML 元素中添加样式（内联样式），或在 HTML 文档中添加 <style> 标签并在其中添加一些样式，也可以引入一个外部的 CSS 文件。最终，将 CSS 样式添加到 DOM 元素这个重担还是要落在浏览器身上。</p>
<p>针对上面提供的 HTML 文档，我们采用下面的 CSS 样式来进行美化。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">html</span> &#123;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">body</span> &#123;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</div><div class="line">    <span class="attribute">color</span>: black;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-tag">h1</span> &#123;</div><div class="line">    <span class="attribute">color</span>: gray;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-tag">p</span> &#123;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</div><div class="line">    <span class="attribute">display</span>: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DOM 树构建完成后，浏览器将读取资源（外部的、内联的、HTML文档中的和用户代理）中的 CSS 样式文件，并构建出一个 CSSOM 树。CSSOM 意为 CSS Object Model，就和 DOM 树一样都是树结构。</p>
<p>在 CSSOM 树上，每一个节点都是针对一个 DOM 元素所包含的样式。而且，CSSOM 树不像 DOM 树（<meta>、<script>等）一样能够被打印在屏幕上。</p>
<p>用户代理样式，是大部分浏览器自带的一些样式表。浏览器在计算 CSS 样式属性时，会首先加载用户代理样式，然后会将开发人员提供的样式表（根据一定的 CSS 优先级规律）进行覆盖，来构造出每一个节点。</p>
<p>即使有的 HTML 元素没有用户代理和开发者提供特定样式，样式的默认值也会根据 W3C CSS 标准进行默认赋值。而一些元素的属性也会继承逐步继承这些默认的属性值。</p>
<p>例如，color 和 font-size 属性如果没有进行任何值的指定，他们会继承父元素的属性值。所以我们能够想象这些样式都是一层层进行继承和覆盖。这就是为什么样式表被称之为 CSS（cascading style sheets），这种规则也是浏览器能构建出 CSSOM 树的原因。</p>
<blockquote>
<p>你能使用谷歌浏览器的 DevTools 控制台的 Elements 面板，在左侧选中一个 HTML 元素，点击后能够在右侧的 computed 面板中看到相应的样式计算结果。</p>
</blockquote>
<p>我们将之前例子中的 CSSOM 树可视化为下面的图表。</p>
<p><img src="%5B%E7%BF%BB%E8%AF%91%5D%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%8E%E6%A0%B7%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%9F%E2%80%94%E2%80%94%20DOM%EF%BC%8CCSSOM%E5%8F%8A%E5%85%B6%E6%B8%B2%E6%9F%93%203a2856637d5f42faa6e8af2b4ce3b433/1_DJg1yRx-AzkZposWbJKcaA.png" alt="%5B%E7%BF%BB%E8%AF%91%5D%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%8E%E6%A0%B7%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%9F%E2%80%94%E2%80%94%20DOM%EF%BC%8CCSSOM%E5%8F%8A%E5%85%B6%E6%B8%B2%E6%9F%93%203a2856637d5f42faa6e8af2b4ce3b433/1_DJg1yRx-AzkZposWbJKcaA.png"></p>
<p>如上图所示，CSSOM 树是不包含能够打印出来的元素和标签的。上面红色的 CSS 属性和值就是从 body 元素上面的样式继承而来的，而 h1 标签的 color 属性则覆盖了其父元素 div 中的 color 属性。</p>
<h3 id="Render-Tree"><a href="#Render-Tree" class="headerlink" title="Render Tree"></a>Render Tree</h3><p>渲染树也是一个树形结构，它结合了 DOM 树和 CSSOM 树。浏览器接下来需要计算每一个可见元素的布局并将其绘制在屏幕上，为了达到这一目的，浏览器需要用到 Render Tree。而 Render Tree 又是由 Dom 和 CSSOM 树得到的。</p>
<p>由于渲染树是能最终在屏幕上打印出的底层表示，<strong>它不会包含任何不包含像素矩阵面积的节点</strong>——例如使用了 <code>display: none</code> 样式的元素，这样的元素是不会出现在渲染树上的。</p>
<p><img src="%5B%E7%BF%BB%E8%AF%91%5D%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%8E%E6%A0%B7%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%9F%E2%80%94%E2%80%94%20DOM%EF%BC%8CCSSOM%E5%8F%8A%E5%85%B6%E6%B8%B2%E6%9F%93%203a2856637d5f42faa6e8af2b4ce3b433/1_8HnhiojSoPaJAWkruPhDwA.png" alt="%5B%E7%BF%BB%E8%AF%91%5D%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%8E%E6%A0%B7%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%9F%E2%80%94%E2%80%94%20DOM%EF%BC%8CCSSOM%E5%8F%8A%E5%85%B6%E6%B8%B2%E6%9F%93%203a2856637d5f42faa6e8af2b4ce3b433/1_8HnhiojSoPaJAWkruPhDwA.png"></p>
<p>如上图所示，渲染树结合了 DOM 树和 CSSOM 树来构建出一个树形结构，这个树结构只包含能够最终绘制在屏幕上的元素。</p>
<p>上面代码中的 p 元素由于被设置了 <code>display: none</code> 样式，所以这个元素以及该元素的子元素都不会呈现在渲染树中，因为它不占任何屏幕空间。但是有一些例外，比如被设置了 <code>visibility:hidden</code> or <code>opacity:0</code> 样式的元素，他们虽然没有占据任何屏幕空间，但是仍然会被添加到渲染树上。</p>
<p>和 DOM API 能够让开发者去操控 DOM 元素不同，CSSOM 是被隐藏起来的，但由于渲染树结合了两者，所以浏览器通过提供高级的 DOM 上的 API 来暴露出 CSSOM 节点，这让开发者能够去操作和修改 CSSOM 节点的 CSS 属性。</p>
<blockquote>
<p>本文不讨论怎样使用 JavaScript 脚本去操作元素的样式，这里仅提供描述了 CSSOM API 的链接 <a href="https://css-tricks.com/an-introduction-and-guide-to-the-css-object-model-cssom/">CSS Tricks Article</a>。<a href="https://developers.google.com/web/updates/2018/03/cssom">CSS Typed Object</a> 一文提供了在 JavaScript 中更精确地操作元素样式属性的 API。</p>
</blockquote>
<h2 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h2><p>现在我们对 DOM，CSSOM 以及渲染树都有了一定的了解，接下来我们将揭露浏览器如何对一个网页进行渲染。对这个流程有一个简单的了解会让网站开发者提升网站的用户体验有极大的作用。</p>
<p>当一个页面加载时，浏览器首先会扫描 HTML 文档并构建出 DOM 树，然后会处理 CSS 文件（无论是内联还是外部的文件）并构建出 CSSOM 树。</p>
<p>当 DOM 树和 CSSOM 树构建出来之后，浏览器会结合两者来构建出渲染树。一旦渲染树构建完成，浏览器就能把每一个元素绘制在屏幕上。</p>
<h3 id="布局（layout）"><a href="#布局（layout）" class="headerlink" title="布局（layout）"></a>布局（layout）</h3><p>首先，浏览器会计算出每一个渲染树节点的布局。这里所说的布局包括这个节点的像素大小、以及绘制位置。这个过程被称作“布局（layout）“，有些时候也会被称作是回流（reflow）或浏览器回流（browser reflow）。回流是在用户进行滚动、缩放浏览器或操作 DOM 元素时会触发的。<a href="https://stackoverflow.com/a/27637245/2790983">这里</a>列举了一系列能够触发回流的事件和操作。</p>
<blockquote>
<p>我们应当避免网页出现过多的布局和回流，因为这是一个极其消耗性能的操作。Paul Lewis 的<a href="https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing">文章</a>讲述了一些如何避免复杂和消耗性能的操作。<a href="https://kellegous.com/j/2013/01/26/layout-performance/">Layout thrashing</a> 一文也可供参考。</p>
</blockquote>
<h3 id="绘制（paint）"><a href="#绘制（paint）" class="headerlink" title="绘制（paint）"></a>绘制（paint）</h3><p>目前我们已经有了一系列需要打印在屏幕上的文字和图案。由于渲染树上的元素有可能会彼此覆盖，甚至会有一些 CSS 属性让这些元素频繁的更改样式、位置等（例如动画），浏览器为此创建了图层（layer）。</p>
<p>图层让浏览器能够高效地进行绘制，无论是在网页上滑动还是缩放浏览器窗口。图层也能帮助浏览器正确地把元素以层叠的方式（开发者所需要的）进行绘制。</p>
<p>现在浏览器能够结合图层，将元素绘制在屏幕上了。但是，浏览器是不会一次性把所有图层绘制出来的，每一个图层都是有先后的绘制顺序。</p>
<p>在每一层中，浏览器会填充每一个可见属性的像素点（例如边框、背景颜色、阴影和文字等）。这个过程也被称作栅格化。为了提升性能，浏览器会使用不同的线程来进行栅格化操作。</p>
<p>这里的图层就像是 Photoshop 软件中的图层。你可以在 Chrome DevTools 中查看每一个不同的图层。打开 Chrome DevTools，在 more tools 选项中选择 Layers 标签。能够在 Rendering 面板上看到每一个层的边界。</p>
<blockquote>
<p>栅格化一般都是由 CPU 来执行的，所以速度慢且成本高，但是现在出现的 GPU 技术能够很大程度提升这一步骤的性能。这篇 <a href="https://software.intel.com/en-us/articles/software-vs-gpu-rasterization-in-chromium">intel article</a> 文章详细概括了绘制流程（尽量去阅读它！）。为了能够更加深入地理解图层，你需要查看<a href="https://www.html5rocks.com/en/tutorials/speed/layers/">这篇文章</a>。</p>
</blockquote>
<h3 id="渲染层合并（compositing-operation）"><a href="#渲染层合并（compositing-operation）" class="headerlink" title="渲染层合并（compositing operation）"></a>渲染层合并（compositing operation）</h3><p>到现在，我们还没有在屏幕上绘制出任何一个元素。但是我们现在有了能够按照一定顺序绘制在屏幕上的一系列不同的图层。在渲染层合并这个流程里，这些图层将被送往 GPU 进行最终的绘制。</p>
<p>将所有的图层一起进行传输显然是低效的，因为每一次回流和重绘都需要全部发送一遍。所以每一个图层都被拆解为不同的块（tiles），这些块才是能够最终被绘制在屏幕上的单元。在 Chrome DevTools 的 Rendering 面板中也能够看到这些块。</p>
<p><img src="%5B%E7%BF%BB%E8%AF%91%5D%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%8E%E6%A0%B7%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%9F%E2%80%94%E2%80%94%20DOM%EF%BC%8CCSSOM%E5%8F%8A%E5%85%B6%E6%B8%B2%E6%9F%93%203a2856637d5f42faa6e8af2b4ce3b433/1_yQJkz12sPxS-kJoMDqzbEQ.png" alt="%5B%E7%BF%BB%E8%AF%91%5D%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%8E%E6%A0%B7%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%9F%E2%80%94%E2%80%94%20DOM%EF%BC%8CCSSOM%E5%8F%8A%E5%85%B6%E6%B8%B2%E6%9F%93%203a2856637d5f42faa6e8af2b4ce3b433/1_yQJkz12sPxS-kJoMDqzbEQ.png"></p>
<p>上面画出了目前为止的所有渲染流程，也被称作 <a href="https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path">critical rendering path</a> 。</p>
<blockquote>
<p>Mariko Kosaka 写过<a href="https://developers.google.com/web/updates/2018/09/inside-browser-part3">一篇文章</a>来详细讲述这一流程中的每一个概念（极力推荐）</p>
</blockquote>
<h3 id="浏览器引擎"><a href="#浏览器引擎" class="headerlink" title="浏览器引擎"></a>浏览器引擎</h3><p>DOM 树、CSSOM 树以及控制整个渲染的逻辑都是在一个被叫做浏览器内置的浏览器引擎（<a href="https://en.wikipedia.org/wiki/Browser_engine">Browser Engine</a>)（也被称作是渲染引擎或布局引擎）。这个浏览器引擎包含了所有将 HTML 文档渲染成为屏幕上的像素点所必须的元素和逻辑。</p>
<p>你听说过 WebKit 吗，这就是一个浏览器引擎。WebKit 是在苹果的 Safari 浏览器中，也是之前谷歌 Chrome 浏览器默认的渲染引擎。现在 Chromium 项目已经开始用 Blink 作为 Chrome 浏览器默认的引擎。<a href="https://stackoverflow.com/questions/3468154/what-is-webkit-and-how-is-it-related-to-css/3468311#3468311">这是</a>一系列不同的浏览器对应的引擎。</p>
<h2 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h2><p>众所周知 JavaScript 是一种符合 ECMAScript 标准的语言，事实上由于 JavaScript 已经被注册为商标，我们现在都称其为 ECMAScript。所以，任何一种 JavaScript 引擎（包括 V8，Chakra，SpiderMonkey）都需要遵守这一标准。</p>
<p>这一标准让所有的 JavaScript 运行时环境（浏览器、Node、Deno等）一致的体验。这让 JavaScript 能够在多平台进行统一的应用开发。</p>
<p>然而浏览器渲染页面却很难提现这样的一致性，因为 HTML、CSS 和 JavaScript，这些语言都有自己独有的标准。所以 Chrome 和 Safari 浏览器在渲染流程上就有所不同。因此我们很难去预测不同浏览器背后所支持的渲染流程。但是 HTML5 规范对理论上如何渲染做出了一些努力，但是是否遵循这一规范不同的浏览器厂家也各有不同。</p>
<p>不管上面所提到的不同点，所有的浏览器在渲染过程其实遵循的规则大体上通常是一致的。我们这里就来了解一下浏览器渲染流程周期中共通的一些事件。为了更好地理解这个过程，下面准备了一个小的工程来测试不同的渲染场景。</p>
<p><a href="https://github.com/course-one/browser-rendering-test/tree/master">course-one/browser-rendering-test</a></p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>文档解析是扫描 HTML 文档内容并构建 DOM 树的一个过程。所以这个解析也被称作是 DOM 解析，执行解析的程序被称作 DOM 解析器。</p>
<p>大多数浏览器都会提供 DOMParser Web API 来将 HTML 文档构建成 DOM 树。一个 DOMParser 类的实例代表一个 DOM 解析器，这个解析器使用 parseFromString 原型方法来将 HTML 文本解析成 DOM 树结构。</p>
<p><img src="%5B%E7%BF%BB%E8%AF%91%5D%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%8E%E6%A0%B7%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%9F%E2%80%94%E2%80%94%20DOM%EF%BC%8CCSSOM%E5%8F%8A%E5%85%B6%E6%B8%B2%E6%9F%93%203a2856637d5f42faa6e8af2b4ce3b433/1_DTO0PBRawrEdZakWloQVjg.png" alt="%5B%E7%BF%BB%E8%AF%91%5D%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%8E%E6%A0%B7%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%9F%E2%80%94%E2%80%94%20DOM%EF%BC%8CCSSOM%E5%8F%8A%E5%85%B6%E6%B8%B2%E6%9F%93%203a2856637d5f42faa6e8af2b4ce3b433/1_DTO0PBRawrEdZakWloQVjg.png"></p>
<p>当浏览器向服务器请求并返回了一个 HTML 文档时，浏览器就可以开始解析这个文档。因此浏览器能够逐步地构建 DOM 树，一次构建一个节点。浏览器是从上到下地扫描 HTML 文档。</p>
<p><img src="https://miro.medium.com/max/1242/1*1bcaVVjG_077zHVzGfHUyw.gif" alt="https://miro.medium.com/max/1242/1*1bcaVVjG_077zHVzGfHUyw.gif"></p>
<p>上图展示了在 Node 服务器上以 10kbps 的速度请求 incremental.html 文件。因为这个请求获取文件的过程需要很长一段时间，浏览器加载这个文件从一开始的一小部分代码就能够不断地增量渲染出节点。</p>
<p>如果你在 Chrome DevTools 中的 Performance 面板中查看上述请求，能够看到每一步流程的时序。这些事件都被称作是性能指标，当这些事件能靠的很近，那么说明用户体验会很好。</p>
<blockquote>
<p>使用⟳按钮可以将某一个性能档案进行捕捉。</p>
</blockquote>
<p>FP 代表着 First Paint，意思是浏览器开始绘制。FCP 代表着 First Contentful Paint，意思是浏览器开始绘制第一个像素点。LCP 代表着 Largest Contentful Paint，意思是浏览器渲染一大块文本或图像的时间。</p>
<blockquote>
<p>你可能听过 FMP，代表着 First Meaningful Paint，与 LCP 指标类似，但是已经被 Chrome 弃用了。</p>
</blockquote>
<p>L 代表着 onload 事件（浏览器在 window 对象上所触发的事件）。DCL 代表着 DOMContentLoaded 事件（在 document 对象上触发但是会冒泡到 window 对象）。因此可以监听 window 对象。这些事件有一些复杂，我们会简单介绍一下。</p>
<p>每当浏览器扫描到了外部的资源，比如一些 <script> 标签标示的脚本文件（JavaScript文件）或 <link> 引入的样式文件，亦或是图片元素，浏览器会开始在后台下载这些资源（而不是 JavaScript 执行的主线程）。</p>
<p>最重要的一点是要记住——DOM解析通常是在主线程上进行的。所以当 JavaScript 主线程忙时，DOM 解析会被挂起直到线程空闲。为什么 JavaScript 会阻塞 DOM 的解析？那是因为脚本元素是解析阻塞的（脚本会影响 DOM 树的生成），而样式表、图片、pdf和视频等静态资源文件则不会阻塞。</p>
<h3 id="阻塞解析脚本"><a href="#阻塞解析脚本" class="headerlink" title="阻塞解析脚本"></a>阻塞解析脚本</h3><p>阻塞解析脚本指的是会让 HTML 文档解析阻塞的脚本文件。当浏览器遇到 script 标签时，如果是嵌入式脚本，脚本会被立即执行然后再继续解析 HTML 文档来构建 DOM 树。</p>
<p>如果遇到的 script 标签是一个引入的外部脚本文件，浏览器会在后台非主线程上开始下载这个脚本文件，在下载过程中，主线程的任务也是被暂时挂起的。在外部脚本没有下载完成之前，DOM 解析不会开始。</p>
<p>一旦脚本文件下载完成，浏览器会在首先主线程上执行这个脚本文件，然后开始 DOM 解析。浏览器再遇到相同的脚本标签，也会重复这一过程。为啥要这么做呢？这是因为浏览器将 DOM API 暴露给 JavaScript 运行时，这意味着我们可以使用 JavaScript 脚本来操控 DOM 元素。这也是 React 和 Angular 这些框架能够动态改变网页的原因。但是如果浏览器并行地解析 DOM 和执行脚本，可能会存在条件竞争漏洞（不知道到底哪个最终会影响 DOM 树的生成）。</p>
<p>但是很显然，在脚本下载的过程中暂停 DOM 的解析也是非常没有必要的，所以 HTML5 为 script 标签新增了 async 属性——当浏览器遇到了带有 async 属性的 script 标签，不会暂停解析过程并在后台下载脚本文件，但是当文件下载完成，解析过程会被挂起直到脚本被执行完。</p>
<p>另外，HTML5 还提供了 defer 属性，有点类似 async 属性，不同的是这种脚本在下载完成之后也不会立即执行。所有带 defer 属性的 script 标签，都会在后台并行下载，等到 HTML 解析完成，DOM 树构建完成，这些脚本才会被执行。</p>
<p>所有其他正常的 script 标签代表的脚本，都是阻塞解析的脚本。所有 async 脚本都是下载期间不阻塞解析，下载完成后阻塞解析。而 defer 脚本是无论如何都不会阻塞 DOM 解析的。</p>
<p><img src="https://miro.medium.com/max/1230/1*5xdQ1j6Ai2PZYCRQuXM5wg.gif" alt="https://miro.medium.com/max/1230/1*5xdQ1j6Ai2PZYCRQuXM5wg.gif"></p>
<p>上图中的例子，是 parser-blocking.html 文件，其中包含了30个元素之后的解析阻塞脚本。如果我们看一眼 Performance 面板，其中 FP 和 FCP 都是在 HTML 准备完成尽可能早的开始构建 DOM 树。LCP 在5秒之后开始，这是因为脚本阻塞了 DOM 解析（下载时间），只有30个文本元素被绘制出来。一旦脚本下载和执行完成，DOM 解析便会重新开始。</p>
<blockquote>
<p>解析阻塞也被称为渲染阻塞，因为此时渲染也不会进行（渲染需要依赖渲染树，而渲染树依赖 DOM 树）。但是两者还是有一些不同的。</p>
</blockquote>
<p>Some browsers may incorporate a <strong><a href="https://developer.mozilla.org/en-US/docs/Glossary/speculative_parsing">speculative parsing</a></strong> strategy where the HTML parsing (<em>but not the DOM tree construction</em>) is offloaded to a separate thread so that browser can read elements such as <code>link</code>(<em>CSS</em>), <code>script</code>, <code>img</code>, etc. and download these resources <strong>eagerly</strong>.</p>
<p>This is quite helpful if you have three <code>script</code> elements one after the other, but the browser won’t be able to start the download of the second script until the first script is downloaded as the DOM parser couldn’t read the second <code>script</code> element. We can fix this easily by using <code>async</code> tag but asynchronous scripts are not guaranteed to execute in order.</p>
<p>The reason it is called speculative parsing because the browser is making a <strong>speculation</strong> that a particular resource is expected to load in the future, so better load it now in the background. However, if some JavaScript manipulates DOM and removes/hides the element with an external resource, then speculation fails and these files were loaded for nothing. Tough.</p>
<blockquote>
<p>💡 Every browser has a mind of its own, so when or if speculative parsing will happen is not guaranteed. However, you can ask the browser to load some resources ahead of time using the <link rel="preload"> element.</p>
</blockquote>
<h3 id="渲染阻塞-CSS"><a href="#渲染阻塞-CSS" class="headerlink" title="渲染阻塞 CSS"></a>渲染阻塞 CSS</h3><p>我们了解了，任何除了解析阻塞脚本之外的外部资源请求都是不会阻塞 DOM 解析和树构建的。所以 CSS 并不会阻塞 DOM 解析，等一下，<strong>其实是会阻塞的</strong>。为了理解这一点，我们需要了解渲染的过程。</p>
<p>DOM 和 CSSOM 树的构建都是在主线程上的，而且这些树时并行进行构建的。它们一起构建出了渲染树，用来绘制元素。这一过程其实也是<strong>跟随着 DOM 树的增量构建进行</strong>的。</p>
<p>上面谈到 DOM 树的生成时增量生成的（并非一下子生成），也就是浏览器一边解析 HTML 文件，一遍在 DOM 树上增加节点。<strong>但是 CSSOM 可不是这样</strong>——CSSOM 树的构建并不是增量构建的。</p>
<p>当浏览器遇到 style 嵌入代码块时，它会扫描所有的 CSS 代码，并依据相应的规则更新 CSSOM 树。然后，它会继续解析 HTML 文档，内联的样式也是一样的。</p>
<p>但是外部的样式表就有所不同了。我们知道外部样式表不是解析阻塞资源，所以它能够在后台与 DOM 解析并行地进行下载。但是与脚本不同，浏览器不会在外部样式表下载完后第一时间进行解析，这是因为<strong>浏览器无法一边扫描 CSS 文件一边构建 CSSOM 树</strong>。原因很简单：CSS 的规则表明，越后面的样式属性，越有可能覆盖前面的属性。一但浏览器增量地生成 CSSOM 树，那么会产生多个渲染树，这会造成很差的体验。</p>
<p>所以浏览器不会增量地生成 CSSOM 树，而是 CSS 文件全部扫描完后才生成完整的 CSSOM。一旦 CSSOM 树生成后，渲染树才会更新并绘制。</p>
<p>CSS 是渲染阻塞资源。一旦浏览器去请求一个外部的样式表文件，渲染树的构建就会暂停（因为渲染树依赖 CSSOM树），因此 CRP（Critical Rendering Path）也会阻塞。但是，DOM 树还是会进行解析。</p>
<p><img src="https://miro.medium.com/max/1232/1*y3QmSfyergjmVV32nH7tPA.gif" alt="https://miro.medium.com/max/1232/1*y3QmSfyergjmVV32nH7tPA.gif"></p>
<p>A browser <strong>could have</strong> used an older state of the CSSOM tree to generate <strong>Render Tree</strong> as HTML is getting parsed to render things on the screen incrementally. But this has a huge downside. In this case, once the stylesheet is downloaded and parsed, and CSSOM is updated, Render Tree will be updated and rendered on the screen. Now the Render Tree nodes generated with older CSSOM will be <strong>repainted with new styles</strong> and it could also lead to <strong><a href="https://webkit.org/blog/66/the-fouc-problem/">Flash of Unstyled Content</a></strong> (<em>FOUC</em>) which is is very bad for UX.</p>
<p>Hence browsers will wait until the stylesheet is loaded and parsed. Once the stylesheet is parsed and CSSOM is updated, the Render Tree is updated, and <strong>CRP is unblocked</strong> which leads to the paint of Render Tree on the screen. Due to this reason, it is recommended to load all external stylesheets as early as possible, possibly in the <code>head</code> section.</p>
<p>Let’s imagine a scenario where the browser has started parsing HTML and it encounters an external stylesheet file. It will start the download of the file in the background, block the CRP, and continue with the DOM parsing. But then it encounters a <code>script</code> tag. So it will start the download of the external script file and block the DOM parsing. Now the browser is sitting idle waiting for the stylesheet and script file to download completely.</p>
<p>But this time, the external script file has been <strong>downloaded completely</strong> while the stylesheet is still being downloaded in the background. Should the browser execute the script file? Is there any harm doing that?</p>
<p>As we know, CSSOM provides a high-level JavaScript API to interact with the <strong>styles</strong> of the DOM elements. For example, you can read or update the background color of a DOM element using <code>elem.style.backgroundColor</code> property. The <code>style</code> object associated the <code>elem</code> element exposes the CSSOM API and there are many other APIs to do the same (<em>read this <a href="https://css-tricks.com/an-introduction-and-guide-to-the-css-object-model-cssom/">css-tricks article</a></em>).</p>
<p>As a stylesheet is being downloaded background, JavaScript can still execute as the main thread is not being blocked by the loading stylesheet. If our JavaScript program accesses CSS properties of a DOM element (<em>through CSSOM API</em>), we will get a proper value (<em>as per the current state of CSSOM</em>).</p>
<p>But once the stylesheet is downloaded and parsed, which leads to CSSOM update, our JavaScript now has a bad CSS value of the element since the new CSSOM update could have changed the CSS properties of that DOM element. Due to this reason, it’s not safe to execute JavaScript while the stylesheet is being downloaded.</p>
<p>As per the <strong><a href="https://html.spec.whatwg.org/multipage/semantics.html#interactions-of-styling-and-scripting">HTML5 specification</a></strong>, the browser may download a script file but it will not execute it unless all previous stylesheets are parsed. When a stylesheet blocks the execution of a script, it is called a <strong>script-blocking</strong> stylesheet or a <strong>script-blocking</strong> CSS.</p>
<p><img src="https://miro.medium.com/max/1232/1*atsh0R6Do25SriYvvskkgA.gif" alt="https://miro.medium.com/max/1232/1*atsh0R6Do25SriYvvskkgA.gif"></p>
<p>In the above example, the <code>[script-blocking.html](https://github.com/course-one/browser-rendering-test/blob/master/html/script-blocking.html)</code> contains a <code>link</code> tag (<em>for an external stylesheet</em>) followed by a <code>script</code> tag (<em>for an external JavaScript</em>). Here the script gets downloaded really fast without any delay but the stylesheet takes 6 seconds to download. Hence, even though the script is downloaded completely as we can see from the <strong>Network</strong> panel, it wasn’t executed by the browser immediately. Only after the stylesheet is loaded, we see the <code>Hello World</code> messaged logged by the script.</p>
<blockquote>
<p>💡 Like async or defer attribute makes script element non-parser-blocking, an external stylesheet can also be marked as non-render-blocking using the media attribute. Using the media attribute value, the browser can make a smart decision when to load the stylesheet.</p>
</blockquote>
<h2 id="Document’s-DOMContentLoaded-Event"><a href="#Document’s-DOMContentLoaded-Event" class="headerlink" title="Document’s DOMContentLoaded Event"></a><strong>Document’s <code>DOMContentLoaded</code> Event</strong></h2><p>The <code>[DOMContentLoaded](https://developer.mozilla.org/en-US/docs/Web/API/Document/DOMContentLoaded_event)</code> (<strong><em>DCL</em></strong>) event marks a point in time when the browser has constructed a complete DOM tree from all the available HTML. But there are a lot of factors involved that can change when the <code>DCL</code> event is fired.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">document.addEventListener( &apos;DOMContentLoaded&apos;, function(e) &#123;</div><div class="line">    console.log( &apos;DOM is fully parsed!&apos; );</div><div class="line">&#125; );</div></pre></td></tr></table></figure>
<p>If our HTML doesn’t contain any scripts, DOM parsing won’t get blocked and <code>DCL</code> will fire as quickly as the browser can parse the entire HTML. If we have parser-blocking scripts, then <code>DCL</code> has to wait until all parser-blocking scripts are downloaded and executed.</p>
<p>Things get a little complicated when stylesheets are thrown into the picture. Even though you have no external scripts, <code>DCL</code> will wait until all stylesheets are loaded. Since <code>DCL</code> marks a point in time when the entire DOM tree is ready, but DOM won’t be safe to access (<em>for the style information</em>) unless CSSOM is also fully constructed. Hence most browsers wait until all external stylesheets are loaded and parsed.</p>
<p>Script-blocking stylesheet will obviously delay the <code>DCL</code>. In this case, since the script is waiting for the stylesheet to load, the DOM tree is not getting constructed.</p>
<p><code>DCL</code> is one of the website performance metrics. We should optimize the <code>DCL</code> to be as small as possible (<em>the time at which it occurs</em>). One of the best practices is to use <code>defer</code> and <code>async</code> tag for <code>script</code> element whenever possible so that browser can perform other things while scripts are being downloaded in the background. Second, we should optimize the <strong>script-blocking</strong> and <strong>render-blocking</strong> stylesheets.</p>
<h2 id="Window’s-load-event"><a href="#Window’s-load-event" class="headerlink" title="Window’s load event"></a><strong>Window’s <code>load</code> event</strong></h2><p>As we know JavaScript can block DOM tree generation but that’s not the case with external stylesheets and files such as images, videos, etc.</p>
<p>The <code>DOMContentLoaded</code> event marks a point in time when the DOM tree is fully constructed and it is safe to access, the <code>window.onload</code> event marks a point in time when external stylesheets and files are downloaded and our web application (<em>complete</em>) has finished downloading.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">window.addEventListener( &apos;load&apos;, function(e) &#123;</div><div class="line">  console.log( &apos;Page is fully loaded!&apos; );</div><div class="line">&#125; )</div></pre></td></tr></table></figure>
<p><img src="https://miro.medium.com/max/1368/1*DuLBecXpJjFh1qnakXjWWg.png" alt="https://miro.medium.com/max/1368/1*DuLBecXpJjFh1qnakXjWWg.png"></p>
<p>In the above example, the <code>[rendering.html](https://github.com/course-one/browser-rendering-test/blob/master/html/rendering.html)</code> file has an external stylesheet in the <code>head</code> that takes around 5 seconds to download. Since it’s in the <code>head</code> section, the <code>FP</code> and <code>FCP</code> occurs after 5 seconds since the stylesheet will block the rendering of any content below it (<em>as it blocks CRP</em>).</p>
<p>After that, we have an <code>img</code> element that loads an image that takes around 10 seconds to download. So the browser will keep downloading this file in the background and move on with the DOM parsing and rendering (<em>as an external image resource is neither parser-blocking nor render-blocking</em>).</p>
<p>Next, we have three external JavaScript files and they take 3s, 6s, and 9s to download respectively and most importantly, they are not <code>async</code>. This means the total load time should be close to <strong>18 seconds</strong> as the subsequent script won’t start downloading before the previous one is executed. However, looking at the <code>DCL</code> event, our browser seemed to have used the <strong>speculative strategy</strong> to eagerly download the script files so the total time to load is close to <strong>9 seconds</strong>.</p>
<p>Since the last file to download that can affect the <code>DCL</code> is the last script file with the load time of <strong>9 seconds</strong> (<em>since stylesheet has already been downloaded in 5 seconds</em>), the <code>DCL</code> event occurs around <strong>9.1 seconds</strong>.</p>
<p>We also had another external resource which was the image file and it kept loading in the background. Once it was fully downloaded (<em>which takes 10 seconds</em>), the window’s <code>load</code> event was fired after <strong>10.2 seconds</strong> which marks that the webpage (<em>application</em>) is fully loaded.</p>
</style></p>
        
        </div>

        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://keefe.wang/2020/08/13/2020-08-13-translate-how-browser-renders-webpage.html" data-id="ckk6vuawf004zow901aec09aj" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
    
</article>

        
            <article id="post-2020-07-29-use-vue-test-utils-to-test-components" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        <div class="article-corner"></div>
        

        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2020/07/29/2020-07-29-use-vue-test-utils-to-test-components.html">使用 vue-test-utils 进行测试</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2020/07/29/2020-07-29-use-vue-test-utils-to-test-components.html">
            <time datetime="2020-07-29T14:23:00.000Z" itemprop="datePublished">2020-07-29</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Document/">Document</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>, <a class="tag-link" href="/tags/Test/">Test</a>, <a class="tag-link" href="/tags/Vue/">Vue</a>
    </div>

                    </div>
                
            </header>
        

        

        <div class="article-entry" itemprop="articleBody">

        
            
            <h3 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h3><p>我们使用 Vue CLI 脚手架进行项目的创建，按照提示一步步进行项目配置，尽量都选择无任何配置，尤其是自带的测试插件：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vue create vue-test</div></pre></td></tr></table></figure>
<p>新建好项目之后，我们需要在项目根目录下<strong>新建一个 test 目录</strong>来放置我们的测试文件。</p>
<p>由于我们是在 Vue 项目中进行测试，采用的是 vue-test-utils 这个测试工具插件进行测试，所以下面几类 npm 插件是必须要安装的：</p>
<ul>
<li><p>jest 相关</p>
<p>  jest 是 vue-test-utils 官方推荐的测试运行器，所以这个插件是必要的；要使用 jest 来处理 *.vue 文件，需要安装和配置 vue-jest 插件。</p>
  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i --save-dev jest vue-jest</div></pre></td></tr></table></figure>
  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在 package.json 中做如下配置</span></div><div class="line">&#123;</div><div class="line">	<span class="string">"scripts"</span>: &#123;</div><div class="line">		<span class="string">"test"</span>: <span class="string">"jest"</span></div><div class="line">	&#125;,</div><div class="line">	<span class="string">"jest"</span>: &#123;</div><div class="line">    <span class="string">"moduleFileExtensions"</span>: [</div><div class="line">      <span class="string">"js"</span>,</div><div class="line">      <span class="string">"json"</span>,</div><div class="line">      <span class="string">"vue"</span></div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>babel 相关</p>
<p>  我们一般都不可避免地希望在代码中使用 ES2015 的特性，这时我们需要安装 babel 相关的插件，其中 babel-jest 是测试中的 ES2015 特性编译的插件</p>
  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev babel-core babel-preset-env babel-jest</div></pre></td></tr></table></figure>
  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在 package.json 中做如下配置</span></div><div class="line">&#123;</div><div class="line">	<span class="string">"jest"</span>: &#123;</div><div class="line">		<span class="string">"transform"</span>: &#123;</div><div class="line">      <span class="string">".*\\.(vue)$"</span>: <span class="string">"vue-jest"</span>,</div><div class="line">      <span class="string">"^.+\\.js$"</span>: <span class="string">"&lt;rootDir&gt;/node_modules/babel-jest"</span></div><div class="line">    &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 在 .babelrc 或 babel.config.js 文件中做如下配置</span></div><div class="line">&#123;</div><div class="line">  <span class="string">"presets"</span>: [[<span class="string">"env"</span>, &#123; <span class="string">"modules"</span>: <span class="literal">false</span> &#125;]],</div><div class="line">  <span class="string">"env"</span>: &#123;</div><div class="line">    <span class="string">"test"</span>: &#123;</div><div class="line">      <span class="string">"presets"</span>: [[<span class="string">"env"</span>, &#123; <span class="string">"targets"</span>: &#123; <span class="string">"node"</span>: <span class="string">"current"</span> &#125; &#125;]]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>vue-test-utils 依赖浏览器环境，我们使用 JSDOM 在 Node 虚拟浏览器环境运行测试。jest 中有自动设置 JSDOM，如果没有，需要安装以下插件</p>
  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev jsdom jsdom-global</div></pre></td></tr></table></figure>
</li>
</ul>
<p>至此，所以前期的插件安装和配置工作就完成了。这时，我们在 test 目录下新建一个 *.test.js 文件，并在 terminal 中运行 npm run test 命令，就可以进行 vue 组件的测试了。</p>

        
        </div>

        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://keefe.wang/2020/07/29/2020-07-29-use-vue-test-utils-to-test-components.html" data-id="ckk6vuawb004uow90n6ny6cnl" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
    
</article>

        
            <article id="post-2020-07-23-advanced-function-in-vue" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        <div class="article-corner"></div>
        

        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2020/07/23/2020-07-23-advanced-function-in-vue.html">Vue 高级用法与精粹</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2020/07/23/2020-07-23-advanced-function-in-vue.html">
            <time datetime="2020-07-23T11:32:00.000Z" itemprop="datePublished">2020-07-23</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Document/">Document</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Framework/">Framework</a>, <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>, <a class="tag-link" href="/tags/Vue/">Vue</a>
    </div>

                    </div>
                
            </header>
        

        

        <div class="article-entry" itemprop="articleBody">

        
            
            <h3 id="复用与组合"><a href="#复用与组合" class="headerlink" title="复用与组合"></a>复用与组合</h3><h4 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h4><p>多重继承大致有两种模式，一种就是按照顺序将各个父类进行继承，例如当你需要一个类继承 A、B、C和D的特性，那么可以采用 A ⇒ B ⇒ C ⇒ D 这样一个继承链去继承，这种继承方式的好处是知道每一步继承的父子关系。而大多数情况我们不需要知道这些，只要像 duck typing 一样拥有这些父类的特性即可，Mixin 混入机制就是来解决这个问题。Vue 中也提供给了这样的机制：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myMixin = &#123;</div><div class="line">  methods: &#123;</div><div class="line">    hello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'hello from mixin!'</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Component = Vue.extend(&#123;</div><div class="line">  mixins: [myMixin]</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>比较好理解的，像 methods、computed 这种本身是对象类型的属性，可以直接进行 merge，所遵循的混合规则如下：</p>
<ul>
<li>数据对象在内部会进行递归合并，并在发生冲突时<strong>以组件数据优先</strong></li>
<li>同名钩子函数将合并为一个数组，数组中的所有函数都将在此钩子生效时执行</li>
</ul>
<p>混入也支持全局注入，但是需要注意！这会影响到之后的每一个 Vue 组件实例（不建议使用）：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Vue.mixin(&#123;</div><div class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> myOption = <span class="keyword">this</span>.$options.myOption</div><div class="line">    <span class="keyword">if</span> (myOption) &#123;</div><div class="line">      <span class="built_in">console</span>.log(myOption)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>除了 v-model 和 v-show 等自带的指令之外，也可以自定义指令。自定义指令可以全局注册，也可以在组件内进行局部注册（指令在标签中必须要以 v- 开头）：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Vue.directive(<span class="string">'focus'</span>, &#123;</div><div class="line">  inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">    el.focus()</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">directives: &#123;</div><div class="line">  focus: &#123;</div><div class="line">    inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">      el.focus()</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中出现的 inserted 是指令所在的钩子，指令的钩子有以下五种：</p>
<ul>
<li><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li>
<li><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li>
<li><code>update</code>：所在组件的 VNode 更新时调用，<strong>但是可能发生在其子 VNode 更新之前</strong>。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</li>
<li><code>componentUpdated</code>：指令所在组件的 VNode <strong>及其子 VNode</strong> 全部更新后调用。</li>
<li><code>unbind</code>：只调用一次，指令与元素解绑时调用。</li>
</ul>
<p>上述的钩子函数的参数有四个，分别是 el、binding、vnode、oldVnode，其中，指令的值需要从 binding.value 中获取。                                                             </p>
<p>自定义指令还可以添加动态参数，v-someDirection:[arg]，使用 binding.arg 来获取动态的指令：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"dynamicexample"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-pin:</span>[<span class="attr">direction</span>]=<span class="string">"200"</span>&gt;</span>I am pinned onto the page at 200px to the left.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Vue.directive(<span class="string">'pin'</span>, &#123;</div><div class="line">  bind: <span class="function"><span class="keyword">function</span> (<span class="params">el, binding, vnode</span>) </span>&#123;</div><div class="line">    el.style.position = <span class="string">'fixed'</span></div><div class="line">    <span class="keyword">var</span> s = (binding.arg == <span class="string">'left'</span> ? <span class="string">'left'</span> : <span class="string">'top'</span>)</div><div class="line">    el.style[s] = binding.value + <span class="string">'px'</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 回调函数可以简写，只支持 bind 和 update 两个钩子同时触发时</span></div><div class="line">Vue.directive(<span class="string">'pin'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">el, binding, vnode</span>) </span>&#123;&#125;);</div></pre></td></tr></table></figure>
<p>自定义指令也支持传入对象字面量 <code>&lt;div v-demo=&quot;{ color: &#39;white&#39;, text: &#39;hello!&#39; }&quot;&gt;&lt;/div&gt;</code></p>
<h3 id="渲染函数"><a href="#渲染函数" class="headerlink" title="渲染函数"></a>渲染函数</h3><p>如果想要使用纯 js 的方式来实现视图，可以使用 Vue 提供的 render 函数属性来进行渲染，下面是一个简单的例子：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'anchored-heading'</span>, &#123;</div><div class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> createElement(</div><div class="line">      <span class="string">'h'</span> + <span class="keyword">this</span>.level,   <span class="comment">// 标签名称</span></div><div class="line">      <span class="keyword">this</span>.$slots.default <span class="comment">// 子节点数组</span></div><div class="line">    )</div><div class="line">  &#125;,</div><div class="line">  props: &#123;</div><div class="line">    level: &#123;</div><div class="line">      type: <span class="built_in">Number</span>,</div><div class="line">      required: <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>createElement 这个函数可以创建出一个虚拟 Dom，它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息，所以也被称为 Vnode。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// @returns &#123;VNode&#125;</span></div><div class="line">createElement(</div><div class="line">  <span class="comment">// 必填项一个 HTML 标签名、组件选项对象，或者 resolve 了上述任何一种的一个 async 函数</span></div><div class="line">  <span class="comment">// &#123;String | Object | Function&#125;</span></div><div class="line">  <span class="string">'div'</span>,</div><div class="line"></div><div class="line">  <span class="comment">// 一个与模板中 attribute 对应的**数据对象**，可选项，&#123;Object&#125;。</span></div><div class="line">  &#123;&#125;,</div><div class="line"></div><div class="line">  <span class="comment">// 子级虚拟节点 (VNodes)，由 `createElement()` 构建而成，也可以使用字符串来生成“文本虚拟节点”，可选。</span></div><div class="line">	<span class="comment">// &#123;String | Array&#125;</span></div><div class="line">  [</div><div class="line">    <span class="string">'先写一些文字'</span>,</div><div class="line">    createElement(<span class="string">'h1'</span>, <span class="string">'一则头条'</span>),</div><div class="line">    createElement(MyComponent, &#123;</div><div class="line">      props: &#123;</div><div class="line">        someProp: <span class="string">'foobar'</span></div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  ]</div><div class="line">)</div></pre></td></tr></table></figure>
<p>上面讲到的数据对象，也就是一个节点中的一些属性描述：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="comment">// 与 `v-bind:class` 的 API 相同，</span></div><div class="line">  <span class="comment">// 接受一个字符串、对象或字符串和对象组成的数组</span></div><div class="line">  <span class="string">'class'</span>: &#123;</div><div class="line">    foo: <span class="literal">true</span>,</div><div class="line">    bar: <span class="literal">false</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 与 `v-bind:style` 的 API 相同，</span></div><div class="line">  <span class="comment">// 接受一个字符串、对象，或对象组成的数组</span></div><div class="line">  style: &#123;</div><div class="line">    color: <span class="string">'red'</span>,</div><div class="line">    fontSize: <span class="string">'14px'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 普通的 HTML attribute</span></div><div class="line">  attrs: &#123;</div><div class="line">    id: <span class="string">'foo'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 组件 prop</span></div><div class="line">  props: &#123;</div><div class="line">    myProp: <span class="string">'bar'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// DOM property</span></div><div class="line">  domProps: &#123;</div><div class="line">    innerHTML: <span class="string">'baz'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 事件监听器在 `on` 内，</span></div><div class="line">  <span class="comment">// 但不再支持如 `v-on:keyup.enter` 这样的修饰器。</span></div><div class="line">  <span class="comment">// 需要在处理函数中手动检查 keyCode。</span></div><div class="line">  on: &#123;</div><div class="line">    click: <span class="keyword">this</span>.clickHandler</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 仅用于组件，用于监听原生事件，而不是组件内部使用</span></div><div class="line">  <span class="comment">// `vm.$emit` 触发的事件。</span></div><div class="line">  nativeOn: &#123;</div><div class="line">    click: <span class="keyword">this</span>.nativeClickHandler</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 自定义指令。注意，你无法对 `binding` 中的 `oldValue`</span></div><div class="line">  <span class="comment">// 赋值，因为 Vue 已经自动为你进行了同步。</span></div><div class="line">  directives: [</div><div class="line">    &#123;</div><div class="line">      name: <span class="string">'my-custom-directive'</span>,</div><div class="line">      value: <span class="string">'2'</span>,</div><div class="line">      expression: <span class="string">'1 + 1'</span>,</div><div class="line">      arg: <span class="string">'foo'</span>,</div><div class="line">      modifiers: &#123;</div><div class="line">        bar: <span class="literal">true</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  ],</div><div class="line">  <span class="comment">// 作用域插槽的格式为</span></div><div class="line">  <span class="comment">// &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125;</span></div><div class="line">  scopedSlots: &#123;</div><div class="line">    <span class="keyword">default</span>: <span class="function"><span class="params">props</span> =&gt;</span> createElement(<span class="string">'span'</span>, props.text)</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 如果组件是其它组件的子组件，需为插槽指定名称</span></div><div class="line">  slot: <span class="string">'name-of-slot'</span>,</div><div class="line">  <span class="comment">// 其它特殊顶层 property</span></div><div class="line">  key: <span class="string">'myKey'</span>,</div><div class="line">  ref: <span class="string">'myRef'</span>,</div><div class="line">  <span class="comment">// 如果你在渲染函数中给多个元素都应用了相同的 ref 名，</span></div><div class="line">  <span class="comment">// 那么 `$refs.myRef` 会变成一个数组。</span></div><div class="line">  refInFor: <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>通过 Vue.use() 方法使用插件，必须要在 new Vue() 实例化之前进行注册。Vue.use 会自动阻止多次注册相同插件，届时即使多次调用也只会注册一次该插件。</p>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>Vue.js 允许你自定义过滤器（filters 可作为与 computed 同一级的属性进行配置），可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 在双花括号中 --&gt;</span></div><div class="line">&#123;&#123; message | capitalize &#125;&#125;</div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 在 `v-bind` 中，过滤器可以串联，前一个的输出会作为下一个的输入 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"rawId | capitalize | formatId"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
        
        </div>

        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://keefe.wang/2020/07/23/2020-07-23-advanced-function-in-vue.html" data-id="ckk6vuaw8004row90soq4v238" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
    
</article>

        
            <article id="post-2020-07-22-things-need-to-be-aware-of-in-vue" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        <div class="article-corner"></div>
        

        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2020/07/22/2020-07-22-things-need-to-be-aware-of-in-vue.html">Vue 中容易被忽视的小功能</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2020/07/22/2020-07-22-things-need-to-be-aware-of-in-vue.html">
            <time datetime="2020-07-22T11:03:00.000Z" itemprop="datePublished">2020-07-22</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Document/">Document</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Framework/">Framework</a>, <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>, <a class="tag-link" href="/tags/Vue/">Vue</a>
    </div>

                    </div>
                
            </header>
        

        

        <div class="article-entry" itemprop="articleBody">

        
            
            <h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><h4 id="Prop相关"><a href="#Prop相关" class="headerlink" title="Prop相关"></a>Prop相关</h4><p>prop 是父组件向子组件传递数据的一种方式，在父组件中使用 kebab-case 的方式传入数据，在子组件中可以添加 props 属性来获取传入的数据。这是一个单向的通信过程。</p>
<p>可以通过 v-bind 传入动态变量，也可以直接传入字符串值到子组件。</p>
<p>如果子组件中 props 属性中没有声明某些值，那么父组件传入的就是<strong>非 prop 的 attribute</strong>，对于绝大多数 attribute 来说，<strong>从外部提供给组件的值会替换掉组件内部设置好的值</strong>。所以如果传入 type=”text” 就会替换掉 type=”date” 并把它破坏！庆幸的是，<strong>class 和 style attribute</strong> 会稍微智能一些，即两边的值<strong>会被合并（merge）起来，从而得到最终的值</strong>。</p>
<p>可以使用 vm.$attr 属性来获取除 class 和 style 之外的非 prop 的 attribute，可以在父组件中使用 <code>v-bind=&quot;$attr&quot;</code> 传入，还可以通过子组件中的 <code>inheritAttrs: true</code> 字段来控制是否接受父组件传入的非 prop 的 attribute。</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h4><p>使用 v-on 绑定事件时，<strong>最好使用 kebab-case 命名法来命名事件</strong>，因为 v-on 事件监听器在 DOM 模板中会被自动转换为全小写 （因为 HTML 是大小写不敏感的）。</p>
<p>可以使用 <code>v-on=&quot;$listeners&quot;</code> 来将所有的事件监听器指向这个组件的某个特定的子元素，它是一个对象，里面包含了作用在这个组件上所有的监听器（监听事件）。这样，在子组件上可以绑定 vm.$listeners 中所包含的监听事件。</p>
<h4 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h4><p>除了 $emit 和 v-on 这一对好基友之外，vue 还提供了类似 总线（bus）机制的观察者模式的事件监听方案：</p>
<ul>
<li><code>$on(eventName, eventHandler)</code> 侦听一个事件</li>
<li><code>$once(eventName, eventHandler)</code> 一次性侦听一个事件</li>
<li><code>$off(eventName, eventHandler)</code> 停止侦听一个事件</li>
</ul>
<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><ul>
<li>sync<ul>
<li>作用：对 prop 进行简单的“双向绑定”，可以实现简单的父子数据同步</li>
<li>使用：在父组件需要双向绑定的数据上添加 .sync 修饰符，例如 <code>&lt;div&gt;&lt;child :some-prop.sync=&quot;someProp&quot;&gt;&lt;/child&gt;&lt;/div&gt;</code> ；在子组件上使用 vm.$emit 触发数据更新，例如 <code>this.$emit(&#39;update:some-prop&#39;, val)</code></li>
</ul>
</li>
</ul>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><h4 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h4><p>动态组件是通过 <component :is="componentName"></component> 来实现的，但是在切换组件时，会将每个组件的原有状态丢失，这时需要添加一个 keep-alive 标签，例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentTabComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h4><p>Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Vue.component(</div><div class="line">  <span class="string">'async-webpack-example'</span>,</div><div class="line">  <span class="comment">// 这个动态导入会返回一个 `Promise` 对象。</span></div><div class="line">  () =&gt; <span class="keyword">import</span>(<span class="string">'./my-async-component'</span>)</div><div class="line">)</div></pre></td></tr></table></figure>
<h3 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a>Slot</h3><h4 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h4><p>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</p>
<h4 id="default内容"><a href="#default内容" class="headerlink" title="default内容"></a>default内容</h4><p>可以使用 <code>&lt;slot&gt; Default content &lt;/slot&gt;</code> 来设置分发内容的默认值，当没有内容传入时会显示该内容。</p>
<h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><p>有多个插槽需要进行内容分发时，可以使用具名插槽，具体用法如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 子元素设置具名插槽 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 父元素设置分发内容，由 v-slot 属性来指明具体的插槽名 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><p>绑定在 <slot> 元素上的 attribute 被称为插槽 prop，为了让父元素能够访问到子组件中的数据，可以通过 v-bind 进行作用域的绑定，具体代码如下：</slot></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 子元素中需要在 slot 中使用 v-bind 绑定具体变量 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-bind:user</span>=<span class="string">"user"</span>&gt;</span></div><div class="line">    &#123;&#123; user.lastName &#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 父元素通过 v-slot 来指明子元素所 bind 的所有数据 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">child</span>&gt;</span></div><div class="line">	  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot</span>=<span class="string">"slotProps"</span>&gt;</span></div><div class="line">		    &#123;&#123; slotProps.user.firstName &#125;&#125;</div><div class="line">	  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong><em>v-slot 的缩写为 #</em></strong>，这个在具名插槽中有</p>
<h4 id="结构插槽Prop"><a href="#结构插槽Prop" class="headerlink" title="结构插槽Prop"></a>结构插槽Prop</h4><p>作用域插槽的内部工作原理是将你的插槽内容包裹在一个拥有单个参数的函数里，这意味着 v-slot 的值实际上可以是任何能够作为函数定义中的参数的 JavaScript 表达式。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- prop 重命名 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">"&#123; user: person &#125;"</span>&gt;</span></div><div class="line">	  &#123;&#123; person.firstName &#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 为 prop 指定默认值 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">"&#123; user = &#123; firstName: 'Guest' &#125; &#125;"</span>&gt;</span></div><div class="line">	  &#123;&#123; user.firstName &#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="边界情况处理"><a href="#边界情况处理" class="headerlink" title="边界情况处理"></a>边界情况处理</h3><h4 id="访问元素-amp-组件"><a href="#访问元素-amp-组件" class="headerlink" title="访问元素&amp;组件"></a>访问元素&amp;组件</h4><ul>
<li><p>访问根实例</p>
<p>  一般不建议触达另一个组件实例内部或手动操作 DOM 元素</p>
<p>  如果必须这么做，可以通过 this.$root 来访问根实例中的 data、computed 和 methods 等属性</p>
</li>
<li><p>访问父级元素</p>
<p>  同访问根实例，父级元素的访问是通过 this.$parent</p>
</li>
<li><p>访问子元素</p>
<p>  你可以通过 ref 这个 attribute 为子组件赋予一个 ID 引用，父组件可以通过 他会 this.$refs.someId 来访问子元素的所有属性</p>
</li>
<li><p>依赖注入</p>
<p>  当出现了多层嵌套的组件时，使用 $parent 属性无法很好获取到特定父级元素，这时需要采用依赖注入的方法 provide 和 inject，相当于爷组件和孙组件之间的 props：</p>
  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 爷组件中添加 provide 属性</span></div><div class="line">provide: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    getMap: <span class="keyword">this</span>.getMap</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 孙组件中添加 inject 属性</span></div><div class="line">inject: [<span class="string">'getMap'</span>]</div></pre></td></tr></table></figure>
</li>
<li><p>循环引用</p>
<ul>
<li>组件递归引用要避免</li>
<li><p>不同组件间相互引用，如果产生循环引用（例如 Tree 文件系统或级联系统，模块系统会不知道到底哪个是初始组件），可以采用如下两种方式来解决：</p>
<ul>
<li><p>在生命周期钩子 beforeCreate 中进行组件的引入：</p>
  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">beforeCreate: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.$options.components.TreeFolderContents = <span class="built_in">require</span>(<span class="string">'./tree-folder-contents.vue'</span>).default</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>引用组件时采用异步方式：</p>
  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">components: &#123;</div><div class="line">  TreeFolderContents: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./tree-folder-contents.vue'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="过渡-amp-动画"><a href="#过渡-amp-动画" class="headerlink" title="过渡&amp;动画"></a>过渡&amp;动画</h3><h4 id="单元素-组件的过渡"><a href="#单元素-组件的过渡" class="headerlink" title="单元素/组件的过渡"></a>单元素/组件的过渡</h4><p>使用 <transition name="someTransition"></transition> 封装所要添加过渡的元素。这种方式适用于以下四种情况（都是单个组件显隐）：</p>
<ul>
<li>条件渲染 (使用 <code>v-if</code>)</li>
<li>条件展示 (使用 <code>v-show</code>)</li>
<li>动态组件</li>
<li>组件根节点</li>
</ul>
<p>封装好元素后，还需要提供相应的 css 样式，分别由六种状态的样式名，需要根据 name 属性进行相应的设置：someTransition-enter 表示进入过渡开始状态，someTransition-enter-active 表示进入过渡生效状态，someTransition-enter-to 表示进入过渡结束状态，someTransition-leave，someTransition-leave-active，someTransition-leave-to。</p>
<p>也可以自定义类名，相对应上面六种默认的样式，可以在 transition 标签中添加 enter-class，enter-active-class，enter-to-class，leave-class，leave-active-class，leave-to-class。</p>
<p>transition 标签中可以指定进入和离开过渡的时长，可以通过 <code>:duration=&quot;{ enter: 500, leave: 800 }&quot;</code> 实现</p>
<p>transition 标签中可以指定过渡各阶段的钩子，以用来绑定相应的事件，包括 @before-enter、@enter、@after-enter、@enter-cancelled、@before-leave、@leave、@after-leave、@leave-cancelled 八种钩子：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在 enter 和 leave 钩子事件，如果没有 css 控制元素过渡，那么一定需要有 done() 回调</span></div><div class="line"><span class="comment">// 否则 enter 和 leave 钩子事件会同时完成</span></div><div class="line">beforeEnter: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;&#125;,</div><div class="line">enter: <span class="function"><span class="keyword">function</span> (<span class="params">el, done</span>) </span>&#123;</div><div class="line">    done()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>transition 标签中可以使用 appear 属性来设置元素初始化过渡的样式，用法与 enter 和 leave 相同，可以使用 someTrasition-appear 类或者自定义类名属性，当然也支持钩子的实现。</p>
<h4 id="多元素的过渡"><a href="#多元素的过渡" class="headerlink" title="多元素的过渡"></a>多元素的过渡</h4><p>多元素使用过渡时，可以在最外层使用 transition 标签进行包装，用法与单元素相同，但是有一点需要注意——使用 v-if 或者 v-for 设置多个元素时，一定要在每个元素上绑定自己的 key。</p>
<p>多个元素切换显隐状态时，Vue 提供了一个 mode 属性来进行平滑过渡：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;transition name=<span class="string">"fade"</span> mode=<span class="string">"out-in"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span></div></pre></td></tr></table></figure>
<h4 id="多组件的过渡"><a href="#多组件的过渡" class="headerlink" title="多组件的过渡"></a>多组件的过渡</h4><p>多组件的过渡，使用之前所提到的动态组件即可实现，在过渡时可以在组件外包装一层 transition，指定过渡的样式名 name 属性，就可以使用上面提到的样式或钩子进行过渡样式的实现，当然也可以添加所需要的 mode：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;transition name=<span class="string">"component-fade"</span> mode=<span class="string">"out-in"</span>&gt;</div><div class="line">  &lt;component v-bind:is=<span class="string">"view"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></div><div class="line">&lt;<span class="regexp">/transition&gt;</span></div></pre></td></tr></table></figure>
<p>对于列表的过渡，可以使用 <transition-group> 包装 v-for 渲染出的列表，指明过渡样式名 name 属性，即可用上面相同的方式进行过渡的实现。在列表打乱或重新排序时，Vue 提供了 someTransition-move 的类名来实现：</transition-group></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"shuffle"</span>&gt;</span>Shuffle<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">transition-group</span> <span class="attr">name</span>=<span class="string">"flip-list"</span> <span class="attr">tag</span>=<span class="string">"ul"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">v-bind:key</span>=<span class="string">"item"</span>&gt;</span></div><div class="line">	      &#123;&#123; item &#125;&#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#flip-list-demo'</span>,</div><div class="line">  data: &#123;</div><div class="line">    items: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    shuffle: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">this</span>.items = _.shuffle(<span class="keyword">this</span>.items)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flip-list-move</span> &#123;</div><div class="line">  <span class="attribute">transition</span>: transform <span class="number">1s</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
        
        </div>

        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://keefe.wang/2020/07/22/2020-07-22-things-need-to-be-aware-of-in-vue.html" data-id="ckk6vuavw004oow902dctjthg" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
    
</article>

        
            <article id="post-2020-06-03-advanced-eventloop-in-javascript" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        <div class="article-corner"></div>
        

        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2020/06/03/2020-06-03-advanced-eventloop-in-javascript.html">JavaScript 基于事件循环的并发模型</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2020/06/03/2020-06-03-advanced-eventloop-in-javascript.html">
            <time datetime="2020-06-03T08:31:00.000Z" itemprop="datePublished">2020-06-03</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Document/">Document</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>
    </div>

                    </div>
                
            </header>
        

        

        <div class="article-entry" itemprop="articleBody">

        
            
            <p>runtime（运行时刻）是指一个程序在运行的状态。JavaScript 的运行时刻有一个基于事件循环的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。</p>
<p><img src="JavaScript%20%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%20b0cfb1289e8e4098b7cae991e050b301/The_Javascript_Runtime_Environment_Example.svg" alt="JavaScript%20%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%20b0cfb1289e8e4098b7cae991e050b301/The_Javascript_Runtime_Environment_Example.svg"></p>
<p>JavaScript 中的函数调用会形成一个由若干帧组成的栈，当一个函数中存在闭包函数时，外层函数会先压入栈中，其中包含参数和局部变量；闭包函数跟着压入栈中，也包含了自己的参数和局部变量。闭包函数先从栈中弹出，执行完了之后外层函数从栈中弹出执行，栈就被清空了。</p>
<p>对象是被分配在堆中。</p>
<p>一个 JavaScript 运行时包含了一个待处理消息的消息队列。每一个消息都关联着一个用以处理这个消息的回调函数。</p>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (queue.waitForMessage()) &#123;</div><div class="line">  queue.processNextMessage();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JavaScript 中每一个函数都是需要完整执行完成才会继续进行下一步（单线程语言：one thread ⇒ one call stack ⇒ one thing at a time），所以 JavaScript 的代码很容易出现一个函数执行时间过长的情况。为了实现程序的并发执行，JavaScript 引入了事件循环机制。</p>
<p>在上面所提到的函数调用栈之外，还会有一个任务队列。当 runtime 执行代码过程中遇到了像 setTimeout 或 DOM 事件绑定的回调函数，会首先调用 WebAPIs 去进行执行——例如 setTimeout 会产生一个 timer 计时器，当计时器到达指定时间后，会将这个事件推入任务队列。任务队列就是由一个个异步操作的回调函数所组成的队列。事件循环简单来说就是：当 runtime 函数调用栈清空后，查看当前任务队列，并把队列第一个任务压入 runtime 函数调用栈。</p>
<p>浏览器的 render 刷新最快是 16.6ms 一次（浏览器刷新一般是 60次/s ），这是在主线程为空的时候（所以任务队列里的任务是不会阻塞浏览器渲染的）。<strong>如果想在浏览器渲染任务队列中添加任务，可以使用 requestAnimationFrame(callback)方法来进行添加</strong>。如果函数调用栈不为空，则 render 会被阻塞：主线程中的死循环会阻塞浏览器渲染，但是看下面的代码： </p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	setTimeout(loop, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line">loop();</div></pre></td></tr></table></figure>
<p>这个无限自我递归调用也会形成一个循环，但是由于 setTimeout 方法只是不停地往任务队列里面添加任务，而主线程还是每次取一个任务去执行，主线程不会被阻塞，所以浏览器渲染也不会被阻塞。</p>
<p>到目前为止，在事件循环中，我们认识到了主线程、任务队列和渲染任务队列。当主线程任务全部执行完成清空后，会从非空的任务队列中拿第一个任务到主线程尽心执行，每次循环都是只取一个任务队列中的任务。而渲染任务则是一次性执行完成的。</p>
<p><img src="JavaScript%20%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%20b0cfb1289e8e4098b7cae991e050b301/_1.png" alt="JavaScript%20%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%20b0cfb1289e8e4098b7cae991e050b301/_1.png"></p>
<p>实际上，浏览器总还有一个 microTask queue，这个队列中一般我们遇到的 99.9% 应该都是以 promise 形式出现的，microTask 执行的时间是每一段 JS 代码执行完毕（主线程任务清空、任务队列取得第一个任务到主线程并执行完、浏览器渲染任务执行完）都会进行执行，而且一旦执行，microTask queue 中无论有多少个任务（包括同时添加进来的任务）都会一直执行完。所以，microTask queue 是会产生阻塞的。</p>
<p><img src="JavaScript%20%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%20b0cfb1289e8e4098b7cae991e050b301/_1%201.png" alt="JavaScript%20%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%20b0cfb1289e8e4098b7cae991e050b301/_1%201.png"></p>
<p>如上图所示，我们所知的浏览器的事件循环有以下的几种队列机制：</p>
<ul>
<li><p>主线程任务队列</p>
<p>  接受 JS 程序中按顺序的同步任务，在每次事件循环中都会执行任务直至队列清空</p>
</li>
<li><p>异步回调任务队列</p>
<p>  接受像 setTimeout、ajax 等的异步回调函数任务，在每次时间循环中主线程任务队列清空后，会拿出该队列的头部任务放入主线程进行执行</p>
</li>
<li><p>microtask 任务队列</p>
<p>  接受 promise.then 的回调函数任务，在事件循环中，每一段 JS 代码执行完毕（主线程任务清空、任务队列取得第一个任务到主线程并执行完、浏览器渲染任务执行完）都会执行，且每次执行都会将该队列清空，包括同时入队的任务也会一并清空</p>
</li>
<li><p>动画帧回调任务队列</p>
<p>  接受 requestAnimationFrame 的回调函数任务，在每次浏览器渲染任务执行之前进行执行（目前仅在 chrome 中是该顺序），每次执行都清空当前队列，如有新的任务添加则等待下次渲染前执行</p>
</li>
<li><p>浏览器渲染任务队列</p>
<p>  每当上面主线程、异步任务队列、microTask 任务队列执行完毕，且距离上一次渲染时长大于 16.6ms 时，就会进行任务执行，每一次执行都会将当前队列任务全部执行完毕</p>
</li>
</ul>
<p>用一个伪代码来进行上面流程的表述，如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">	<span class="keyword">while</span> (mainThread.hasTasks()) &#123;</div><div class="line">		execute(mainThread.getNextTask());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	queue = getNextQueue();</div><div class="line">	task = queue.pop();</div><div class="line">	execute(task);</div><div class="line"></div><div class="line">	<span class="keyword">while</span>(microTask.hasTasks()) &#123;</div><div class="line">		doMicroTask();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (isRepaintTime()) &#123;</div><div class="line">		animationTasks = animationQueue.copyTasks();</div><div class="line">		<span class="keyword">for</span> (task <span class="keyword">in</span> animationTasks) &#123;</div><div class="line">			doAnimationTask();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	repaint()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Node-中的事件循环"><a href="#Node-中的事件循环" class="headerlink" title="Node 中的事件循环"></a>Node 中的事件循环</h3><p>NodeJS 的事件循环基本上与浏览器中的事件循环是一致的，只不过浏览器使用的是 WebAPIs，而 NodeJS 中使用的是 C++ APIs。</p>
<p><img src="JavaScript%20%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%20b0cfb1289e8e4098b7cae991e050b301/_1%202.png" alt="JavaScript%20%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%20b0cfb1289e8e4098b7cae991e050b301/_1%202.png"></p>
<p>主线程与异步任务队列执行以及 microTask 任务队列都与浏览器中的事件循环相同，我们可以看到上图中多了三个没有见到过的任务队列：</p>
<ul>
<li><p>check phase 任务队列</p>
<p>  接受使用 setImmediate 方法传入的回调函数任务，每次在异步任务队列执行完成后，清空该队列</p>
</li>
<li><p>timer phase 任务队列</p>
<p>  接受 setTimeout、setInterval 传入的回调函数，每次在 check phase 任务队列清空后，清空该任务队列</p>
</li>
<li><p>nextTick 任务队列</p>
<p>  与 microTask 任务队列相同， 接受 process.nextTick 传入的回调函数，该队列优先级高于 microTask </p>
</li>
</ul>
<p>用伪代码进行上述流程的模拟，如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (tasksAreWaiting()) &#123;</div><div class="line">	queue = getNextQueue();</div><div class="line">	<span class="keyword">while</span> (queue.hasTasks()) &#123;</div><div class="line">		task = queue.pop();</div><div class="line">		execute(task);</div><div class="line">		</div><div class="line">		<span class="keyword">while</span> (nextTickQueue.hasTasks()) &#123;</div><div class="line">			doNextTickTask();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">while</span> (promiseQueue.hasTasks()) &#123;</div><div class="line">			doPromiseTask();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
        
        </div>

        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://keefe.wang/2020/06/03/2020-06-03-advanced-eventloop-in-javascript.html" data-id="ckk6vuavu004mow901d77j0j6" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
    
</article>

        
            <article id="post-2020-05-30-source-code-reading-Egg-starting" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        <div class="article-corner"></div>
        

        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2020/05/23/2020-05-30-source-code-reading-Egg-starting.html">EggJS源码阅读-启动流程与代码实现</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2020/05/23/2020-05-30-source-code-reading-Egg-starting.html">
            <time datetime="2020-05-23T04:30:00.000Z" itemprop="datePublished">2020-05-23</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/SourceCodeReading/">SourceCodeReading</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/EggJS/">EggJS</a>, <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>, <a class="tag-link" href="/tags/NodeJS/">NodeJS</a>, <a class="tag-link" href="/tags/源码学习/">源码学习</a>
    </div>

                    </div>
                
            </header>
        

        

        <div class="article-entry" itemprop="articleBody">

        
            
            <blockquote>
<p>egg是阿里开源的一个框架，为企业级框架和应用而生，相较于express和koa，有更加严格的目录结构和规范。不同的团队可以基于egg，根据自己的需求封装出适合团队业务的更上层框架。</p>
</blockquote>
<h3 id="egg如何启动"><a href="#egg如何启动" class="headerlink" title="egg如何启动"></a>egg如何启动</h3><p><img src="https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiZDc4MmQxN2MtM2FjYS00MDZhLTk4MDktOGRmMzMwY2M3ZGQxIiwicmVzb3VyY0d1aWQiOiJiMzZlODM2OS0xNzY1LTQzOTEtOTAzOC0zN2Q0NmE0NWVjNjAifQ==" alt="fca8379caeffb9c194aa5369db1c563b.png"></p>
<p>根据<code>package.json</code>中的<code>script</code>命令，可以看到执行的直接是<code>egg-bin dev</code>的命令。找到<code>egg-bin</code>文件夹中的<code>dev.js</code>,会看到里面会去执行外层的<code>start-cluster</code>文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">require(options.framework).startCluster(options);</div></pre></td></tr></table></figure>
<p>此处的<code>options.framework</code>其实指的就是<code>egg</code>框架，然后调用了<code>egg-cluster</code>包中的<code>startCluster</code>方法，egg正式迈出了启动的第一步。</p>
<p>[源码流程]</p>
<p><code>egg</code>框架采用了<code>master-agent-worder</code>的集群模式，如果所示，官方文档中也对于这三种进程的启动和通信给出了较为详细的说明：</p>
<ul>
<li>Master 启动后先 fork Agent 进程</li>
<li>Agent 初始化成功后，通过 IPC 通道通知 Master</li>
<li>Master 再 fork 多个 App Worker</li>
<li>App Worker 初始化成功，通知 Master</li>
<li>所有的进程初始化成功后，Master 通知 Agent 和 Worker 应用启动成功</li>
</ul>
<p>我们尝试从源码中大致将这个流程实现出来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// egg-cluster/lib/master.js</span></div><div class="line">ready.mixin(<span class="keyword">this</span>);              <span class="comment">// 将 ready 方法挂在 Master 上</span></div><div class="line"><span class="keyword">this</span>.detectPorts().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;  <span class="comment">// 检测端口</span></div><div class="line">    <span class="keyword">this</span>.forkAgentWorker();      <span class="comment">// 启动 agent 进程，发送 agent-start 消息给 master 进程</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// master 进程一旦接收到 agent-start 消息后，开始创建 worker 进程</span></div><div class="line"><span class="keyword">this</span>.once(<span class="string">'agent-start'</span>, <span class="keyword">this</span>.forkAppWorkers.bind(<span class="keyword">this</span>));</div></pre></td></tr></table></figure>
<p>[源码流程]</p>
<h3 id="Agent与AppWorker的实现"><a href="#Agent与AppWorker的实现" class="headerlink" title="Agent与AppWorker的实现"></a>Agent与AppWorker的实现</h3><h4 id="AgentWorker与AppWorker进程的启动"><a href="#AgentWorker与AppWorker进程的启动" class="headerlink" title="AgentWorker与AppWorker进程的启动"></a>AgentWorker与AppWorker进程的启动</h4><p><img src="https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiZDc4MmQxN2MtM2FjYS00MDZhLTk4MDktOGRmMzMwY2M3ZGQxIiwicmVzb3VyY0d1aWQiOiI3ZmViNGFmYS1kMzNlLTQ1MDgtYjAyNi0wYWIyOGRkMDc2Y2MifQ==" alt="de59fd88a438492231f38fb2032ffd5b.png"></p>
<p>在启动<code>AgentWorker</code>和<code>AppWorker</code>时，会分别加载<code>agent_worker.js</code>和<code>app_worker.js</code>两个文件并创建进程，其中<code>agent_worker.js</code>中会创建<code>Agent</code>类的实例，而<code>app_worker.js</code>中会创建<code>Application</code>类的实例。</p>
<p>两种进程在启动时都会调用<code>this.loader.load()</code>方法来加载自己相应的一些插件和自定义的扩展。</p>
<p><img src="https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiZDc4MmQxN2MtM2FjYS00MDZhLTk4MDktOGRmMzMwY2M3ZGQxIiwicmVzb3VyY0d1aWQiOiI0MDczM2IwZi04OTc0LTQxNzctYjM4Zi0zN2I0MTE3ZGQ2MjAifQ==" alt="18d21732106d0293791bf03d6481784b.png"></p>
<p>基于<code>egg_loader</code>实现了<code>AppWorkerLoader</code>和 <code>AgentWorkerLoader</code>，上层框架基于这两个类来扩展，<code>Loader</code>的扩展只能在框架进行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; AppWorkerLoader &#125; <span class="keyword">from</span> <span class="string">'egg'</span></div><div class="line"><span class="keyword">import</span> common <span class="keyword">from</span> <span class="string">'./common'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAppWorkerLoader</span> <span class="keyword">extends</span> <span class="title">AppWorkerLoader</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(opt) &#123;</div><div class="line">    <span class="keyword">super</span>(opt);</div><div class="line">        <span class="comment">// 自定义初始化</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    loadConfig() &#123;</div><div class="line">        <span class="keyword">super</span>.loadConfig();</div><div class="line">        <span class="comment">// 对 config 进行处理</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    load() &#123;</div><div class="line">        <span class="keyword">super</span>.load();</div><div class="line">        <span class="comment">// 自定义加载其他目录</span></div><div class="line">        <span class="comment">// 或对已加载的文件进行处理</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">Object</span>.assign(MyAppWorkerLoader.prototype, &#123;</div><div class="line">    <span class="comment">// 可以根据自己的需求，重写一些获取配置的方法</span></div><div class="line">    getServerEnv()&#123;&#125;;</div><div class="line">    _preloadAppConfig()&#123;&#125;</div><div class="line">    getTypeFiles()&#123;&#125;</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> MyAppWorkerLoader</div></pre></td></tr></table></figure>
<h4 id="Agent如何实现"><a href="#Agent如何实现" class="headerlink" title="Agent如何实现"></a>Agent如何实现</h4><p><img src="https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiZDc4MmQxN2MtM2FjYS00MDZhLTk4MDktOGRmMzMwY2M3ZGQxIiwicmVzb3VyY0d1aWQiOiJmMTAwMWJlZi05OWMwLTQ3Y2MtYjk3NS1kYmZiNjI1N2VkNjMifQ==" alt="f2ac3732452f487f21e11c0de480f3df.png"></p>
<p><code>Agent</code>对象在<code>egg-cluster</code>创建环节中被创建出来，继承自<code>egg.Agent</code>对象，该对象继承<code>EggApplication</code>,且<code>loader</code>为<code>./lib/loader/agent_worker_loader.js</code>文件，继承自<code>egg-core.eggLoader</code>对象，整体继承链如上图。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// egg/lib/agent.js</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Agent</span> <span class="keyword">extends</span> <span class="title">EggApplication</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(options = &#123;&#125;) &#123;</div><div class="line">    options.type = <span class="string">'agent'</span>;</div><div class="line">    <span class="comment">// 1.完成父类构建</span></div><div class="line">    <span class="keyword">super</span>(options);</div><div class="line">    <span class="comment">// 2.驱动loader执行load方法</span></div><div class="line">    <span class="keyword">this</span>.loader.load();</div><div class="line">    <span class="comment">// 3.dump相关配置文件进入./run目录下</span></div><div class="line">    <span class="keyword">this</span>.dumpConfig();</div><div class="line">    </div><div class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>);</div><div class="line">    <span class="comment">// 4.监听异常事件</span></div><div class="line">    <span class="keyword">this</span>._uncaughtExceptionHandler = <span class="keyword">this</span>._uncaughtExceptionHandler.bind(<span class="keyword">this</span>);</div><div class="line">    process.on(<span class="string">'uncaughtException'</span>, <span class="keyword">this</span>._uncaughtExceptionHandler);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Agent</code>类的实现中，主要是实例化了<code>EggApplication</code>，调用了<code>this.loader.load()</code>方法来加载各种文件和配置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// egg/lib/egg.js</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EggApplication</span> <span class="keyword">extends</span> <span class="title">EggCore</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(options = &#123;&#125;) &#123;</div><div class="line">        options.mode = options.mode || <span class="string">'cluster'</span>;</div><div class="line">        <span class="comment">// 1.原型EggCore构建</span></div><div class="line">        <span class="keyword">super</span>(options);</div><div class="line">        <span class="comment">// 2.调用loadConfig，在agent的实现中，指向的并不是egg-core.loader，而是agent_worker_loader</span></div><div class="line">        <span class="keyword">this</span>.loader.loadConfig();</div><div class="line">        <span class="comment">// 3.ready事件</span></div><div class="line">        <span class="keyword">this</span>.ready(<span class="function"><span class="params">()</span> =&gt;</span> process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">          <span class="keyword">const</span> dumpStartTime = <span class="built_in">Date</span>.now();</div><div class="line">          <span class="keyword">this</span>.dumpConfig();</div><div class="line">          <span class="keyword">this</span>.dumpTiming();</div><div class="line">        &#125;));</div><div class="line">        <span class="comment">// 监听unhandleRejection事件</span></div><div class="line">        <span class="comment">// 4.cluster初始化</span></div><div class="line">        <span class="keyword">this</span>[CLUSTER_CLIENTS] = [];</div><div class="line">        <span class="keyword">this</span>.cluster = <span class="function">(<span class="params">clientClass, options</span>) =&gt;</span> &#123;&#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>EggApplication</code>类的实现中，我们可以看到是继承自<code>EggCore</code>类，在父类构建好之后，会调用<code>this.loader.loadConfig()</code>方法，该方法的<code>loader</code>实例实际指向了<code>AgentWorkerLoader（agent_worker_loader.js）</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// egg/lib/loader/agent_worker_loader.js</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AgentWorkerLoader</span> <span class="keyword">extends</span> <span class="title">EggLoader</span> </span>&#123;</div><div class="line">  loadConfig() &#123;</div><div class="line">    <span class="keyword">this</span>.loadPlugin();  <span class="comment">// loadPlugin from egg-core/lib/loader/mixin/plgin.js</span></div><div class="line">    <span class="keyword">super</span>.loadConfig(); <span class="comment">// loadConfig from egg-core/lib/loader/mixin/config.js</span></div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  load() &#123;</div><div class="line">    <span class="keyword">this</span>.loadAgentExtend();</div><div class="line">    <span class="keyword">this</span>.loadContextExtend();</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.loadCustomAgent();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>loadPlugin</code>方法会加载三种插件：</p>
<ul>
<li><code>eggPlugins</code>，从eggjs框架配置的插件，也就是<code>egg/config/plugins.js</code>文件中egg框架自带的插件；</li>
<li><code>appPlugins</code>，每个应用自己配置的插件，也就是<code>myproject/config/plugins.js</code>，用户可以自定义配置一些特殊的插件；</li>
<li><code>customPlugins</code>，应用启动命令中参数EGG_PLUGINS值所代表的插件；</li>
</ul>
<p>最后会将这三种插件都挂在app实例上：<code>this.plugins = enablePlugins</code>;</p>
<p><code>loadConfig</code>方法会加载三种配置：</p>
<ul>
<li><code>appConfig</code>，每个应用自己独有的配置，其中会按顺序加载两个配置，一个是默认配置<code>config.default</code>，另一个是当前环境的配置<code>config.${this.serverEnv}</code>，也就是<code>myproject/config</code>下的一些配置文件加载</li>
<li>加载自定义添加的<code>plugin</code>插件的配置</li>
<li>加载框架<code>egg</code>的配置，即<code>egg/config</code></li>
<li>重新加载应用<code>app</code>的配置，即<code>myproject/config</code>下的</li>
</ul>
<p>最后将合并的配置挂载在<code>app</code>实例上<code>this.config = target</code>;</p>
<h4 id="Application如何实现"><a href="#Application如何实现" class="headerlink" title="Application如何实现"></a>Application如何实现</h4><p>上面提到，<code>AppWorker</code>在实例化的过程中，会调用<code>this.loader.load()</code>。进入具体这个<code>Application</code>所对应的<code>loader.load</code>方法，可以发现<code>Application</code>的实现比<code>Agent</code>的实现多调用了很多加载的方法：</p>
<ul>
<li><code>this.loadApplicationExtend();</code>，该方法的调用会给应用加载扩展方法，加载路径为<code>app\extend\application.js</code>, 会将对应的对象挂载在app 应用上。</li>
<li><code>this.loadRequestExtend();</code>，加载<code>app\extend\request.js</code></li>
<li><code>this.loadResponseExtend();</code>，加载<code>app\extend\response.js</code></li>
<li><code>this.loadContextExtend();</code>，加载<code>app\extend\context.js</code></li>
<li><code>this.loadHelperExtend();</code>，加载<code>app\extend\helper.js</code></li>
<li><code>this.loadService()</code></li>
<li><code>this.loadMiddleware()</code></li>
<li><code>this.loadController()</code></li>
<li><code>this.loadRouter()</code></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p>egg启动服务集群，采用了<code>master-agent-worker</code>模式，<code>AgentWorker</code>和<code>AppWorker</code>都由Application(egg/lib/applicaton.js) -&gt; EggApplication(egg/lib/egg.js) -&gt; EggCore(egg-core/lib/egg.js) -&gt; KoaApplication(koa)原型链进行继承</p>
</li>
<li><p><code>Agent</code>和<code>Application</code>在实例化的过程中，都会调用相应的Loader去加载自己所需的插件和配置，且加载顺序严格按照<strong>插件plugin-框架framework-应用application</strong>这样一个顺序</p>
</li>
</ol>
<p><img src="https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiZDc4MmQxN2MtM2FjYS00MDZhLTk4MDktOGRmMzMwY2M3ZGQxIiwicmVzb3VyY0d1aWQiOiIwZGM3ZmY3Mi1iZjM1LTQzZDMtODE1Ni0wMDk2YmQyY2FiMDUifQ==" alt="0464781205f05b89c1b8807280114dd8.png"></p>

        
        </div>

        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://keefe.wang/2020/05/23/2020-05-30-source-code-reading-Egg-starting.html" data-id="ckk6vuavs004iow908y9hsncb" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
    
</article>

        
            <article id="post-2020-03-05-source-code-reading-express-router" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        <div class="article-corner"></div>
        

        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2020/03/15/2020-03-05-source-code-reading-express-router.html">Express源码阅读-router相关</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2020/03/15/2020-03-05-source-code-reading-express-router.html">
            <time datetime="2020-03-15T04:30:00.000Z" itemprop="datePublished">2020-03-15</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/SourceCodeReading/">SourceCodeReading</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Express/">Express</a>, <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>, <a class="tag-link" href="/tags/NodeJS/">NodeJS</a>, <a class="tag-link" href="/tags/源码学习/">源码学习</a>
    </div>

                    </div>
                
            </header>
        

        

        <div class="article-entry" itemprop="articleBody">

        
            
            <p>Express 是一种保持最低程度规模的灵活 Node.js Web 应用程序框架，为 Web 和移动应用程序提供一组强大的功能。</p>
<h3 id="Express中的app"><a href="#Express中的app" class="headerlink" title="Express中的app"></a>Express中的app</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// express.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// typeof app === 'function'，同时它身上还绑定着无数属性和方法</span></div><div class="line">    <span class="keyword">var</span> app = <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">        app.handle(req, res, next);</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// app同时继承了事件监听/触发机制和application.js中的各种方法</span></div><div class="line">    mixin(app, EventEmitter.prototype, <span class="literal">false</span>);</div><div class="line">    mixin(app, proto, <span class="literal">false</span>);</div><div class="line">    <span class="comment">// 此处暴露了request和response两个类</span></div><div class="line">    app.request = <span class="built_in">Object</span>.create(req, &#123; ... &#125;);</div><div class="line">    app.response = <span class="built_in">Object</span>.create(res, &#123; ... &#125;);</div><div class="line">    <span class="comment">// 调用application.js中的init方法，主要调用的是defaultConfiguration方法</span></div><div class="line">    app.init();</div><div class="line">    <span class="keyword">return</span> app;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 这里需要注意的是exports和module.exports的不同：当module.exports被赋值后，exports就不同于module.exports了，所以需要这么做；当然也可以只用module.exports；</span></div><div class="line">exports = <span class="built_in">module</span>.exports = createApplication;</div></pre></td></tr></table></figure>
<p>可以看出，调用express()返回的app其实是一个函数，调用app.listen()其实执行的是http.createServer(app).listen()。因此，app其实就是一个请求处理函数，作为http.createServer的参数。而express其实是一个工厂函数，用来生成请求处理函数。</p>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><blockquote>
<p>An Express application is essentially a series of middleware calls.<br>一个Express应用实际上就是一系列中间件的调用。</p>
</blockquote>
<p>中间件大致可分为两种，一种是普通中间件，通过 <code>app.use(&#39;/user&#39;)</code> 方法进行注册，该方法中的路径是匹配所有以 <code>/user</code> 开头的路径；另外一种是路由中间件，通过 <code>app.METHOD()</code> 方法进行注册，这种方式精确匹配路径，且只能处理确定请求方法的请求。</p>
<p>针对app.use部分的代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">app.use = <span class="function"><span class="keyword">function</span> <span class="title">use</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> offset = <span class="number">0</span>;</div><div class="line">  <span class="comment">// 默认设置路径为根路径，同时判断中间件是方法还是方法所在路径</span></div><div class="line">  <span class="keyword">var</span> path = <span class="string">'/'</span>;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) &#123;</div><div class="line">    <span class="keyword">var</span> arg = fn;</div><div class="line">    <span class="keyword">while</span> (<span class="built_in">Array</span>.isArray(arg) &amp;&amp; arg.length !== <span class="number">0</span>) &#123;</div><div class="line">      arg = arg[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">'function'</span>) &#123;</div><div class="line">      offset = <span class="number">1</span>;</div><div class="line">      path = fn;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// router初始化</span></div><div class="line">  <span class="keyword">this</span>.lazyrouter();</div><div class="line">  <span class="keyword">var</span> router = <span class="keyword">this</span>._router;</div><div class="line">  </div><div class="line">  <span class="keyword">var</span> fns = flatten(slice.call(<span class="built_in">arguments</span>, offset));</div><div class="line">  fns.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</div><div class="line">    <span class="comment">// non-express app</span></div><div class="line">    <span class="keyword">if</span> (!fn || !fn.handle || !fn.set) &#123;</div><div class="line">      <span class="keyword">return</span> router.use(path, fn);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    debug(<span class="string">'.use app under %s'</span>, path);</div><div class="line">    fn.mountpath = path;</div><div class="line">    fn.parent = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">    <span class="comment">// restore .app property on req and res</span></div><div class="line">    router.use(path, <span class="function"><span class="keyword">function</span> <span class="title">mounted_app</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> orig = req.app;</div><div class="line">      fn.handle(req, res, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">        setPrototypeOf(req, orig.request)</div><div class="line">        setPrototypeOf(res, orig.response)</div><div class="line">        next(err);</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">// mounted an app</span></div><div class="line">    fn.emit(<span class="string">'mount'</span>, <span class="keyword">this</span>);</div><div class="line">  &#125;, <span class="keyword">this</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>针对app.METHODS的代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">methods.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>)</span>&#123;</div><div class="line">  app[method] = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (method === <span class="string">'get'</span> &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</div><div class="line">      <span class="comment">// app.get(setting)</span></div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.set(path);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 路由初始化</span></div><div class="line">    <span class="keyword">this</span>.lazyrouter();</div><div class="line">    <span class="keyword">var</span> route = <span class="keyword">this</span>._router.route(path);</div><div class="line">    route[method].apply(route, slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="路由详解"><a href="#路由详解" class="headerlink" title="路由详解"></a>路由详解</h3><p>在上面两种中间件的实现代码中，都调用了 <code>this.lazyrouter()</code> 方法，所有涉及到路由的方法都会调用这个方法，作用是初始化一个应用的内部路由。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">app.lazyrouter = <span class="function"><span class="keyword">function</span> <span class="title">lazyrouter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>._router) &#123;</div><div class="line">    <span class="comment">// 生成一个路由实例</span></div><div class="line">    <span class="keyword">this</span>._router = <span class="keyword">new</span> Router(&#123;</div><div class="line">        caseSensitive: <span class="keyword">this</span>.enabled(<span class="string">'case sensitive routing'</span>),</div><div class="line">        strict: <span class="keyword">this</span>.enabled(<span class="string">'strict routing'</span>)</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">this</span>._router.use(query(<span class="keyword">this</span>.get(<span class="string">'query parser fn'</span>)));</div><div class="line">    <span class="keyword">this</span>._router.use(middleware.init(<span class="keyword">this</span>));</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>针对第一个默认路由，可以看下具体调用了哪些方法，最终实现了什么逻辑：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.get(<span class="string">'query parser fn'</span>);</div><div class="line"><span class="comment">// 上面的 get 方法同 app.get，可以在 methods.forEach 循环处理时，如果 get 方法的入参长度为1时，会调用 this.set(arg)</span></div><div class="line"><span class="comment">// 在set方法中，有针对 'query parser' 的处理</span></div><div class="line"><span class="comment">// 最终，query 方法实现了将 req.query 进行 querystring.parse 的一个解析过程</span></div><div class="line"><span class="keyword">case</span> <span class="string">'query parser'</span>:</div><div class="line">  <span class="keyword">this</span>.set(<span class="string">'query parser fn'</span>, compileQueryParser(val));</div><div class="line">  <span class="keyword">break</span>;</div></pre></td></tr></table></figure></p>
<p>针对第二个默认路由 init，是给 app 上的暴露出的 req、res 继承 node 原生的 request 和 response 的一些属性。</p>
<p>之所以不在 <code>defaultConfiguration</code> 方法中进行这一步路由的初始化，原因在于设置路由的相关参数需要调用app.set方法，这个方法明显需要有app实例，如果在获取app实例的时候就初始化了一个路由，这个路由的参数就没办法配置了。因此，在获取app实例后，必须先对路由参数进行配置，然后再调用对应的app.use等方法。</p>
<h4 id="app-Methods"><a href="#app-Methods" class="headerlink" title="app.Methods"></a>app.Methods</h4><p>我们先以 <code>app.get</code> 为例，通过断点调试的方式来查看 <code>app.get</code> 这种路由的 <code>_router</code> 对象是什么结构。</p>
<p><img src="https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiZmI2ODUxODEtZjg1Yi00MTc3LTg5MTUtMTMxYTY5OTU2NWU2IiwicmVzb3VyY0d1aWQiOiIzMzk0MTlkZi05NDNlLTQzNzAtOTc0YS1mYjI5NmU3MzQxMDgifQ==" alt="702ca38d0160d8b82ab5d1b7a552bec1.png"></p>
<p>上面的截图是当我们初始化一个 express 实例，并设置了一个 <code>app.get()</code> 的路由后，在 app.listen 处添加断点进行调试时的 app 实例的属性。可以看到在 <code>app._router</code> 中有一个 stack，里面按顺存放着三个 layer 对象，分别是初始化时的 query 和 init 两个路由，和第三个则是我们所设置的 get 路由。每一个 layer 中包含路由处理的回调函数 <code>handle</code>，路由对象 <code>route&lt;Route&gt;</code>，该对象中还包含一个存有 Layer 对象的栈（stack)，就和 <code>app._router.stack</code> 相同。</p>
<p><img src="https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiZmI2ODUxODEtZjg1Yi00MTc3LTg5MTUtMTMxYTY5OTU2NWU2IiwicmVzb3VyY0d1aWQiOiJkOGY5MWM1ZC1lOWRkLTRmNDYtYmJlMC01MGRkNjJjMDUzMTYifQ==" alt="81b68f825db7a3f5bf1ff7d87c09496d.png"></p>
<p>根据上面对于 <code>app.get</code> 这种路由的结构分析，我们可以先猜想它的实现流程：</p>
<ul>
<li><p>首先根据传入的路径封装一个Route对象，再对传入的回调函数封装成Layer对象，接着把这个Layer对象push到Route.stack里面去</p>
</li>
<li><p>再创建一个默认Layer(跟app.use里面Layer的同级)，把步骤一中的Route挂到这个Layer.route属性上面，而这个Layer对象，会被push到app._router.stack里面</p>
</li>
</ul>
<h4 id="app-use"><a href="#app-use" class="headerlink" title="app.use"></a>app.use</h4><p>接下来我们来看 <code>app.use</code> 这种路由又有什么不同。</p>
<p><img src="https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiZmI2ODUxODEtZjg1Yi00MTc3LTg5MTUtMTMxYTY5OTU2NWU2IiwicmVzb3VyY0d1aWQiOiIyNzA3MmYzNC03ZTY0LTQ0ODUtOTQxNC05M2RkMmVjNTkwMWYifQ==" alt="08bdd22fe221f77141d8af6afb5ac8bc.png"></p>
<p>可以看到，在这种路由中，除了 <code>query</code> 和 <code>init</code> 两个初始化路由的方法外，第三个真正的回调方法被封装成的 <code>Layer</code> 对象中，<code>route</code> 属性的值为 <code>undefined</code>。<br>所以我们可以猜想：在 <code>app.use</code> 这种路由里，传入的参数（路径、回调函数）会被封装成 <code>Layer</code> 对象（其中 <code>route</code> 属性为 <code>undefined</code>），压入 <code>app._router.stack</code> 栈中。</p>
<h4 id="两种路由的源码实现"><a href="#两种路由的源码实现" class="headerlink" title="两种路由的源码实现"></a>两种路由的源码实现</h4><p>接下来我们通过源码来分析我们写的 <code>app.use(&#39;/main&#39;, someFun())</code> 是如何成为一个 layer 对象并压入 <code>app._router</code> 的路由栈中的。</p>
<p><strong>首先来看 <code>app.use</code>：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">app.use = <span class="function"><span class="keyword">function</span> <span class="title">use</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> path = <span class="string">'/'</span>;   <span class="comment">// 设置一个默认的路由方法路径</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="comment">// 设置路由，同样也是由lazyrouter进行路由对象的初始化：this._router = new Router(&#123;&#125;)</span></div><div class="line">  <span class="keyword">this</span>.lazyrouter();</div><div class="line">  <span class="keyword">var</span> router = <span class="keyword">this</span>._router;</div><div class="line"></div><div class="line">  fns.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</div><div class="line">    <span class="comment">// router.use是接下来重点要看的方法</span></div><div class="line">    router.use(path, <span class="function"><span class="keyword">function</span> <span class="title">mounted_app</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;, <span class="keyword">this</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>接下来看 Router 对象的 use 方法实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">proto.use = <span class="function"><span class="keyword">function</span> <span class="title">use</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> path = <span class="string">'/'</span>;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="keyword">var</span> callbacks = flatten(slice.call(<span class="built_in">arguments</span>, offset));</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; callbacks.length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> fn = callbacks[i];</div><div class="line">    <span class="comment">// 针对传入路由中的每一个回调方法，都包装成一个 Layer 对象并压入</span></div><div class="line">    <span class="keyword">var</span> layer = <span class="keyword">new</span> Layer(path, &#123;</div><div class="line">      sensitive: <span class="keyword">this</span>.caseSensitive,</div><div class="line">      strict: <span class="literal">false</span>,</div><div class="line">      end: <span class="literal">false</span></div><div class="line">    &#125;, fn);</div><div class="line">    layer.route = <span class="literal">undefined</span>;</div><div class="line">    <span class="keyword">this</span>.stack.push(layer);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>从代码中可以看到，与我们的猜想一致，<code>app.use</code> 这种路由的实现，是将传入的一个个路径或回调方法等参数封装成 <code>Layer</code> 对象压入 <code>_router.stack</code> 栈中。</p>
<p><strong>然后来看 <code>app.get</code> 这种路由的代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// methods 中包含各种请求类型等，get 就包含在其中</span></div><div class="line">methods.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>)</span>&#123;</div><div class="line">  app[method] = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (method === <span class="string">'get'</span> &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</div><div class="line">      <span class="comment">// app.get(setting)</span></div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.set(path);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.lazyrouter();  <span class="comment">// 路由对象 Router 初始化</span></div><div class="line">    <span class="keyword">var</span> route = <span class="keyword">this</span>._router.route(path);</div><div class="line">    route[method].apply(route, slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面代码中最终返回的是 <code>app</code>，那么这端代码对 <code>app</code> 进行了什么样的操作呢？我们可以将目光聚焦在 <code>route[method].apply()</code> 这行代码上。接下来我们可以看下 <code>route</code> 到底是个什么东西。<code>this._router.route</code> 的代码实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">proto.route = <span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">path</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> route = <span class="keyword">new</span> Route(path);</div><div class="line"></div><div class="line">  <span class="keyword">var</span> layer = <span class="keyword">new</span> Layer(path, &#123;</div><div class="line">    sensitive: <span class="keyword">this</span>.caseSensitive,</div><div class="line">    strict: <span class="keyword">this</span>.strict,</div><div class="line">    end: <span class="literal">true</span></div><div class="line">  &#125;, route.dispatch.bind(route));</div><div class="line"></div><div class="line">  layer.route = route;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.stack.push(layer);</div><div class="line">  <span class="keyword">return</span> route;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里可以看到返回的 <code>route</code> 是一个 <code>Route</code> 对象，在这个对象中将参数封装成了 <code>Layer</code> 对象推入了 <code>app._router.stack</code> 中。</p>
<p>接下来我们看一下 <code>Route</code> 对象中的一些实现代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Route</span>(<span class="params">path</span>) </span>&#123;</div><div class="line">  <span class="comment">// Route对象初始化时添加了一个空数组stack属性</span></div><div class="line">  <span class="keyword">this</span>.path = path;</div><div class="line">  <span class="keyword">this</span>.stack = [];</div><div class="line">  <span class="keyword">this</span>.methods = &#123;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 对于app.METHODS这种路由，将路由参数（路径、回调方法）包装成Layer对象压入Route.stack中</span></div><div class="line">methods.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>)</span>&#123;</div><div class="line">  Route.prototype[method] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> handles = flatten(slice.call(<span class="built_in">arguments</span>));</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; handles.length; i++) &#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">      <span class="keyword">var</span> layer = Layer(<span class="string">'/'</span>, &#123;&#125;, handle);</div><div class="line">      layer.method = method;</div><div class="line"></div><div class="line">      <span class="keyword">this</span>.methods[method] = <span class="literal">true</span>;</div><div class="line">      <span class="keyword">this</span>.stack.push(layer);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>至此，在调用 <code>route[method].apply()</code> 时就会为 <code>app.METHODS</code> 这种类型的路由的 <code>Layer</code> 中添加 <code>route&lt;Route&gt;</code> 属性。</p>
<p><img src="https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiZmI2ODUxODEtZjg1Yi00MTc3LTg5MTUtMTMxYTY5OTU2NWU2IiwicmVzb3VyY0d1aWQiOiIyYWEwMDk1ZS1jOGQwLTRkNjMtOWUzNi0yNGZmMjY4NjllOTkifQ==" alt="e6778eb14b0b4f77fc6bc60d49e9a053.png"></p>

        
        </div>

        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://keefe.wang/2020/03/15/2020-03-05-source-code-reading-express-router.html" data-id="ckk6vuavr004gow90ebsbeg6t" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
    
</article>

        
            <article id="post-2020-01-12-Javascript-module-history" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        <div class="article-corner"></div>
        

        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2020/01/12/2020-01-12-Javascript-module-history.html">JavaScript模块化</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2020/01/12/2020-01-12-Javascript-module-history.html">
            <time datetime="2020-01-12T04:30:00.000Z" itemprop="datePublished">2020-01-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Reading/">Reading</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>, <a class="tag-link" href="/tags/规范/">规范</a>, <a class="tag-link" href="/tags/读书笔记/">读书笔记</a>
    </div>

                    </div>
                
            </header>
        

        

        <div class="article-entry" itemprop="articleBody">

        
            
            <h4 id="名词定义先行"><a href="#名词定义先行" class="headerlink" title="名词定义先行"></a>名词定义先行</h4><p>模块化主要解决以下三个问题：</p>
<ul>
<li>代码分离</li>
<li>不同模块间的依赖定义</li>
<li>代码到执行环境的传递</li>
</ul>
<p>能够解决其中一两个点的解决方案我们称之为“<strong>模式</strong>”，能够解决全部三个问题的方案我们称之为“<strong>模块系统</strong>”；</p>
<p>我们将封装好的导出实例（对象、方法等）和引入的实例称为“<strong>模块格式</strong>”；用“分离依赖定义（detached dependency definitions，即用不同文件存储不同文件）”来描述模块系统中可被使用的独立依赖。</p>
<h4 id="关于模块化所解决的问题"><a href="#关于模块化所解决的问题" class="headerlink" title="关于模块化所解决的问题"></a>关于模块化所解决的问题</h4><ul>
<li>命名冲突</li>
</ul>
<p>在1995-1999年间，使用var来定义全局变量是非常方便的，因为当时的JavaScript就是用来编写脚本处理小微任务，而随着应用的代码量上升，全局变量的缺点就越来越明显，因此我们甚至不能引用第三方脚本。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file greeting.js</span></div><div class="line"><span class="keyword">var</span> helloInLang = &#123;</div><div class="line">    en: <span class="string">'Hello world!'</span>,</div><div class="line">    es: <span class="string">'¡Hola mundo!'</span>,</div><div class="line">    ru: <span class="string">'Привет мир!'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeHello</span>(<span class="params">lang</span>) </span>&#123;</div><div class="line">    <span class="built_in">document</span>.write(helloInLang[lang]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// file hello.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeHello</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">document</span>.write(<span class="string">'The script is broken'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>支持大量代码仓库</li>
</ul>
<p>由于编写应用的代码量越来越大，我们常常需要将代码分为多个脚本文件逐一引入，这导致了越来越多数量的脚本文件需要我们手动维护，而且还要考虑脚本引入的顺序！这真是太令人头痛！</p>
<h4 id="Directly-Defined-Dependencies"><a href="#Directly-Defined-Dependencies" class="headerlink" title="Directly Defined Dependencies"></a>Directly Defined Dependencies</h4><p>1999年提出的首次对于独立依赖的模式“直接定义依赖”。该模式是由 Erik Arvidsson 在1999年提出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file greeting.js</span></div><div class="line">dojo.provide(<span class="string">"app.greeting"</span>);</div><div class="line"></div><div class="line">app.greeting.helloInLang = &#123;</div><div class="line">    en: <span class="string">'Hello world!'</span>,</div><div class="line">    es: <span class="string">'¡Hola mundo!'</span>,</div><div class="line">    ru: <span class="string">'Привет мир!'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">app.greeting.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params">lang</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> app.greeting.helloInLang[lang];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// file hello.js</span></div><div class="line">dojo.provide(<span class="string">"app.hello"</span>);</div><div class="line"></div><div class="line">dojo.require(<span class="string">'app.greeting'</span>);</div><div class="line"></div><div class="line">app.hello = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="built_in">document</span>.write(app.greeting.sayHello(<span class="string">'es'</span>));</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>代码使用dojo 1.6编写，其中dojo.provide用来定义模块，获取模块时需要使用dojo.require</p>
<h4 id="命名空间模式"><a href="#命名空间模式" class="headerlink" title="命名空间模式"></a>命名空间模式</h4><p>在JavaScript中，函数是<code>first class citizens</code>，意味着可以被赋给变量，也可以被函数返回。命名空间模式是由 Erik Arvidsson于2002年发明的互联网应用开发工具Bindows开始形成。该模式类似于：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file app.js</span></div><div class="line"><span class="keyword">var</span> app = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// file greeting.js</span></div><div class="line">app.helloInLang = &#123;</div><div class="line">    en: <span class="string">'Hello world!'</span>,</div><div class="line">    es: <span class="string">'¡Hola mundo!'</span>,</div><div class="line">    ru: <span class="string">'Привет мир!'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// file hello.js</span></div><div class="line">app.writeHello = <span class="function"><span class="keyword">function</span> (<span class="params">lang</span>) </span>&#123;</div><div class="line">    <span class="built_in">document</span>.write(app.helloInLang[lang]);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可见，所有的逻辑和数据都被放在了app对象的属性中，所以不会污染其他全局变量。尽管该模式看似让代码组织有了一定的规律，但是很明显上面的数据和逻辑仍然没有被隔离，我们很轻易就可以修改这些代码。</p>
<h4 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h4><p>模块模式的主旨是将数据和逻辑代码放在闭包中并提供一些公用方法作为对外接口对这些资源进行访问<a href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html" target="_blank" rel="external">JavaScript Module Pattern: In-Depth</a>。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> greeting = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> <span class="built_in">module</span> = &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> helloInLang = &#123;</div><div class="line">        en: <span class="string">'Hello world!'</span>,</div><div class="line">        es: <span class="string">'¡Hola mundo!'</span>,</div><div class="line">        ru: <span class="string">'Привет мир!'</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="built_in">module</span>.getHello = <span class="function"><span class="keyword">function</span> (<span class="params">lang</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> helloInLang[lang];</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="built_in">module</span>.writeHello = <span class="function"><span class="keyword">function</span> (<span class="params">lang</span>) </span>&#123;</div><div class="line">        <span class="built_in">document</span>.write(<span class="built_in">module</span>.getHello(lang))</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="built_in">module</span>;</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<p>这种将数据和逻辑闭包在立即调用方法中的方式在2008年Douglas Crockford发表的《JavaScript the Good Parts》一书中被称作“模块”。</p>
<h4 id="模板定义依赖（Template-Defined-Dependencies"><a href="#模板定义依赖（Template-Defined-Dependencies" class="headerlink" title="模板定义依赖（Template Defined Dependencies)"></a>模板定义依赖（Template Defined Dependencies)</h4><p>当有多个script文件依赖时，我们可以使用一个模板来将这些依赖进行顺序管理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file app.tmp.js</span></div><div class="line"></div><div class="line"><span class="comment">/*borschik:include:../lib/main.js*/</span></div><div class="line"><span class="comment">/*borschik:include:../lib/helloInLang.js*/</span></div><div class="line"><span class="comment">/*borschik:include:../lib/writeHello.js*/</span></div><div class="line"></div><div class="line"><span class="comment">// file main.js</span></div><div class="line"><span class="keyword">var</span> app = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// file helloInLang.js</span></div><div class="line">app.helloInLang = &#123;</div><div class="line">    en: <span class="string">'Hello world!'</span>,</div><div class="line">    es: <span class="string">'¡Hola mundo!'</span>,</div><div class="line">    ru: <span class="string">'Привет мир!'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// file writeHello.js</span></div><div class="line">app.writeHello = <span class="function"><span class="keyword">function</span> (<span class="params">lang</span>) </span>&#123;</div><div class="line">    <span class="built_in">document</span>.write(app.helloInLang[lang]);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="注释定义依赖"><a href="#注释定义依赖" class="headerlink" title="注释定义依赖"></a>注释定义依赖</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file helloInLang.js</span></div><div class="line"><span class="keyword">var</span> helloInLang = &#123;</div><div class="line">    en: <span class="string">'Hello world!'</span>,</div><div class="line">    es: <span class="string">'¡Hola mundo!'</span>,</div><div class="line">    ru: <span class="string">'Привет мир!'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// file sayHello.js</span></div><div class="line"></div><div class="line"><span class="comment">/*! lazy require scripts/app/helloInLang.js */</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">lang</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> helloInLang[lang];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// file hello.js</span></div><div class="line"></div><div class="line"><span class="comment">/*! lazy require scripts/app/sayHello.js */</span></div><div class="line"></div><div class="line"><span class="built_in">document</span>.write(sayHello(<span class="string">'en'</span>));</div></pre></td></tr></table></figure>
<p>这种依赖的工作方式是：首先下载这些依赖文件，并进行文件内容解析，解析到有依赖存在的注释时迭代下载、解析……</p>
<h4 id="外部定义依赖"><a href="#外部定义依赖" class="headerlink" title="外部定义依赖"></a>外部定义依赖</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file deps.json</span></div><div class="line">&#123;</div><div class="line">    <span class="string">"files"</span>: &#123;</div><div class="line">        <span class="string">"main.js"</span>: [<span class="string">"sayHello.js"</span>],</div><div class="line">        <span class="string">"sayHello.js"</span>: [<span class="string">"helloInLang.js"</span>],</div><div class="line">        <span class="string">"helloInLang.js"</span>: []</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// file helloInLang.js</span></div><div class="line"><span class="keyword">var</span> helloInLang = &#123;</div><div class="line">    en: <span class="string">'Hello world!'</span>,</div><div class="line">    es: <span class="string">'¡Hola mundo!'</span>,</div><div class="line">    ru: <span class="string">'Привет мир!'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// file sayHello.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">lang</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> helloInLang[lang];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// file main.js</span></div><div class="line"><span class="built_in">console</span>.log(sayHello(<span class="string">'en'</span>));</div></pre></td></tr></table></figure>
<p>deps.json文件就是我们定义所有依赖的外部上下文依赖文件。当运行这个应用时，加载器会获取到这个文件，将这个文件中的依赖按照数组的正确顺序进行读取和加载。lodash就是使用的这种方法进行依赖加载的。</p>
<h4 id="沙箱模式"><a href="#沙箱模式" class="headerlink" title="沙箱模式"></a>沙箱模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file sandbox.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sandbox</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> modules = [];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> Sandbox.modules) &#123;</div><div class="line">        modules.push(i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; modules.length; i++) &#123;</div><div class="line">        <span class="keyword">this</span>[modules[i]] = Sandbox.modules[modules[i]]();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    callback(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// file greeting.js</span></div><div class="line">Sandbox.modules = Sandbox.modules || &#123;&#125;;</div><div class="line"></div><div class="line">Sandbox.modules.greeting = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> helloInLang = &#123;</div><div class="line">        en: <span class="string">'Hello world!'</span>,</div><div class="line">        es: <span class="string">'¡Hola mundo!'</span>,</div><div class="line">        ru: <span class="string">'Привет мир!'</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        sayHello: <span class="function"><span class="keyword">function</span> (<span class="params">lang</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> helloInLang[lang];</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// file app.js</span></div><div class="line"><span class="keyword">new</span> Sandbox(<span class="function"><span class="keyword">function</span>(<span class="params">box</span>) </span>&#123;</div><div class="line">    <span class="built_in">document</span>.write(box.greeting.sayHello(<span class="string">'es'</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>该模式的关键是使用一个全局的构造函数来代替全局对象，依赖模块可以被定义为这个构造函数的属性。</p>
<h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file greeting.js</span></div><div class="line">angular.module(<span class="string">'greeter'</span>, [])</div><div class="line">    .value(<span class="string">'greeting'</span>, &#123;</div><div class="line">        helloInLang: &#123;</div><div class="line">            en: <span class="string">'Hello world!'</span>,</div><div class="line">            es: <span class="string">'¡Hola mundo!'</span>,</div><div class="line">            ru: <span class="string">'Привет мир!'</span></div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        sayHello: <span class="function"><span class="keyword">function</span>(<span class="params">lang</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.helloInLang[lang];</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"><span class="comment">// file app.js</span></div><div class="line">angular.module(<span class="string">'app'</span>, [<span class="string">'greeter'</span>])</div><div class="line">    .controller(<span class="string">'GreetingController'</span>, [<span class="string">'$scope'</span>, <span class="string">'greeting'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$scope, greeting</span>) </span>&#123;</div><div class="line">        $scope.phrase = greeting.sayHello(<span class="string">'en'</span>);</div><div class="line">    &#125;]);</div></pre></td></tr></table></figure>
<h4 id="CommonJS-Modules"><a href="#CommonJS-Modules" class="headerlink" title="CommonJS Modules"></a>CommonJS Modules</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file greeting.js</span></div><div class="line"><span class="keyword">var</span> helloInLang = &#123;</div><div class="line">    en: <span class="string">'Hello world!'</span>,</div><div class="line">    es: <span class="string">'¡Hola mundo!'</span>,</div><div class="line">    ru: <span class="string">'Привет мир!'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sayHello = <span class="function"><span class="keyword">function</span> (<span class="params">lang</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> helloInLang[lang];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports.sayHello = sayHello;</div><div class="line"></div><div class="line"><span class="comment">// file hello.js</span></div><div class="line"><span class="keyword">var</span> sayHello = <span class="built_in">require</span>(<span class="string">'./lib/greeting'</span>).sayHello;</div><div class="line"><span class="keyword">var</span> phrase = sayHello(<span class="string">'en'</span>);</div><div class="line"><span class="built_in">console</span>.log(phrase);</div></pre></td></tr></table></figure>
<p>CommonJS使用require和module两个标志来表示依赖的引入和导出。</p>
<h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file lib/greeting.js</span></div><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> helloInLang = &#123;</div><div class="line">        en: <span class="string">'Hello world!'</span>,</div><div class="line">        es: <span class="string">'¡Hola mundo!'</span>,</div><div class="line">        ru: <span class="string">'Привет мир!'</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        sayHello: <span class="function"><span class="keyword">function</span> (<span class="params">lang</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> helloInLang[lang];</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// file hello.js</span></div><div class="line">define([<span class="string">'./lib/greeting'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">greeting</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> phrase = greeting.sayHello(<span class="string">'en'</span>);</div><div class="line">    <span class="built_in">document</span>.write(phrase);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
        
        </div>

        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://keefe.wang/2020/01/12/2020-01-12-Javascript-module-history.html" data-id="ckk6vuawe004wow90epc4aiwt" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
    
</article>

        
            <article id="post-2020-01-09-how-to-be-a-pragmatic-programmer" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        <div class="article-corner"></div>
        

        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2020/01/09/2020-01-09-how-to-be-a-pragmatic-programmer.html">怎样做一个Pragmatic Programmer</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2020/01/09/2020-01-09-how-to-be-a-pragmatic-programmer.html">
            <time datetime="2020-01-09T04:30:00.000Z" itemprop="datePublished">2020-01-09</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Reading/">Reading</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>, <a class="tag-link" href="/tags/规范/">规范</a>, <a class="tag-link" href="/tags/读书笔记/">读书笔记</a>
    </div>

                    </div>
                
            </header>
        

        

        <div class="article-entry" itemprop="articleBody">

        
            
            <h4 id="What-maks-a-pragmatic-programmer"><a href="#What-maks-a-pragmatic-programmer" class="headerlink" title="What maks a pragmatic programmer"></a>What maks a pragmatic programmer</h4><p>1.Early adopter/faster adapter: 善于学习新的技术并能够尝试将其集成在自己的知识库中;<br>2.Inquisitive：善于提问、保持好奇心；<br>3.Critical thinker：辩证地看待问题而非一味接受前人的话语；<br>4.Realistic：发觉问题的本质，认识问题的难度并能估计解决该问题的时间；<br>5.Jack of all trades：能够转移领域之后快速适应，通过掌握核心基础知识；<br>6.We who cut mere stones must always be envisioning cathedrals.<br>7.持续以上过程</p>
<h4 id="TIPs"><a href="#TIPs" class="headerlink" title="TIPs"></a>TIPs</h4><p>Tip1.在乎你所做的事情<br>Tip2.不断思考所做的事情，不断从big picture进行思考<br>Tip3.提供解决方案而非各种借口<br>Tip4.“不留一扇破窗”，一旦发现问题及时修复<br>Tip5.做项目的催化剂，吸引资源到一个可预见成功的项目中<br>Tip6.时刻牢记“蓝图”<br>Tip7.将产品质量作为需求之一进行考量<br>Tip8.定期对知识进行投资<br>Tip9.批判地看待自己的所见所闻</p>
<h4 id="持续进行知识投资"><a href="#持续进行知识投资" class="headerlink" title="持续进行知识投资"></a>持续进行知识投资</h4><p>1.定期地进行知识投资<br>2.注重知识的多样性<br>3.在2的基础上注意控制风险<br>4.在一个技术还未成熟前进行学习<br>5.时常对知识库进行review</p>
<h5 id="e-g"><a href="#e-g" class="headerlink" title="e.g."></a>e.g.</h5><p>1.一年至少学习一种新的语言<br>2.一个季度看一本技术书籍（甚至一个月、可涉及非技术例如用户等）<br>3.上课<br>4.参与到用户群体中<br>5.在不同环境中进行试验<br>6.跟上潮流：订阅杂志或期刊</p>

        
        </div>

        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://keefe.wang/2020/01/09/2020-01-09-how-to-be-a-pragmatic-programmer.html" data-id="ckk6vuau40019ow909vrpgkma" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
    
</article>

        
            <article id="post-2019-12-21-clean-code-note" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        <div class="article-corner"></div>
        

        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2019/12/21/2019-12-21-clean-code-note.html">Clean Code规范整理</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2019/12/21/2019-12-21-clean-code-note.html">
            <time datetime="2019-12-21T03:30:00.000Z" itemprop="datePublished">2019-12-21</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Reading/">Reading</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>, <a class="tag-link" href="/tags/规范/">规范</a>, <a class="tag-link" href="/tags/读书笔记/">读书笔记</a>
    </div>

                    </div>
                
            </header>
        

        

        <div class="article-entry" itemprop="articleBody">

        
            
            <h4 id="变量："><a href="#变量：" class="headerlink" title="变量："></a>变量：</h4><pre><code>1.变量名有意义
2.不使用魔法数字
3.参数用变量而不是数字
4.mapping中的iterator变量命名清楚
5.属性中不要出现类名/对象名
6.方法参数使用默认值检查参数是否为undefined
</code></pre><h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><pre><code>1.使用一到两个形参（或方法复杂、使用对象类型参数、形参的解构赋值）
2.一个方法应该只做一件事！
3.方法名要能自我解释
4.如果出现重复的代码要精练和抽象
5.使用Object.assign给对象赋值
6.（如果方法中出现flag，应当分成两个方法处理）
7.尽量避免方法的副作用（更改全局变量、多个方法写一个文件、公用一个状态等）
8.处理数组、对象时最好处理其复本
9.修改原生对象和方法最好使用class新建
10.尽量使用函数式编程代替命令式编程
11.存在多个判断条件时用方法来包括，避免使用非类型条件
12.避免使用条件语句，使用多态性（class）来代替
13.避免类型判断
</code></pre><h4 id="对象与数据结构"><a href="#对象与数据结构" class="headerlink" title="对象与数据结构"></a>对象与数据结构</h4><pre><code>1.使用class来实现继承
2.使用链式方法调用
3.谨慎使用继承（仅在以下三种情况使用）：
    a.关系为is-a而不是has-a的时候
    b.基类可以被复用时
    c.想通过更改基类来进行全局属性的改变时
</code></pre><h4 id="SOLID原则"><a href="#SOLID原则" class="headerlink" title="SOLID原则"></a>SOLID原则</h4><pre><code>1.SRP（单一职责）：一个类要足够内聚，负责尽量单一的功能，减少类的改动；
2.OCP（开闭原则）：对扩展开放，对修改封闭；
3.LSP（里式替换）：父类特性在子类中要完全继承无变化，即在父类对象被替换为子类对象时无影响；
4.ISP（接口隔离）：不同接口之间需要进行隔离；
5.DIP（依赖倒置）：高层模块不能依赖底层模块，应都依赖于抽象；
</code></pre><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><pre><code>1.用Promises，不用回调函数callbacks（用async/await更好）
</code></pre><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><pre><code>1.不确定的代码需要try...catch...
2.不要忘了catch里的错误处理、reject里的错误处理
</code></pre><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><pre><code>1.驼峰、下划线、大小写都需要保持一致
</code></pre>
        
        </div>

        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://keefe.wang/2019/12/21/2019-12-21-clean-code-note.html" data-id="ckk6vuau30016ow90ka10649w" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
    
</article>

        
        <nav id="page-nav">
            <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
        </nav>
    
    </section>

    
    <aside id="sidebar">
   
        
    <div class="widget-wrap">
        <div class="widget-corner"></div>
        <h3 class="widget-title">Recent Posts</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/08/13/2020-08-13-translate-how-browser-renders-webpage.html" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Translate/">Translate</a></p>
                            <p class="item-title"><a href="/2020/08/13/2020-08-13-translate-how-browser-renders-webpage.html" class="title">[翻译]浏览器怎样渲染一个页面？—— DOM，CSSOM及其渲染</a></p>
                            <p class="item-date"><time datetime="2020-08-13T14:02:03.000Z" itemprop="datePublished">2020-08-13</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/07/29/2020-07-29-use-vue-test-utils-to-test-components.html" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Document/">Document</a></p>
                            <p class="item-title"><a href="/2020/07/29/2020-07-29-use-vue-test-utils-to-test-components.html" class="title">使用 vue-test-utils 进行测试</a></p>
                            <p class="item-date"><time datetime="2020-07-29T14:23:00.000Z" itemprop="datePublished">2020-07-29</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/07/23/2020-07-23-advanced-function-in-vue.html" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Document/">Document</a></p>
                            <p class="item-title"><a href="/2020/07/23/2020-07-23-advanced-function-in-vue.html" class="title">Vue 高级用法与精粹</a></p>
                            <p class="item-date"><time datetime="2020-07-23T11:32:00.000Z" itemprop="datePublished">2020-07-23</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/07/22/2020-07-22-things-need-to-be-aware-of-in-vue.html" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Document/">Document</a></p>
                            <p class="item-title"><a href="/2020/07/22/2020-07-22-things-need-to-be-aware-of-in-vue.html" class="title">Vue 中容易被忽视的小功能</a></p>
                            <p class="item-date"><time datetime="2020-07-22T11:03:00.000Z" itemprop="datePublished">2020-07-22</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/06/03/2020-06-03-advanced-eventloop-in-javascript.html" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Document/">Document</a></p>
                            <p class="item-title"><a href="/2020/06/03/2020-06-03-advanced-eventloop-in-javascript.html" class="title">JavaScript 基于事件循环的并发模型</a></p>
                            <p class="item-date"><time datetime="2020-06-03T08:31:00.000Z" itemprop="datePublished">2020-06-03</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <div class="widget-corner"></div>
        <h3 class="widget-title">Categories</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Document/">Document</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Reading/">Reading</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Research/">Research</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SourceCodeReading/">SourceCodeReading</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Toolkit/">Toolkit</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Translate/">Translate</a><span class="category-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <div class="widget-corner"></div>
        <h3 class="widget-title">Archives</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">十二月 2014</a><span class="archive-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <div class="widget-corner"></div>
        <h3 class="widget-title">Tags</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/API/">API</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Babel/">Babel</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Browser/">Browser</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3/">CSS3</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6/">ES6</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EggJS/">EggJS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Express/">Express</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Framework/">Framework</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Http/">Http</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">23</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JenaAPI/">JenaAPI</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jupyter/">Jupyter</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Knowledge-Base/">Knowledge Base</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Leaflet/">Leaflet</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Map/">Map</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/">Markdown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NodeJS/">NodeJS</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/">Nodejs</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ontology/">Ontology</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Selector/">Selector</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Test/">Test</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VUE/">VUE</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/原型/">原型</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础知识/">基础知识</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/形状文法/">形状文法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据响应/">数据响应</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则表达式/">正则表达式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码学习/">源码学习</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/继承/">继承</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/腾讯地图/">腾讯地图</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/规范/">规范</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/解释器/">解释器</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/说明书/">说明书</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书笔记/">读书笔记</a><span class="tag-list-count">12</span></li></ul>
        </div>
    </div>

    
        
    
        
    <div class="widget-wrap widget-list">
        <div class="widget-corner"></div>
        <h3 class="widget-title">Links</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://hexo.io">Hexo</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
    
</div>






        <footer id="footer" class="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2021 Keefe Wang<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/sanfran1068">Keefe</a>
        </div>
    </div>
</footer>
        


    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>