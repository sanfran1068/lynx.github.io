<!DOCTYPE html>
<html lang=zh>
<head>
    <meta charset="utf-8">
    
    <title>Lynx-Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta property="og:type" content="website">
<meta property="og:title" content="Lynx-Blog">
<meta property="og:url" content="http://keefe.wang/index.html">
<meta property="og:site_name" content="Lynx-Blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lynx-Blog">
    

    
        <link rel="alternate" href="/" title="Lynx-Blog" type="application/atom+xml" />
    

    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


</head>

<body>
    <div id="progress">
        <span></span>
    </div>

    <div id="container">

        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">Lynx-Blog</span>
            </a>

            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>

            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">Home</a>
                
                    <a class="main-nav-link" href="/archives">Archives</a>
                
                    <a class="main-nav-link" href="/categories">Categories</a>
                
                    <a class="main-nav-link" href="/tags">Tags</a>
                
                    <a class="main-nav-link" href="/about">About</a>
                
            </nav>

            <!---->

        </div>
    </div>

    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">Home</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/categories">Categories</a></td>
                
                    <td><a class="main-nav-link" href="/tags">Tags</a></td>
                
                    <td><a class="main-nav-link" href="/about">About</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
    </div>

                </td>
            </tr>
        </table>
    </div>

</header>


            

<div class="slideshow-container">
    <div class="mySlides fade">
        <img src="css/images/1.jpg">
    </div>

    <div class="mySlides fade">
        <img src="css/images/2.jpg">
    </div>

    <div class="mySlides fade">
        <img src="css/images/3.jpg">
    </div>

    <a class="carousel-prev" onclick="plusSlides(-1)"><span class="fa fa-chevron-left"></span></a>
    <a class="carousel-next" onclick="plusSlides(1)"><span class="fa fa-chevron-right"></span></a>
</div>

<script>
    var slideIndex = 1;
    showSlides(slideIndex);

    function plusSlides(n) {
        showSlides(slideIndex += n);
    }

    function currentSlide(n) {
        showSlides(slideIndex = n);
    }

    function showSlides(n) {
        var i;
        var slides = document.getElementsByClassName("mySlides");

        if (n > slides.length) {slideIndex = 1}
        if (n < 1) {slideIndex = slides.length}

        for (i = 0; i < slides.length; i++) {
            slides[i].style.display = "none";
        }

        slides[slideIndex-1].style.display = "block";
    }
</script>

<div class="outer">
    <section id="main">
        
            <article id="post-2020-07-29-use-vue-test-utils-to-test-components" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        <div class="article-corner"></div>
        

        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2020/07/29/2020-07-29-use-vue-test-utils-to-test-components.html">使用 vue-test-utils 进行测试</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2020/07/29/2020-07-29-use-vue-test-utils-to-test-components.html">
            <time datetime="2020-07-29T14:23:00.000Z" itemprop="datePublished">2020-07-29</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Document/">Document</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>, <a class="tag-link" href="/tags/Test/">Test</a>, <a class="tag-link" href="/tags/Vue/">Vue</a>
    </div>

                    </div>
                
            </header>
        

        

        <div class="article-entry" itemprop="articleBody">

        
            
            <h3 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h3><p>我们使用 Vue CLI 脚手架进行项目的创建，按照提示一步步进行项目配置，尽量都选择无任何配置，尤其是自带的测试插件：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vue create vue-test</div></pre></td></tr></table></figure>
<p>新建好项目之后，我们需要在项目根目录下<strong>新建一个 test 目录</strong>来放置我们的测试文件。</p>
<p>由于我们是在 Vue 项目中进行测试，采用的是 vue-test-utils 这个测试工具插件进行测试，所以下面几类 npm 插件是必须要安装的：</p>
<ul>
<li><p>jest 相关</p>
<p>  jest 是 vue-test-utils 官方推荐的测试运行器，所以这个插件是必要的；要使用 jest 来处理 *.vue 文件，需要安装和配置 vue-jest 插件。</p>
  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i --save-dev jest vue-jest</div></pre></td></tr></table></figure>
  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在 package.json 中做如下配置</span></div><div class="line">&#123;</div><div class="line">	<span class="string">"scripts"</span>: &#123;</div><div class="line">		<span class="string">"test"</span>: <span class="string">"jest"</span></div><div class="line">	&#125;,</div><div class="line">	<span class="string">"jest"</span>: &#123;</div><div class="line">    <span class="string">"moduleFileExtensions"</span>: [</div><div class="line">      <span class="string">"js"</span>,</div><div class="line">      <span class="string">"json"</span>,</div><div class="line">      <span class="string">"vue"</span></div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>babel 相关</p>
<p>  我们一般都不可避免地希望在代码中使用 ES2015 的特性，这时我们需要安装 babel 相关的插件，其中 babel-jest 是测试中的 ES2015 特性编译的插件</p>
  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev babel-core babel-preset-env babel-jest</div></pre></td></tr></table></figure>
  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在 package.json 中做如下配置</span></div><div class="line">&#123;</div><div class="line">	<span class="string">"jest"</span>: &#123;</div><div class="line">		<span class="string">"transform"</span>: &#123;</div><div class="line">      <span class="string">".*\\.(vue)$"</span>: <span class="string">"vue-jest"</span>,</div><div class="line">      <span class="string">"^.+\\.js$"</span>: <span class="string">"&lt;rootDir&gt;/node_modules/babel-jest"</span></div><div class="line">    &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 在 .babelrc 或 babel.config.js 文件中做如下配置</span></div><div class="line">&#123;</div><div class="line">  <span class="string">"presets"</span>: [[<span class="string">"env"</span>, &#123; <span class="string">"modules"</span>: <span class="literal">false</span> &#125;]],</div><div class="line">  <span class="string">"env"</span>: &#123;</div><div class="line">    <span class="string">"test"</span>: &#123;</div><div class="line">      <span class="string">"presets"</span>: [[<span class="string">"env"</span>, &#123; <span class="string">"targets"</span>: &#123; <span class="string">"node"</span>: <span class="string">"current"</span> &#125; &#125;]]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>vue-test-utils 依赖浏览器环境，我们使用 JSDOM 在 Node 虚拟浏览器环境运行测试。jest 中有自动设置 JSDOM，如果没有，需要安装以下插件</p>
  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev jsdom jsdom-global</div></pre></td></tr></table></figure>
</li>
</ul>
<p>至此，所以前期的插件安装和配置工作就完成了。这时，我们在 test 目录下新建一个 *.test.js 文件，并在 terminal 中运行 npm run test 命令，就可以进行 vue 组件的测试了。</p>

        
        </div>

        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://keefe.wang/2020/07/29/2020-07-29-use-vue-test-utils-to-test-components.html" data-id="ckk4rtiiu001xfv90qmlr63t8" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
    
</article>

        
            <article id="post-2020-07-23-advanced-function-in-vue" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        <div class="article-corner"></div>
        

        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2020/07/23/2020-07-23-advanced-function-in-vue.html">Vue 高级用法与精粹</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2020/07/23/2020-07-23-advanced-function-in-vue.html">
            <time datetime="2020-07-23T11:32:00.000Z" itemprop="datePublished">2020-07-23</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Document/">Document</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Framework/">Framework</a>, <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>, <a class="tag-link" href="/tags/Vue/">Vue</a>
    </div>

                    </div>
                
            </header>
        

        

        <div class="article-entry" itemprop="articleBody">

        
            
            <h3 id="复用与组合"><a href="#复用与组合" class="headerlink" title="复用与组合"></a>复用与组合</h3><h4 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h4><p>多重继承大致有两种模式，一种就是按照顺序将各个父类进行继承，例如当你需要一个类继承 A、B、C和D的特性，那么可以采用 A ⇒ B ⇒ C ⇒ D 这样一个继承链去继承，这种继承方式的好处是知道每一步继承的父子关系。而大多数情况我们不需要知道这些，只要像 duck typing 一样拥有这些父类的特性即可，Mixin 混入机制就是来解决这个问题。Vue 中也提供给了这样的机制：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myMixin = &#123;</div><div class="line">  methods: &#123;</div><div class="line">    hello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'hello from mixin!'</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Component = Vue.extend(&#123;</div><div class="line">  mixins: [myMixin]</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>比较好理解的，像 methods、computed 这种本身是对象类型的属性，可以直接进行 merge，所遵循的混合规则如下：</p>
<ul>
<li>数据对象在内部会进行递归合并，并在发生冲突时<strong>以组件数据优先</strong></li>
<li>同名钩子函数将合并为一个数组，数组中的所有函数都将在此钩子生效时执行</li>
</ul>
<p>混入也支持全局注入，但是需要注意！这会影响到之后的每一个 Vue 组件实例（不建议使用）：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Vue.mixin(&#123;</div><div class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> myOption = <span class="keyword">this</span>.$options.myOption</div><div class="line">    <span class="keyword">if</span> (myOption) &#123;</div><div class="line">      <span class="built_in">console</span>.log(myOption)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>除了 v-model 和 v-show 等自带的指令之外，也可以自定义指令。自定义指令可以全局注册，也可以在组件内进行局部注册（指令在标签中必须要以 v- 开头）：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Vue.directive(<span class="string">'focus'</span>, &#123;</div><div class="line">  inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">    el.focus()</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">directives: &#123;</div><div class="line">  focus: &#123;</div><div class="line">    inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">      el.focus()</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中出现的 inserted 是指令所在的钩子，指令的钩子有以下五种：</p>
<ul>
<li><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li>
<li><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li>
<li><code>update</code>：所在组件的 VNode 更新时调用，<strong>但是可能发生在其子 VNode 更新之前</strong>。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</li>
<li><code>componentUpdated</code>：指令所在组件的 VNode <strong>及其子 VNode</strong> 全部更新后调用。</li>
<li><code>unbind</code>：只调用一次，指令与元素解绑时调用。</li>
</ul>
<p>上述的钩子函数的参数有四个，分别是 el、binding、vnode、oldVnode，其中，指令的值需要从 binding.value 中获取。                                                             </p>
<p>自定义指令还可以添加动态参数，v-someDirection:[arg]，使用 binding.arg 来获取动态的指令：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"dynamicexample"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-pin:</span>[<span class="attr">direction</span>]=<span class="string">"200"</span>&gt;</span>I am pinned onto the page at 200px to the left.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Vue.directive(<span class="string">'pin'</span>, &#123;</div><div class="line">  bind: <span class="function"><span class="keyword">function</span> (<span class="params">el, binding, vnode</span>) </span>&#123;</div><div class="line">    el.style.position = <span class="string">'fixed'</span></div><div class="line">    <span class="keyword">var</span> s = (binding.arg == <span class="string">'left'</span> ? <span class="string">'left'</span> : <span class="string">'top'</span>)</div><div class="line">    el.style[s] = binding.value + <span class="string">'px'</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 回调函数可以简写，只支持 bind 和 update 两个钩子同时触发时</span></div><div class="line">Vue.directive(<span class="string">'pin'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">el, binding, vnode</span>) </span>&#123;&#125;);</div></pre></td></tr></table></figure>
<p>自定义指令也支持传入对象字面量 <code>&lt;div v-demo=&quot;{ color: &#39;white&#39;, text: &#39;hello!&#39; }&quot;&gt;&lt;/div&gt;</code></p>
<h3 id="渲染函数"><a href="#渲染函数" class="headerlink" title="渲染函数"></a>渲染函数</h3><p>如果想要使用纯 js 的方式来实现视图，可以使用 Vue 提供的 render 函数属性来进行渲染，下面是一个简单的例子：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'anchored-heading'</span>, &#123;</div><div class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> createElement(</div><div class="line">      <span class="string">'h'</span> + <span class="keyword">this</span>.level,   <span class="comment">// 标签名称</span></div><div class="line">      <span class="keyword">this</span>.$slots.default <span class="comment">// 子节点数组</span></div><div class="line">    )</div><div class="line">  &#125;,</div><div class="line">  props: &#123;</div><div class="line">    level: &#123;</div><div class="line">      type: <span class="built_in">Number</span>,</div><div class="line">      required: <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>createElement 这个函数可以创建出一个虚拟 Dom，它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息，所以也被称为 Vnode。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// @returns &#123;VNode&#125;</span></div><div class="line">createElement(</div><div class="line">  <span class="comment">// 必填项一个 HTML 标签名、组件选项对象，或者 resolve 了上述任何一种的一个 async 函数</span></div><div class="line">  <span class="comment">// &#123;String | Object | Function&#125;</span></div><div class="line">  <span class="string">'div'</span>,</div><div class="line"></div><div class="line">  <span class="comment">// 一个与模板中 attribute 对应的**数据对象**，可选项，&#123;Object&#125;。</span></div><div class="line">  &#123;&#125;,</div><div class="line"></div><div class="line">  <span class="comment">// 子级虚拟节点 (VNodes)，由 `createElement()` 构建而成，也可以使用字符串来生成“文本虚拟节点”，可选。</span></div><div class="line">	<span class="comment">// &#123;String | Array&#125;</span></div><div class="line">  [</div><div class="line">    <span class="string">'先写一些文字'</span>,</div><div class="line">    createElement(<span class="string">'h1'</span>, <span class="string">'一则头条'</span>),</div><div class="line">    createElement(MyComponent, &#123;</div><div class="line">      props: &#123;</div><div class="line">        someProp: <span class="string">'foobar'</span></div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  ]</div><div class="line">)</div></pre></td></tr></table></figure>
<p>上面讲到的数据对象，也就是一个节点中的一些属性描述：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="comment">// 与 `v-bind:class` 的 API 相同，</span></div><div class="line">  <span class="comment">// 接受一个字符串、对象或字符串和对象组成的数组</span></div><div class="line">  <span class="string">'class'</span>: &#123;</div><div class="line">    foo: <span class="literal">true</span>,</div><div class="line">    bar: <span class="literal">false</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 与 `v-bind:style` 的 API 相同，</span></div><div class="line">  <span class="comment">// 接受一个字符串、对象，或对象组成的数组</span></div><div class="line">  style: &#123;</div><div class="line">    color: <span class="string">'red'</span>,</div><div class="line">    fontSize: <span class="string">'14px'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 普通的 HTML attribute</span></div><div class="line">  attrs: &#123;</div><div class="line">    id: <span class="string">'foo'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 组件 prop</span></div><div class="line">  props: &#123;</div><div class="line">    myProp: <span class="string">'bar'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// DOM property</span></div><div class="line">  domProps: &#123;</div><div class="line">    innerHTML: <span class="string">'baz'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 事件监听器在 `on` 内，</span></div><div class="line">  <span class="comment">// 但不再支持如 `v-on:keyup.enter` 这样的修饰器。</span></div><div class="line">  <span class="comment">// 需要在处理函数中手动检查 keyCode。</span></div><div class="line">  on: &#123;</div><div class="line">    click: <span class="keyword">this</span>.clickHandler</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 仅用于组件，用于监听原生事件，而不是组件内部使用</span></div><div class="line">  <span class="comment">// `vm.$emit` 触发的事件。</span></div><div class="line">  nativeOn: &#123;</div><div class="line">    click: <span class="keyword">this</span>.nativeClickHandler</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 自定义指令。注意，你无法对 `binding` 中的 `oldValue`</span></div><div class="line">  <span class="comment">// 赋值，因为 Vue 已经自动为你进行了同步。</span></div><div class="line">  directives: [</div><div class="line">    &#123;</div><div class="line">      name: <span class="string">'my-custom-directive'</span>,</div><div class="line">      value: <span class="string">'2'</span>,</div><div class="line">      expression: <span class="string">'1 + 1'</span>,</div><div class="line">      arg: <span class="string">'foo'</span>,</div><div class="line">      modifiers: &#123;</div><div class="line">        bar: <span class="literal">true</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  ],</div><div class="line">  <span class="comment">// 作用域插槽的格式为</span></div><div class="line">  <span class="comment">// &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125;</span></div><div class="line">  scopedSlots: &#123;</div><div class="line">    <span class="keyword">default</span>: <span class="function"><span class="params">props</span> =&gt;</span> createElement(<span class="string">'span'</span>, props.text)</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 如果组件是其它组件的子组件，需为插槽指定名称</span></div><div class="line">  slot: <span class="string">'name-of-slot'</span>,</div><div class="line">  <span class="comment">// 其它特殊顶层 property</span></div><div class="line">  key: <span class="string">'myKey'</span>,</div><div class="line">  ref: <span class="string">'myRef'</span>,</div><div class="line">  <span class="comment">// 如果你在渲染函数中给多个元素都应用了相同的 ref 名，</span></div><div class="line">  <span class="comment">// 那么 `$refs.myRef` 会变成一个数组。</span></div><div class="line">  refInFor: <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>通过 Vue.use() 方法使用插件，必须要在 new Vue() 实例化之前进行注册。Vue.use 会自动阻止多次注册相同插件，届时即使多次调用也只会注册一次该插件。</p>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>Vue.js 允许你自定义过滤器（filters 可作为与 computed 同一级的属性进行配置），可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 在双花括号中 --&gt;</span></div><div class="line">&#123;&#123; message | capitalize &#125;&#125;</div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 在 `v-bind` 中，过滤器可以串联，前一个的输出会作为下一个的输入 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"rawId | capitalize | formatId"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
        
        </div>

        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://keefe.wang/2020/07/23/2020-07-23-advanced-function-in-vue.html" data-id="ckk4rtiii001mfv906sx4wykz" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
    
</article>

        
            <article id="post-2020-07-22-things-need-to-be-aware-of-in-vue" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        <div class="article-corner"></div>
        

        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2020/07/22/2020-07-22-things-need-to-be-aware-of-in-vue.html">Vue 中容易被忽视的小功能</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2020/07/22/2020-07-22-things-need-to-be-aware-of-in-vue.html">
            <time datetime="2020-07-22T11:03:00.000Z" itemprop="datePublished">2020-07-22</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Document/">Document</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Framework/">Framework</a>, <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>, <a class="tag-link" href="/tags/Vue/">Vue</a>
    </div>

                    </div>
                
            </header>
        

        

        <div class="article-entry" itemprop="articleBody">

        
            
            <h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><h4 id="Prop相关"><a href="#Prop相关" class="headerlink" title="Prop相关"></a>Prop相关</h4><p>prop 是父组件向子组件传递数据的一种方式，在父组件中使用 kebab-case 的方式传入数据，在子组件中可以添加 props 属性来获取传入的数据。这是一个单向的通信过程。</p>
<p>可以通过 v-bind 传入动态变量，也可以直接传入字符串值到子组件。</p>
<p>如果子组件中 props 属性中没有声明某些值，那么父组件传入的就是<strong>非 prop 的 attribute</strong>，对于绝大多数 attribute 来说，<strong>从外部提供给组件的值会替换掉组件内部设置好的值</strong>。所以如果传入 type=”text” 就会替换掉 type=”date” 并把它破坏！庆幸的是，<strong>class 和 style attribute</strong> 会稍微智能一些，即两边的值<strong>会被合并（merge）起来，从而得到最终的值</strong>。</p>
<p>可以使用 vm.$attr 属性来获取除 class 和 style 之外的非 prop 的 attribute，可以在父组件中使用 <code>v-bind=&quot;$attr&quot;</code> 传入，还可以通过子组件中的 <code>inheritAttrs: true</code> 字段来控制是否接受父组件传入的非 prop 的 attribute。</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h4><p>使用 v-on 绑定事件时，<strong>最好使用 kebab-case 命名法来命名事件</strong>，因为 v-on 事件监听器在 DOM 模板中会被自动转换为全小写 （因为 HTML 是大小写不敏感的）。</p>
<p>可以使用 <code>v-on=&quot;$listeners&quot;</code> 来将所有的事件监听器指向这个组件的某个特定的子元素，它是一个对象，里面包含了作用在这个组件上所有的监听器（监听事件）。这样，在子组件上可以绑定 vm.$listeners 中所包含的监听事件。</p>
<h4 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h4><p>除了 $emit 和 v-on 这一对好基友之外，vue 还提供了类似 总线（bus）机制的观察者模式的事件监听方案：</p>
<ul>
<li><code>$on(eventName, eventHandler)</code> 侦听一个事件</li>
<li><code>$once(eventName, eventHandler)</code> 一次性侦听一个事件</li>
<li><code>$off(eventName, eventHandler)</code> 停止侦听一个事件</li>
</ul>
<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><ul>
<li>sync<ul>
<li>作用：对 prop 进行简单的“双向绑定”，可以实现简单的父子数据同步</li>
<li>使用：在父组件需要双向绑定的数据上添加 .sync 修饰符，例如 <code>&lt;div&gt;&lt;child :some-prop.sync=&quot;someProp&quot;&gt;&lt;/child&gt;&lt;/div&gt;</code> ；在子组件上使用 vm.$emit 触发数据更新，例如 <code>this.$emit(&#39;update:some-prop&#39;, val)</code></li>
</ul>
</li>
</ul>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><h4 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h4><p>动态组件是通过 <component :is="componentName"></component> 来实现的，但是在切换组件时，会将每个组件的原有状态丢失，这时需要添加一个 keep-alive 标签，例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentTabComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h4><p>Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Vue.component(</div><div class="line">  <span class="string">'async-webpack-example'</span>,</div><div class="line">  <span class="comment">// 这个动态导入会返回一个 `Promise` 对象。</span></div><div class="line">  () =&gt; <span class="keyword">import</span>(<span class="string">'./my-async-component'</span>)</div><div class="line">)</div></pre></td></tr></table></figure>
<h3 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a>Slot</h3><h4 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h4><p>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</p>
<h4 id="default内容"><a href="#default内容" class="headerlink" title="default内容"></a>default内容</h4><p>可以使用 <code>&lt;slot&gt; Default content &lt;/slot&gt;</code> 来设置分发内容的默认值，当没有内容传入时会显示该内容。</p>
<h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><p>有多个插槽需要进行内容分发时，可以使用具名插槽，具体用法如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 子元素设置具名插槽 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 父元素设置分发内容，由 v-slot 属性来指明具体的插槽名 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><p>绑定在 <slot> 元素上的 attribute 被称为插槽 prop，为了让父元素能够访问到子组件中的数据，可以通过 v-bind 进行作用域的绑定，具体代码如下：</slot></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 子元素中需要在 slot 中使用 v-bind 绑定具体变量 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-bind:user</span>=<span class="string">"user"</span>&gt;</span></div><div class="line">    &#123;&#123; user.lastName &#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 父元素通过 v-slot 来指明子元素所 bind 的所有数据 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">child</span>&gt;</span></div><div class="line">	  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot</span>=<span class="string">"slotProps"</span>&gt;</span></div><div class="line">		    &#123;&#123; slotProps.user.firstName &#125;&#125;</div><div class="line">	  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong><em>v-slot 的缩写为 #</em></strong>，这个在具名插槽中有</p>
<h4 id="结构插槽Prop"><a href="#结构插槽Prop" class="headerlink" title="结构插槽Prop"></a>结构插槽Prop</h4><p>作用域插槽的内部工作原理是将你的插槽内容包裹在一个拥有单个参数的函数里，这意味着 v-slot 的值实际上可以是任何能够作为函数定义中的参数的 JavaScript 表达式。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- prop 重命名 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">"&#123; user: person &#125;"</span>&gt;</span></div><div class="line">	  &#123;&#123; person.firstName &#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 为 prop 指定默认值 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">"&#123; user = &#123; firstName: 'Guest' &#125; &#125;"</span>&gt;</span></div><div class="line">	  &#123;&#123; user.firstName &#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="边界情况处理"><a href="#边界情况处理" class="headerlink" title="边界情况处理"></a>边界情况处理</h3><h4 id="访问元素-amp-组件"><a href="#访问元素-amp-组件" class="headerlink" title="访问元素&amp;组件"></a>访问元素&amp;组件</h4><ul>
<li><p>访问根实例</p>
<p>  一般不建议触达另一个组件实例内部或手动操作 DOM 元素</p>
<p>  如果必须这么做，可以通过 this.$root 来访问根实例中的 data、computed 和 methods 等属性</p>
</li>
<li><p>访问父级元素</p>
<p>  同访问根实例，父级元素的访问是通过 this.$parent</p>
</li>
<li><p>访问子元素</p>
<p>  你可以通过 ref 这个 attribute 为子组件赋予一个 ID 引用，父组件可以通过 他会 this.$refs.someId 来访问子元素的所有属性</p>
</li>
<li><p>依赖注入</p>
<p>  当出现了多层嵌套的组件时，使用 $parent 属性无法很好获取到特定父级元素，这时需要采用依赖注入的方法 provide 和 inject，相当于爷组件和孙组件之间的 props：</p>
  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 爷组件中添加 provide 属性</span></div><div class="line">provide: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    getMap: <span class="keyword">this</span>.getMap</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 孙组件中添加 inject 属性</span></div><div class="line">inject: [<span class="string">'getMap'</span>]</div></pre></td></tr></table></figure>
</li>
<li><p>循环引用</p>
<ul>
<li>组件递归引用要避免</li>
<li><p>不同组件间相互引用，如果产生循环引用（例如 Tree 文件系统或级联系统，模块系统会不知道到底哪个是初始组件），可以采用如下两种方式来解决：</p>
<ul>
<li><p>在生命周期钩子 beforeCreate 中进行组件的引入：</p>
  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">beforeCreate: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.$options.components.TreeFolderContents = <span class="built_in">require</span>(<span class="string">'./tree-folder-contents.vue'</span>).default</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>引用组件时采用异步方式：</p>
  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">components: &#123;</div><div class="line">  TreeFolderContents: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./tree-folder-contents.vue'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="过渡-amp-动画"><a href="#过渡-amp-动画" class="headerlink" title="过渡&amp;动画"></a>过渡&amp;动画</h3><h4 id="单元素-组件的过渡"><a href="#单元素-组件的过渡" class="headerlink" title="单元素/组件的过渡"></a>单元素/组件的过渡</h4><p>使用 <transition name="someTransition"></transition> 封装所要添加过渡的元素。这种方式适用于以下四种情况（都是单个组件显隐）：</p>
<ul>
<li>条件渲染 (使用 <code>v-if</code>)</li>
<li>条件展示 (使用 <code>v-show</code>)</li>
<li>动态组件</li>
<li>组件根节点</li>
</ul>
<p>封装好元素后，还需要提供相应的 css 样式，分别由六种状态的样式名，需要根据 name 属性进行相应的设置：someTransition-enter 表示进入过渡开始状态，someTransition-enter-active 表示进入过渡生效状态，someTransition-enter-to 表示进入过渡结束状态，someTransition-leave，someTransition-leave-active，someTransition-leave-to。</p>
<p>也可以自定义类名，相对应上面六种默认的样式，可以在 transition 标签中添加 enter-class，enter-active-class，enter-to-class，leave-class，leave-active-class，leave-to-class。</p>
<p>transition 标签中可以指定进入和离开过渡的时长，可以通过 <code>:duration=&quot;{ enter: 500, leave: 800 }&quot;</code> 实现</p>
<p>transition 标签中可以指定过渡各阶段的钩子，以用来绑定相应的事件，包括 @before-enter、@enter、@after-enter、@enter-cancelled、@before-leave、@leave、@after-leave、@leave-cancelled 八种钩子：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在 enter 和 leave 钩子事件，如果没有 css 控制元素过渡，那么一定需要有 done() 回调</span></div><div class="line"><span class="comment">// 否则 enter 和 leave 钩子事件会同时完成</span></div><div class="line">beforeEnter: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;&#125;,</div><div class="line">enter: <span class="function"><span class="keyword">function</span> (<span class="params">el, done</span>) </span>&#123;</div><div class="line">    done()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>transition 标签中可以使用 appear 属性来设置元素初始化过渡的样式，用法与 enter 和 leave 相同，可以使用 someTrasition-appear 类或者自定义类名属性，当然也支持钩子的实现。</p>
<h4 id="多元素的过渡"><a href="#多元素的过渡" class="headerlink" title="多元素的过渡"></a>多元素的过渡</h4><p>多元素使用过渡时，可以在最外层使用 transition 标签进行包装，用法与单元素相同，但是有一点需要注意——使用 v-if 或者 v-for 设置多个元素时，一定要在每个元素上绑定自己的 key。</p>
<p>多个元素切换显隐状态时，Vue 提供了一个 mode 属性来进行平滑过渡：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;transition name=<span class="string">"fade"</span> mode=<span class="string">"out-in"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span></div></pre></td></tr></table></figure>
<h4 id="多组件的过渡"><a href="#多组件的过渡" class="headerlink" title="多组件的过渡"></a>多组件的过渡</h4><p>多组件的过渡，使用之前所提到的动态组件即可实现，在过渡时可以在组件外包装一层 transition，指定过渡的样式名 name 属性，就可以使用上面提到的样式或钩子进行过渡样式的实现，当然也可以添加所需要的 mode：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;transition name=<span class="string">"component-fade"</span> mode=<span class="string">"out-in"</span>&gt;</div><div class="line">  &lt;component v-bind:is=<span class="string">"view"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></div><div class="line">&lt;<span class="regexp">/transition&gt;</span></div></pre></td></tr></table></figure>
<p>对于列表的过渡，可以使用 <transition-group> 包装 v-for 渲染出的列表，指明过渡样式名 name 属性，即可用上面相同的方式进行过渡的实现。在列表打乱或重新排序时，Vue 提供了 someTransition-move 的类名来实现：</transition-group></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"shuffle"</span>&gt;</span>Shuffle<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">transition-group</span> <span class="attr">name</span>=<span class="string">"flip-list"</span> <span class="attr">tag</span>=<span class="string">"ul"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">v-bind:key</span>=<span class="string">"item"</span>&gt;</span></div><div class="line">	      &#123;&#123; item &#125;&#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#flip-list-demo'</span>,</div><div class="line">  data: &#123;</div><div class="line">    items: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    shuffle: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">this</span>.items = _.shuffle(<span class="keyword">this</span>.items)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flip-list-move</span> &#123;</div><div class="line">  <span class="attribute">transition</span>: transform <span class="number">1s</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
        
        </div>

        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://keefe.wang/2020/07/22/2020-07-22-things-need-to-be-aware-of-in-vue.html" data-id="ckk4rtiif001gfv90soh6hr18" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
    
</article>

        
            <article id="post-2020-06-03-advanced-eventloop-in-javascript" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        <div class="article-corner"></div>
        

        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2020/06/03/2020-06-03-advanced-eventloop-in-javascript.html">JavaScript 基于事件循环的并发模型</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2020/06/03/2020-06-03-advanced-eventloop-in-javascript.html">
            <time datetime="2020-06-03T08:31:00.000Z" itemprop="datePublished">2020-06-03</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Document/">Document</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>
    </div>

                    </div>
                
            </header>
        

        

        <div class="article-entry" itemprop="articleBody">

        
            
            <p>runtime（运行时刻）是指一个程序在运行的状态。JavaScript 的运行时刻有一个基于事件循环的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。</p>
<p><img src="JavaScript%20%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%20b0cfb1289e8e4098b7cae991e050b301/The_Javascript_Runtime_Environment_Example.svg" alt="JavaScript%20%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%20b0cfb1289e8e4098b7cae991e050b301/The_Javascript_Runtime_Environment_Example.svg"></p>
<p>JavaScript 中的函数调用会形成一个由若干帧组成的栈，当一个函数中存在闭包函数时，外层函数会先压入栈中，其中包含参数和局部变量；闭包函数跟着压入栈中，也包含了自己的参数和局部变量。闭包函数先从栈中弹出，执行完了之后外层函数从栈中弹出执行，栈就被清空了。</p>
<p>对象是被分配在堆中。</p>
<p>一个 JavaScript 运行时包含了一个待处理消息的消息队列。每一个消息都关联着一个用以处理这个消息的回调函数。</p>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (queue.waitForMessage()) &#123;</div><div class="line">  queue.processNextMessage();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JavaScript 中每一个函数都是需要完整执行完成才会继续进行下一步（单线程语言：one thread ⇒ one call stack ⇒ one thing at a time），所以 JavaScript 的代码很容易出现一个函数执行时间过长的情况。为了实现程序的并发执行，JavaScript 引入了事件循环机制。</p>
<p>在上面所提到的函数调用栈之外，还会有一个任务队列。当 runtime 执行代码过程中遇到了像 setTimeout 或 DOM 事件绑定的回调函数，会首先调用 WebAPIs 去进行执行——例如 setTimeout 会产生一个 timer 计时器，当计时器到达指定时间后，会将这个事件推入任务队列。任务队列就是由一个个异步操作的回调函数所组成的队列。事件循环简单来说就是：当 runtime 函数调用栈清空后，查看当前任务队列，并把队列第一个任务压入 runtime 函数调用栈。</p>
<p>浏览器的 render 刷新最快是 16.6ms 一次（浏览器刷新一般是 60次/s ），这是在主线程为空的时候（所以任务队列里的任务是不会阻塞浏览器渲染的）。<strong>如果想在浏览器渲染任务队列中添加任务，可以使用 requestAnimationFrame(callback)方法来进行添加</strong>。如果函数调用栈不为空，则 render 会被阻塞：主线程中的死循环会阻塞浏览器渲染，但是看下面的代码： </p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	setTimeout(loop, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line">loop();</div></pre></td></tr></table></figure>
<p>这个无限自我递归调用也会形成一个循环，但是由于 setTimeout 方法只是不停地往任务队列里面添加任务，而主线程还是每次取一个任务去执行，主线程不会被阻塞，所以浏览器渲染也不会被阻塞。</p>
<p>到目前为止，在事件循环中，我们认识到了主线程、任务队列和渲染任务队列。当主线程任务全部执行完成清空后，会从非空的任务队列中拿第一个任务到主线程尽心执行，每次循环都是只取一个任务队列中的任务。而渲染任务则是一次性执行完成的。</p>
<p><img src="JavaScript%20%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%20b0cfb1289e8e4098b7cae991e050b301/_1.png" alt="JavaScript%20%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%20b0cfb1289e8e4098b7cae991e050b301/_1.png"></p>
<p>实际上，浏览器总还有一个 microTask queue，这个队列中一般我们遇到的 99.9% 应该都是以 promise 形式出现的，microTask 执行的时间是每一段 JS 代码执行完毕（主线程任务清空、任务队列取得第一个任务到主线程并执行完、浏览器渲染任务执行完）都会进行执行，而且一旦执行，microTask queue 中无论有多少个任务（包括同时添加进来的任务）都会一直执行完。所以，microTask queue 是会产生阻塞的。</p>
<p><img src="JavaScript%20%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%20b0cfb1289e8e4098b7cae991e050b301/_1%201.png" alt="JavaScript%20%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%20b0cfb1289e8e4098b7cae991e050b301/_1%201.png"></p>
<p>如上图所示，我们所知的浏览器的事件循环有以下的几种队列机制：</p>
<ul>
<li><p>主线程任务队列</p>
<p>  接受 JS 程序中按顺序的同步任务，在每次事件循环中都会执行任务直至队列清空</p>
</li>
<li><p>异步回调任务队列</p>
<p>  接受像 setTimeout、ajax 等的异步回调函数任务，在每次时间循环中主线程任务队列清空后，会拿出该队列的头部任务放入主线程进行执行</p>
</li>
<li><p>microtask 任务队列</p>
<p>  接受 promise.then 的回调函数任务，在事件循环中，每一段 JS 代码执行完毕（主线程任务清空、任务队列取得第一个任务到主线程并执行完、浏览器渲染任务执行完）都会执行，且每次执行都会将该队列清空，包括同时入队的任务也会一并清空</p>
</li>
<li><p>动画帧回调任务队列</p>
<p>  接受 requestAnimationFrame 的回调函数任务，在每次浏览器渲染任务执行之前进行执行（目前仅在 chrome 中是该顺序），每次执行都清空当前队列，如有新的任务添加则等待下次渲染前执行</p>
</li>
<li><p>浏览器渲染任务队列</p>
<p>  每当上面主线程、异步任务队列、microTask 任务队列执行完毕，且距离上一次渲染时长大于 16.6ms 时，就会进行任务执行，每一次执行都会将当前队列任务全部执行完毕</p>
</li>
</ul>
<p>用一个伪代码来进行上面流程的表述，如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">	<span class="keyword">while</span> (mainThread.hasTasks()) &#123;</div><div class="line">		execute(mainThread.getNextTask());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	queue = getNextQueue();</div><div class="line">	task = queue.pop();</div><div class="line">	execute(task);</div><div class="line"></div><div class="line">	<span class="keyword">while</span>(microTask.hasTasks()) &#123;</div><div class="line">		doMicroTask();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (isRepaintTime()) &#123;</div><div class="line">		animationTasks = animationQueue.copyTasks();</div><div class="line">		<span class="keyword">for</span> (task <span class="keyword">in</span> animationTasks) &#123;</div><div class="line">			doAnimationTask();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	repaint()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Node-中的事件循环"><a href="#Node-中的事件循环" class="headerlink" title="Node 中的事件循环"></a>Node 中的事件循环</h3><p>NodeJS 的事件循环基本上与浏览器中的事件循环是一致的，只不过浏览器使用的是 WebAPIs，而 NodeJS 中使用的是 C++ APIs。</p>
<p><img src="JavaScript%20%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%20b0cfb1289e8e4098b7cae991e050b301/_1%202.png" alt="JavaScript%20%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%20b0cfb1289e8e4098b7cae991e050b301/_1%202.png"></p>
<p>主线程与异步任务队列执行以及 microTask 任务队列都与浏览器中的事件循环相同，我们可以看到上图中多了三个没有见到过的任务队列：</p>
<ul>
<li><p>check phase 任务队列</p>
<p>  接受使用 setImmediate 方法传入的回调函数任务，每次在异步任务队列执行完成后，清空该队列</p>
</li>
<li><p>timer phase 任务队列</p>
<p>  接受 setTimeout、setInterval 传入的回调函数，每次在 check phase 任务队列清空后，清空该任务队列</p>
</li>
<li><p>nextTick 任务队列</p>
<p>  与 microTask 任务队列相同， 接受 process.nextTick 传入的回调函数，该队列优先级高于 microTask </p>
</li>
</ul>
<p>用伪代码进行上述流程的模拟，如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (tasksAreWaiting()) &#123;</div><div class="line">	queue = getNextQueue();</div><div class="line">	<span class="keyword">while</span> (queue.hasTasks()) &#123;</div><div class="line">		task = queue.pop();</div><div class="line">		execute(task);</div><div class="line">		</div><div class="line">		<span class="keyword">while</span> (nextTickQueue.hasTasks()) &#123;</div><div class="line">			doNextTickTask();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">while</span> (promiseQueue.hasTasks()) &#123;</div><div class="line">			doPromiseTask();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
        
        </div>

        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://keefe.wang/2020/06/03/2020-06-03-advanced-eventloop-in-javascript.html" data-id="ckk4rtiih001jfv90pkhzesfc" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
    
</article>

        
            <article id="post-2020-05-30-source-code-reading-Egg-starting" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        <div class="article-corner"></div>
        

        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2020/05/23/2020-05-30-source-code-reading-Egg-starting.html">EggJS源码阅读-启动流程与代码实现</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2020/05/23/2020-05-30-source-code-reading-Egg-starting.html">
            <time datetime="2020-05-23T04:30:00.000Z" itemprop="datePublished">2020-05-23</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/SourceCodeReading/">SourceCodeReading</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/EggJS/">EggJS</a>, <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>, <a class="tag-link" href="/tags/NodeJS/">NodeJS</a>, <a class="tag-link" href="/tags/源码学习/">源码学习</a>
    </div>

                    </div>
                
            </header>
        

        

        <div class="article-entry" itemprop="articleBody">

        
            
            <blockquote>
<p>egg是阿里开源的一个框架，为企业级框架和应用而生，相较于express和koa，有更加严格的目录结构和规范。不同的团队可以基于egg，根据自己的需求封装出适合团队业务的更上层框架。</p>
</blockquote>
<h3 id="egg如何启动"><a href="#egg如何启动" class="headerlink" title="egg如何启动"></a>egg如何启动</h3><p><img src="https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiZDc4MmQxN2MtM2FjYS00MDZhLTk4MDktOGRmMzMwY2M3ZGQxIiwicmVzb3VyY0d1aWQiOiJiMzZlODM2OS0xNzY1LTQzOTEtOTAzOC0zN2Q0NmE0NWVjNjAifQ==" alt="fca8379caeffb9c194aa5369db1c563b.png"></p>
<p>根据<code>package.json</code>中的<code>script</code>命令，可以看到执行的直接是<code>egg-bin dev</code>的命令。找到<code>egg-bin</code>文件夹中的<code>dev.js</code>,会看到里面会去执行外层的<code>start-cluster</code>文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">require(options.framework).startCluster(options);</div></pre></td></tr></table></figure>
<p>此处的<code>options.framework</code>其实指的就是<code>egg</code>框架，然后调用了<code>egg-cluster</code>包中的<code>startCluster</code>方法，egg正式迈出了启动的第一步。</p>
<p>[源码流程]</p>
<p><code>egg</code>框架采用了<code>master-agent-worder</code>的集群模式，如果所示，官方文档中也对于这三种进程的启动和通信给出了较为详细的说明：</p>
<ul>
<li>Master 启动后先 fork Agent 进程</li>
<li>Agent 初始化成功后，通过 IPC 通道通知 Master</li>
<li>Master 再 fork 多个 App Worker</li>
<li>App Worker 初始化成功，通知 Master</li>
<li>所有的进程初始化成功后，Master 通知 Agent 和 Worker 应用启动成功</li>
</ul>
<p>我们尝试从源码中大致将这个流程实现出来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// egg-cluster/lib/master.js</span></div><div class="line">ready.mixin(<span class="keyword">this</span>);              <span class="comment">// 将 ready 方法挂在 Master 上</span></div><div class="line"><span class="keyword">this</span>.detectPorts().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;  <span class="comment">// 检测端口</span></div><div class="line">    <span class="keyword">this</span>.forkAgentWorker();      <span class="comment">// 启动 agent 进程，发送 agent-start 消息给 master 进程</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// master 进程一旦接收到 agent-start 消息后，开始创建 worker 进程</span></div><div class="line"><span class="keyword">this</span>.once(<span class="string">'agent-start'</span>, <span class="keyword">this</span>.forkAppWorkers.bind(<span class="keyword">this</span>));</div></pre></td></tr></table></figure>
<p>[源码流程]</p>
<h3 id="Agent与AppWorker的实现"><a href="#Agent与AppWorker的实现" class="headerlink" title="Agent与AppWorker的实现"></a>Agent与AppWorker的实现</h3><h4 id="AgentWorker与AppWorker进程的启动"><a href="#AgentWorker与AppWorker进程的启动" class="headerlink" title="AgentWorker与AppWorker进程的启动"></a>AgentWorker与AppWorker进程的启动</h4><p><img src="https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiZDc4MmQxN2MtM2FjYS00MDZhLTk4MDktOGRmMzMwY2M3ZGQxIiwicmVzb3VyY0d1aWQiOiI3ZmViNGFmYS1kMzNlLTQ1MDgtYjAyNi0wYWIyOGRkMDc2Y2MifQ==" alt="de59fd88a438492231f38fb2032ffd5b.png"></p>
<p>在启动<code>AgentWorker</code>和<code>AppWorker</code>时，会分别加载<code>agent_worker.js</code>和<code>app_worker.js</code>两个文件并创建进程，其中<code>agent_worker.js</code>中会创建<code>Agent</code>类的实例，而<code>app_worker.js</code>中会创建<code>Application</code>类的实例。</p>
<p>两种进程在启动时都会调用<code>this.loader.load()</code>方法来加载自己相应的一些插件和自定义的扩展。</p>
<p><img src="https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiZDc4MmQxN2MtM2FjYS00MDZhLTk4MDktOGRmMzMwY2M3ZGQxIiwicmVzb3VyY0d1aWQiOiI0MDczM2IwZi04OTc0LTQxNzctYjM4Zi0zN2I0MTE3ZGQ2MjAifQ==" alt="18d21732106d0293791bf03d6481784b.png"></p>
<p>基于<code>egg_loader</code>实现了<code>AppWorkerLoader</code>和 <code>AgentWorkerLoader</code>，上层框架基于这两个类来扩展，<code>Loader</code>的扩展只能在框架进行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; AppWorkerLoader &#125; <span class="keyword">from</span> <span class="string">'egg'</span></div><div class="line"><span class="keyword">import</span> common <span class="keyword">from</span> <span class="string">'./common'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAppWorkerLoader</span> <span class="keyword">extends</span> <span class="title">AppWorkerLoader</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(opt) &#123;</div><div class="line">    <span class="keyword">super</span>(opt);</div><div class="line">        <span class="comment">// 自定义初始化</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    loadConfig() &#123;</div><div class="line">        <span class="keyword">super</span>.loadConfig();</div><div class="line">        <span class="comment">// 对 config 进行处理</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    load() &#123;</div><div class="line">        <span class="keyword">super</span>.load();</div><div class="line">        <span class="comment">// 自定义加载其他目录</span></div><div class="line">        <span class="comment">// 或对已加载的文件进行处理</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">Object</span>.assign(MyAppWorkerLoader.prototype, &#123;</div><div class="line">    <span class="comment">// 可以根据自己的需求，重写一些获取配置的方法</span></div><div class="line">    getServerEnv()&#123;&#125;;</div><div class="line">    _preloadAppConfig()&#123;&#125;</div><div class="line">    getTypeFiles()&#123;&#125;</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> MyAppWorkerLoader</div></pre></td></tr></table></figure>
<h4 id="Agent如何实现"><a href="#Agent如何实现" class="headerlink" title="Agent如何实现"></a>Agent如何实现</h4><p><img src="https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiZDc4MmQxN2MtM2FjYS00MDZhLTk4MDktOGRmMzMwY2M3ZGQxIiwicmVzb3VyY0d1aWQiOiJmMTAwMWJlZi05OWMwLTQ3Y2MtYjk3NS1kYmZiNjI1N2VkNjMifQ==" alt="f2ac3732452f487f21e11c0de480f3df.png"></p>
<p><code>Agent</code>对象在<code>egg-cluster</code>创建环节中被创建出来，继承自<code>egg.Agent</code>对象，该对象继承<code>EggApplication</code>,且<code>loader</code>为<code>./lib/loader/agent_worker_loader.js</code>文件，继承自<code>egg-core.eggLoader</code>对象，整体继承链如上图。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// egg/lib/agent.js</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Agent</span> <span class="keyword">extends</span> <span class="title">EggApplication</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(options = &#123;&#125;) &#123;</div><div class="line">    options.type = <span class="string">'agent'</span>;</div><div class="line">    <span class="comment">// 1.完成父类构建</span></div><div class="line">    <span class="keyword">super</span>(options);</div><div class="line">    <span class="comment">// 2.驱动loader执行load方法</span></div><div class="line">    <span class="keyword">this</span>.loader.load();</div><div class="line">    <span class="comment">// 3.dump相关配置文件进入./run目录下</span></div><div class="line">    <span class="keyword">this</span>.dumpConfig();</div><div class="line">    </div><div class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>);</div><div class="line">    <span class="comment">// 4.监听异常事件</span></div><div class="line">    <span class="keyword">this</span>._uncaughtExceptionHandler = <span class="keyword">this</span>._uncaughtExceptionHandler.bind(<span class="keyword">this</span>);</div><div class="line">    process.on(<span class="string">'uncaughtException'</span>, <span class="keyword">this</span>._uncaughtExceptionHandler);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Agent</code>类的实现中，主要是实例化了<code>EggApplication</code>，调用了<code>this.loader.load()</code>方法来加载各种文件和配置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// egg/lib/egg.js</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EggApplication</span> <span class="keyword">extends</span> <span class="title">EggCore</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(options = &#123;&#125;) &#123;</div><div class="line">        options.mode = options.mode || <span class="string">'cluster'</span>;</div><div class="line">        <span class="comment">// 1.原型EggCore构建</span></div><div class="line">        <span class="keyword">super</span>(options);</div><div class="line">        <span class="comment">// 2.调用loadConfig，在agent的实现中，指向的并不是egg-core.loader，而是agent_worker_loader</span></div><div class="line">        <span class="keyword">this</span>.loader.loadConfig();</div><div class="line">        <span class="comment">// 3.ready事件</span></div><div class="line">        <span class="keyword">this</span>.ready(<span class="function"><span class="params">()</span> =&gt;</span> process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">          <span class="keyword">const</span> dumpStartTime = <span class="built_in">Date</span>.now();</div><div class="line">          <span class="keyword">this</span>.dumpConfig();</div><div class="line">          <span class="keyword">this</span>.dumpTiming();</div><div class="line">        &#125;));</div><div class="line">        <span class="comment">// 监听unhandleRejection事件</span></div><div class="line">        <span class="comment">// 4.cluster初始化</span></div><div class="line">        <span class="keyword">this</span>[CLUSTER_CLIENTS] = [];</div><div class="line">        <span class="keyword">this</span>.cluster = <span class="function">(<span class="params">clientClass, options</span>) =&gt;</span> &#123;&#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>EggApplication</code>类的实现中，我们可以看到是继承自<code>EggCore</code>类，在父类构建好之后，会调用<code>this.loader.loadConfig()</code>方法，该方法的<code>loader</code>实例实际指向了<code>AgentWorkerLoader（agent_worker_loader.js）</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// egg/lib/loader/agent_worker_loader.js</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AgentWorkerLoader</span> <span class="keyword">extends</span> <span class="title">EggLoader</span> </span>&#123;</div><div class="line">  loadConfig() &#123;</div><div class="line">    <span class="keyword">this</span>.loadPlugin();  <span class="comment">// loadPlugin from egg-core/lib/loader/mixin/plgin.js</span></div><div class="line">    <span class="keyword">super</span>.loadConfig(); <span class="comment">// loadConfig from egg-core/lib/loader/mixin/config.js</span></div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  load() &#123;</div><div class="line">    <span class="keyword">this</span>.loadAgentExtend();</div><div class="line">    <span class="keyword">this</span>.loadContextExtend();</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.loadCustomAgent();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>loadPlugin</code>方法会加载三种插件：</p>
<ul>
<li><code>eggPlugins</code>，从eggjs框架配置的插件，也就是<code>egg/config/plugins.js</code>文件中egg框架自带的插件；</li>
<li><code>appPlugins</code>，每个应用自己配置的插件，也就是<code>myproject/config/plugins.js</code>，用户可以自定义配置一些特殊的插件；</li>
<li><code>customPlugins</code>，应用启动命令中参数EGG_PLUGINS值所代表的插件；</li>
</ul>
<p>最后会将这三种插件都挂在app实例上：<code>this.plugins = enablePlugins</code>;</p>
<p><code>loadConfig</code>方法会加载三种配置：</p>
<ul>
<li><code>appConfig</code>，每个应用自己独有的配置，其中会按顺序加载两个配置，一个是默认配置<code>config.default</code>，另一个是当前环境的配置<code>config.${this.serverEnv}</code>，也就是<code>myproject/config</code>下的一些配置文件加载</li>
<li>加载自定义添加的<code>plugin</code>插件的配置</li>
<li>加载框架<code>egg</code>的配置，即<code>egg/config</code></li>
<li>重新加载应用<code>app</code>的配置，即<code>myproject/config</code>下的</li>
</ul>
<p>最后将合并的配置挂载在<code>app</code>实例上<code>this.config = target</code>;</p>
<h4 id="Application如何实现"><a href="#Application如何实现" class="headerlink" title="Application如何实现"></a>Application如何实现</h4><p>上面提到，<code>AppWorker</code>在实例化的过程中，会调用<code>this.loader.load()</code>。进入具体这个<code>Application</code>所对应的<code>loader.load</code>方法，可以发现<code>Application</code>的实现比<code>Agent</code>的实现多调用了很多加载的方法：</p>
<ul>
<li><code>this.loadApplicationExtend();</code>，该方法的调用会给应用加载扩展方法，加载路径为<code>app\extend\application.js</code>, 会将对应的对象挂载在app 应用上。</li>
<li><code>this.loadRequestExtend();</code>，加载<code>app\extend\request.js</code></li>
<li><code>this.loadResponseExtend();</code>，加载<code>app\extend\response.js</code></li>
<li><code>this.loadContextExtend();</code>，加载<code>app\extend\context.js</code></li>
<li><code>this.loadHelperExtend();</code>，加载<code>app\extend\helper.js</code></li>
<li><code>this.loadService()</code></li>
<li><code>this.loadMiddleware()</code></li>
<li><code>this.loadController()</code></li>
<li><code>this.loadRouter()</code></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p>egg启动服务集群，采用了<code>master-agent-worker</code>模式，<code>AgentWorker</code>和<code>AppWorker</code>都由Application(egg/lib/applicaton.js) -&gt; EggApplication(egg/lib/egg.js) -&gt; EggCore(egg-core/lib/egg.js) -&gt; KoaApplication(koa)原型链进行继承</p>
</li>
<li><p><code>Agent</code>和<code>Application</code>在实例化的过程中，都会调用相应的Loader去加载自己所需的插件和配置，且加载顺序严格按照<strong>插件plugin-框架framework-应用application</strong>这样一个顺序</p>
</li>
</ol>
<p><img src="https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiZDc4MmQxN2MtM2FjYS00MDZhLTk4MDktOGRmMzMwY2M3ZGQxIiwicmVzb3VyY0d1aWQiOiIwZGM3ZmY3Mi1iZjM1LTQzZDMtODE1Ni0wMDk2YmQyY2FiMDUifQ==" alt="0464781205f05b89c1b8807280114dd8.png"></p>

        
        </div>

        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://keefe.wang/2020/05/23/2020-05-30-source-code-reading-Egg-starting.html" data-id="ckk4rtiis001ufv90uk81gvd1" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
    
</article>

        
            <article id="post-2020-03-05-source-code-reading-express-router" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        <div class="article-corner"></div>
        

        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2020/03/15/2020-03-05-source-code-reading-express-router.html">Express源码阅读-router相关</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2020/03/15/2020-03-05-source-code-reading-express-router.html">
            <time datetime="2020-03-15T04:30:00.000Z" itemprop="datePublished">2020-03-15</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/SourceCodeReading/">SourceCodeReading</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Express/">Express</a>, <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>, <a class="tag-link" href="/tags/NodeJS/">NodeJS</a>, <a class="tag-link" href="/tags/源码学习/">源码学习</a>
    </div>

                    </div>
                
            </header>
        

        

        <div class="article-entry" itemprop="articleBody">

        
            
            <p>Express 是一种保持最低程度规模的灵活 Node.js Web 应用程序框架，为 Web 和移动应用程序提供一组强大的功能。</p>
<h3 id="Express中的app"><a href="#Express中的app" class="headerlink" title="Express中的app"></a>Express中的app</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// express.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// typeof app === 'function'，同时它身上还绑定着无数属性和方法</span></div><div class="line">    <span class="keyword">var</span> app = <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">        app.handle(req, res, next);</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// app同时继承了事件监听/触发机制和application.js中的各种方法</span></div><div class="line">    mixin(app, EventEmitter.prototype, <span class="literal">false</span>);</div><div class="line">    mixin(app, proto, <span class="literal">false</span>);</div><div class="line">    <span class="comment">// 此处暴露了request和response两个类</span></div><div class="line">    app.request = <span class="built_in">Object</span>.create(req, &#123; ... &#125;);</div><div class="line">    app.response = <span class="built_in">Object</span>.create(res, &#123; ... &#125;);</div><div class="line">    <span class="comment">// 调用application.js中的init方法，主要调用的是defaultConfiguration方法</span></div><div class="line">    app.init();</div><div class="line">    <span class="keyword">return</span> app;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 这里需要注意的是exports和module.exports的不同：当module.exports被赋值后，exports就不同于module.exports了，所以需要这么做；当然也可以只用module.exports；</span></div><div class="line">exports = <span class="built_in">module</span>.exports = createApplication;</div></pre></td></tr></table></figure>
<p>可以看出，调用express()返回的app其实是一个函数，调用app.listen()其实执行的是http.createServer(app).listen()。因此，app其实就是一个请求处理函数，作为http.createServer的参数。而express其实是一个工厂函数，用来生成请求处理函数。</p>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><blockquote>
<p>An Express application is essentially a series of middleware calls.<br>一个Express应用实际上就是一系列中间件的调用。</p>
</blockquote>
<p>中间件大致可分为两种，一种是普通中间件，通过 <code>app.use(&#39;/user&#39;)</code> 方法进行注册，该方法中的路径是匹配所有以 <code>/user</code> 开头的路径；另外一种是路由中间件，通过 <code>app.METHOD()</code> 方法进行注册，这种方式精确匹配路径，且只能处理确定请求方法的请求。</p>
<p>针对app.use部分的代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">app.use = <span class="function"><span class="keyword">function</span> <span class="title">use</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> offset = <span class="number">0</span>;</div><div class="line">  <span class="comment">// 默认设置路径为根路径，同时判断中间件是方法还是方法所在路径</span></div><div class="line">  <span class="keyword">var</span> path = <span class="string">'/'</span>;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) &#123;</div><div class="line">    <span class="keyword">var</span> arg = fn;</div><div class="line">    <span class="keyword">while</span> (<span class="built_in">Array</span>.isArray(arg) &amp;&amp; arg.length !== <span class="number">0</span>) &#123;</div><div class="line">      arg = arg[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">'function'</span>) &#123;</div><div class="line">      offset = <span class="number">1</span>;</div><div class="line">      path = fn;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// router初始化</span></div><div class="line">  <span class="keyword">this</span>.lazyrouter();</div><div class="line">  <span class="keyword">var</span> router = <span class="keyword">this</span>._router;</div><div class="line">  </div><div class="line">  <span class="keyword">var</span> fns = flatten(slice.call(<span class="built_in">arguments</span>, offset));</div><div class="line">  fns.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</div><div class="line">    <span class="comment">// non-express app</span></div><div class="line">    <span class="keyword">if</span> (!fn || !fn.handle || !fn.set) &#123;</div><div class="line">      <span class="keyword">return</span> router.use(path, fn);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    debug(<span class="string">'.use app under %s'</span>, path);</div><div class="line">    fn.mountpath = path;</div><div class="line">    fn.parent = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">    <span class="comment">// restore .app property on req and res</span></div><div class="line">    router.use(path, <span class="function"><span class="keyword">function</span> <span class="title">mounted_app</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> orig = req.app;</div><div class="line">      fn.handle(req, res, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">        setPrototypeOf(req, orig.request)</div><div class="line">        setPrototypeOf(res, orig.response)</div><div class="line">        next(err);</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">// mounted an app</span></div><div class="line">    fn.emit(<span class="string">'mount'</span>, <span class="keyword">this</span>);</div><div class="line">  &#125;, <span class="keyword">this</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>针对app.METHODS的代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">methods.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>)</span>&#123;</div><div class="line">  app[method] = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (method === <span class="string">'get'</span> &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</div><div class="line">      <span class="comment">// app.get(setting)</span></div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.set(path);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 路由初始化</span></div><div class="line">    <span class="keyword">this</span>.lazyrouter();</div><div class="line">    <span class="keyword">var</span> route = <span class="keyword">this</span>._router.route(path);</div><div class="line">    route[method].apply(route, slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="路由详解"><a href="#路由详解" class="headerlink" title="路由详解"></a>路由详解</h3><p>在上面两种中间件的实现代码中，都调用了 <code>this.lazyrouter()</code> 方法，所有涉及到路由的方法都会调用这个方法，作用是初始化一个应用的内部路由。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">app.lazyrouter = <span class="function"><span class="keyword">function</span> <span class="title">lazyrouter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>._router) &#123;</div><div class="line">    <span class="comment">// 生成一个路由实例</span></div><div class="line">    <span class="keyword">this</span>._router = <span class="keyword">new</span> Router(&#123;</div><div class="line">        caseSensitive: <span class="keyword">this</span>.enabled(<span class="string">'case sensitive routing'</span>),</div><div class="line">        strict: <span class="keyword">this</span>.enabled(<span class="string">'strict routing'</span>)</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">this</span>._router.use(query(<span class="keyword">this</span>.get(<span class="string">'query parser fn'</span>)));</div><div class="line">    <span class="keyword">this</span>._router.use(middleware.init(<span class="keyword">this</span>));</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>针对第一个默认路由，可以看下具体调用了哪些方法，最终实现了什么逻辑：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.get(<span class="string">'query parser fn'</span>);</div><div class="line"><span class="comment">// 上面的 get 方法同 app.get，可以在 methods.forEach 循环处理时，如果 get 方法的入参长度为1时，会调用 this.set(arg)</span></div><div class="line"><span class="comment">// 在set方法中，有针对 'query parser' 的处理</span></div><div class="line"><span class="comment">// 最终，query 方法实现了将 req.query 进行 querystring.parse 的一个解析过程</span></div><div class="line"><span class="keyword">case</span> <span class="string">'query parser'</span>:</div><div class="line">  <span class="keyword">this</span>.set(<span class="string">'query parser fn'</span>, compileQueryParser(val));</div><div class="line">  <span class="keyword">break</span>;</div></pre></td></tr></table></figure></p>
<p>针对第二个默认路由 init，是给 app 上的暴露出的 req、res 继承 node 原生的 request 和 response 的一些属性。</p>
<p>之所以不在 <code>defaultConfiguration</code> 方法中进行这一步路由的初始化，原因在于设置路由的相关参数需要调用app.set方法，这个方法明显需要有app实例，如果在获取app实例的时候就初始化了一个路由，这个路由的参数就没办法配置了。因此，在获取app实例后，必须先对路由参数进行配置，然后再调用对应的app.use等方法。</p>
<h4 id="app-Methods"><a href="#app-Methods" class="headerlink" title="app.Methods"></a>app.Methods</h4><p>我们先以 <code>app.get</code> 为例，通过断点调试的方式来查看 <code>app.get</code> 这种路由的 <code>_router</code> 对象是什么结构。</p>
<p><img src="https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiZmI2ODUxODEtZjg1Yi00MTc3LTg5MTUtMTMxYTY5OTU2NWU2IiwicmVzb3VyY0d1aWQiOiIzMzk0MTlkZi05NDNlLTQzNzAtOTc0YS1mYjI5NmU3MzQxMDgifQ==" alt="702ca38d0160d8b82ab5d1b7a552bec1.png"></p>
<p>上面的截图是当我们初始化一个 express 实例，并设置了一个 <code>app.get()</code> 的路由后，在 app.listen 处添加断点进行调试时的 app 实例的属性。可以看到在 <code>app._router</code> 中有一个 stack，里面按顺存放着三个 layer 对象，分别是初始化时的 query 和 init 两个路由，和第三个则是我们所设置的 get 路由。每一个 layer 中包含路由处理的回调函数 <code>handle</code>，路由对象 <code>route&lt;Route&gt;</code>，该对象中还包含一个存有 Layer 对象的栈（stack)，就和 <code>app._router.stack</code> 相同。</p>
<p><img src="https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiZmI2ODUxODEtZjg1Yi00MTc3LTg5MTUtMTMxYTY5OTU2NWU2IiwicmVzb3VyY0d1aWQiOiJkOGY5MWM1ZC1lOWRkLTRmNDYtYmJlMC01MGRkNjJjMDUzMTYifQ==" alt="81b68f825db7a3f5bf1ff7d87c09496d.png"></p>
<p>根据上面对于 <code>app.get</code> 这种路由的结构分析，我们可以先猜想它的实现流程：</p>
<ul>
<li><p>首先根据传入的路径封装一个Route对象，再对传入的回调函数封装成Layer对象，接着把这个Layer对象push到Route.stack里面去</p>
</li>
<li><p>再创建一个默认Layer(跟app.use里面Layer的同级)，把步骤一中的Route挂到这个Layer.route属性上面，而这个Layer对象，会被push到app._router.stack里面</p>
</li>
</ul>
<h4 id="app-use"><a href="#app-use" class="headerlink" title="app.use"></a>app.use</h4><p>接下来我们来看 <code>app.use</code> 这种路由又有什么不同。</p>
<p><img src="https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiZmI2ODUxODEtZjg1Yi00MTc3LTg5MTUtMTMxYTY5OTU2NWU2IiwicmVzb3VyY0d1aWQiOiIyNzA3MmYzNC03ZTY0LTQ0ODUtOTQxNC05M2RkMmVjNTkwMWYifQ==" alt="08bdd22fe221f77141d8af6afb5ac8bc.png"></p>
<p>可以看到，在这种路由中，除了 <code>query</code> 和 <code>init</code> 两个初始化路由的方法外，第三个真正的回调方法被封装成的 <code>Layer</code> 对象中，<code>route</code> 属性的值为 <code>undefined</code>。<br>所以我们可以猜想：在 <code>app.use</code> 这种路由里，传入的参数（路径、回调函数）会被封装成 <code>Layer</code> 对象（其中 <code>route</code> 属性为 <code>undefined</code>），压入 <code>app._router.stack</code> 栈中。</p>
<h4 id="两种路由的源码实现"><a href="#两种路由的源码实现" class="headerlink" title="两种路由的源码实现"></a>两种路由的源码实现</h4><p>接下来我们通过源码来分析我们写的 <code>app.use(&#39;/main&#39;, someFun())</code> 是如何成为一个 layer 对象并压入 <code>app._router</code> 的路由栈中的。</p>
<p><strong>首先来看 <code>app.use</code>：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">app.use = <span class="function"><span class="keyword">function</span> <span class="title">use</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> path = <span class="string">'/'</span>;   <span class="comment">// 设置一个默认的路由方法路径</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="comment">// 设置路由，同样也是由lazyrouter进行路由对象的初始化：this._router = new Router(&#123;&#125;)</span></div><div class="line">  <span class="keyword">this</span>.lazyrouter();</div><div class="line">  <span class="keyword">var</span> router = <span class="keyword">this</span>._router;</div><div class="line"></div><div class="line">  fns.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</div><div class="line">    <span class="comment">// router.use是接下来重点要看的方法</span></div><div class="line">    router.use(path, <span class="function"><span class="keyword">function</span> <span class="title">mounted_app</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;, <span class="keyword">this</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>接下来看 Router 对象的 use 方法实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">proto.use = <span class="function"><span class="keyword">function</span> <span class="title">use</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> path = <span class="string">'/'</span>;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="keyword">var</span> callbacks = flatten(slice.call(<span class="built_in">arguments</span>, offset));</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; callbacks.length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> fn = callbacks[i];</div><div class="line">    <span class="comment">// 针对传入路由中的每一个回调方法，都包装成一个 Layer 对象并压入</span></div><div class="line">    <span class="keyword">var</span> layer = <span class="keyword">new</span> Layer(path, &#123;</div><div class="line">      sensitive: <span class="keyword">this</span>.caseSensitive,</div><div class="line">      strict: <span class="literal">false</span>,</div><div class="line">      end: <span class="literal">false</span></div><div class="line">    &#125;, fn);</div><div class="line">    layer.route = <span class="literal">undefined</span>;</div><div class="line">    <span class="keyword">this</span>.stack.push(layer);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>从代码中可以看到，与我们的猜想一致，<code>app.use</code> 这种路由的实现，是将传入的一个个路径或回调方法等参数封装成 <code>Layer</code> 对象压入 <code>_router.stack</code> 栈中。</p>
<p><strong>然后来看 <code>app.get</code> 这种路由的代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// methods 中包含各种请求类型等，get 就包含在其中</span></div><div class="line">methods.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>)</span>&#123;</div><div class="line">  app[method] = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (method === <span class="string">'get'</span> &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</div><div class="line">      <span class="comment">// app.get(setting)</span></div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.set(path);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.lazyrouter();  <span class="comment">// 路由对象 Router 初始化</span></div><div class="line">    <span class="keyword">var</span> route = <span class="keyword">this</span>._router.route(path);</div><div class="line">    route[method].apply(route, slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面代码中最终返回的是 <code>app</code>，那么这端代码对 <code>app</code> 进行了什么样的操作呢？我们可以将目光聚焦在 <code>route[method].apply()</code> 这行代码上。接下来我们可以看下 <code>route</code> 到底是个什么东西。<code>this._router.route</code> 的代码实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">proto.route = <span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">path</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> route = <span class="keyword">new</span> Route(path);</div><div class="line"></div><div class="line">  <span class="keyword">var</span> layer = <span class="keyword">new</span> Layer(path, &#123;</div><div class="line">    sensitive: <span class="keyword">this</span>.caseSensitive,</div><div class="line">    strict: <span class="keyword">this</span>.strict,</div><div class="line">    end: <span class="literal">true</span></div><div class="line">  &#125;, route.dispatch.bind(route));</div><div class="line"></div><div class="line">  layer.route = route;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.stack.push(layer);</div><div class="line">  <span class="keyword">return</span> route;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里可以看到返回的 <code>route</code> 是一个 <code>Route</code> 对象，在这个对象中将参数封装成了 <code>Layer</code> 对象推入了 <code>app._router.stack</code> 中。</p>
<p>接下来我们看一下 <code>Route</code> 对象中的一些实现代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Route</span>(<span class="params">path</span>) </span>&#123;</div><div class="line">  <span class="comment">// Route对象初始化时添加了一个空数组stack属性</span></div><div class="line">  <span class="keyword">this</span>.path = path;</div><div class="line">  <span class="keyword">this</span>.stack = [];</div><div class="line">  <span class="keyword">this</span>.methods = &#123;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 对于app.METHODS这种路由，将路由参数（路径、回调方法）包装成Layer对象压入Route.stack中</span></div><div class="line">methods.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>)</span>&#123;</div><div class="line">  Route.prototype[method] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> handles = flatten(slice.call(<span class="built_in">arguments</span>));</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; handles.length; i++) &#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">      <span class="keyword">var</span> layer = Layer(<span class="string">'/'</span>, &#123;&#125;, handle);</div><div class="line">      layer.method = method;</div><div class="line"></div><div class="line">      <span class="keyword">this</span>.methods[method] = <span class="literal">true</span>;</div><div class="line">      <span class="keyword">this</span>.stack.push(layer);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>至此，在调用 <code>route[method].apply()</code> 时就会为 <code>app.METHODS</code> 这种类型的路由的 <code>Layer</code> 中添加 <code>route&lt;Route&gt;</code> 属性。</p>
<p><img src="https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiZmI2ODUxODEtZjg1Yi00MTc3LTg5MTUtMTMxYTY5OTU2NWU2IiwicmVzb3VyY0d1aWQiOiIyYWEwMDk1ZS1jOGQwLTRkNjMtOWUzNi0yNGZmMjY4NjllOTkifQ==" alt="e6778eb14b0b4f77fc6bc60d49e9a053.png"></p>

        
        </div>

        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://keefe.wang/2020/03/15/2020-03-05-source-code-reading-express-router.html" data-id="ckk4rtijz005ofv906lyvwyjg" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
    
</article>

        
            <article id="post-2020-01-12-Javascript-module-history" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        <div class="article-corner"></div>
        

        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2020/01/12/2020-01-12-Javascript-module-history.html">JavaScript模块化</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2020/01/12/2020-01-12-Javascript-module-history.html">
            <time datetime="2020-01-12T04:30:00.000Z" itemprop="datePublished">2020-01-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Reading/">Reading</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>, <a class="tag-link" href="/tags/规范/">规范</a>, <a class="tag-link" href="/tags/读书笔记/">读书笔记</a>
    </div>

                    </div>
                
            </header>
        

        

        <div class="article-entry" itemprop="articleBody">

        
            
            <h4 id="名词定义先行"><a href="#名词定义先行" class="headerlink" title="名词定义先行"></a>名词定义先行</h4><p>模块化主要解决以下三个问题：</p>
<ul>
<li>代码分离</li>
<li>不同模块间的依赖定义</li>
<li>代码到执行环境的传递</li>
</ul>
<p>能够解决其中一两个点的解决方案我们称之为“<strong>模式</strong>”，能够解决全部三个问题的方案我们称之为“<strong>模块系统</strong>”；</p>
<p>我们将封装好的导出实例（对象、方法等）和引入的实例称为“<strong>模块格式</strong>”；用“分离依赖定义（detached dependency definitions，即用不同文件存储不同文件）”来描述模块系统中可被使用的独立依赖。</p>
<h4 id="关于模块化所解决的问题"><a href="#关于模块化所解决的问题" class="headerlink" title="关于模块化所解决的问题"></a>关于模块化所解决的问题</h4><ul>
<li>命名冲突</li>
</ul>
<p>在1995-1999年间，使用var来定义全局变量是非常方便的，因为当时的JavaScript就是用来编写脚本处理小微任务，而随着应用的代码量上升，全局变量的缺点就越来越明显，因此我们甚至不能引用第三方脚本。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file greeting.js</span></div><div class="line"><span class="keyword">var</span> helloInLang = &#123;</div><div class="line">    en: <span class="string">'Hello world!'</span>,</div><div class="line">    es: <span class="string">'¡Hola mundo!'</span>,</div><div class="line">    ru: <span class="string">'Привет мир!'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeHello</span>(<span class="params">lang</span>) </span>&#123;</div><div class="line">    <span class="built_in">document</span>.write(helloInLang[lang]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// file hello.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeHello</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">document</span>.write(<span class="string">'The script is broken'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>支持大量代码仓库</li>
</ul>
<p>由于编写应用的代码量越来越大，我们常常需要将代码分为多个脚本文件逐一引入，这导致了越来越多数量的脚本文件需要我们手动维护，而且还要考虑脚本引入的顺序！这真是太令人头痛！</p>
<h4 id="Directly-Defined-Dependencies"><a href="#Directly-Defined-Dependencies" class="headerlink" title="Directly Defined Dependencies"></a>Directly Defined Dependencies</h4><p>1999年提出的首次对于独立依赖的模式“直接定义依赖”。该模式是由 Erik Arvidsson 在1999年提出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file greeting.js</span></div><div class="line">dojo.provide(<span class="string">"app.greeting"</span>);</div><div class="line"></div><div class="line">app.greeting.helloInLang = &#123;</div><div class="line">    en: <span class="string">'Hello world!'</span>,</div><div class="line">    es: <span class="string">'¡Hola mundo!'</span>,</div><div class="line">    ru: <span class="string">'Привет мир!'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">app.greeting.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params">lang</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> app.greeting.helloInLang[lang];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// file hello.js</span></div><div class="line">dojo.provide(<span class="string">"app.hello"</span>);</div><div class="line"></div><div class="line">dojo.require(<span class="string">'app.greeting'</span>);</div><div class="line"></div><div class="line">app.hello = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="built_in">document</span>.write(app.greeting.sayHello(<span class="string">'es'</span>));</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>代码使用dojo 1.6编写，其中dojo.provide用来定义模块，获取模块时需要使用dojo.require</p>
<h4 id="命名空间模式"><a href="#命名空间模式" class="headerlink" title="命名空间模式"></a>命名空间模式</h4><p>在JavaScript中，函数是<code>first class citizens</code>，意味着可以被赋给变量，也可以被函数返回。命名空间模式是由 Erik Arvidsson于2002年发明的互联网应用开发工具Bindows开始形成。该模式类似于：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file app.js</span></div><div class="line"><span class="keyword">var</span> app = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// file greeting.js</span></div><div class="line">app.helloInLang = &#123;</div><div class="line">    en: <span class="string">'Hello world!'</span>,</div><div class="line">    es: <span class="string">'¡Hola mundo!'</span>,</div><div class="line">    ru: <span class="string">'Привет мир!'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// file hello.js</span></div><div class="line">app.writeHello = <span class="function"><span class="keyword">function</span> (<span class="params">lang</span>) </span>&#123;</div><div class="line">    <span class="built_in">document</span>.write(app.helloInLang[lang]);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可见，所有的逻辑和数据都被放在了app对象的属性中，所以不会污染其他全局变量。尽管该模式看似让代码组织有了一定的规律，但是很明显上面的数据和逻辑仍然没有被隔离，我们很轻易就可以修改这些代码。</p>
<h4 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h4><p>模块模式的主旨是将数据和逻辑代码放在闭包中并提供一些公用方法作为对外接口对这些资源进行访问<a href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html" target="_blank" rel="external">JavaScript Module Pattern: In-Depth</a>。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> greeting = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> <span class="built_in">module</span> = &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> helloInLang = &#123;</div><div class="line">        en: <span class="string">'Hello world!'</span>,</div><div class="line">        es: <span class="string">'¡Hola mundo!'</span>,</div><div class="line">        ru: <span class="string">'Привет мир!'</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="built_in">module</span>.getHello = <span class="function"><span class="keyword">function</span> (<span class="params">lang</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> helloInLang[lang];</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="built_in">module</span>.writeHello = <span class="function"><span class="keyword">function</span> (<span class="params">lang</span>) </span>&#123;</div><div class="line">        <span class="built_in">document</span>.write(<span class="built_in">module</span>.getHello(lang))</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="built_in">module</span>;</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<p>这种将数据和逻辑闭包在立即调用方法中的方式在2008年Douglas Crockford发表的《JavaScript the Good Parts》一书中被称作“模块”。</p>
<h4 id="模板定义依赖（Template-Defined-Dependencies"><a href="#模板定义依赖（Template-Defined-Dependencies" class="headerlink" title="模板定义依赖（Template Defined Dependencies)"></a>模板定义依赖（Template Defined Dependencies)</h4><p>当有多个script文件依赖时，我们可以使用一个模板来将这些依赖进行顺序管理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file app.tmp.js</span></div><div class="line"></div><div class="line"><span class="comment">/*borschik:include:../lib/main.js*/</span></div><div class="line"><span class="comment">/*borschik:include:../lib/helloInLang.js*/</span></div><div class="line"><span class="comment">/*borschik:include:../lib/writeHello.js*/</span></div><div class="line"></div><div class="line"><span class="comment">// file main.js</span></div><div class="line"><span class="keyword">var</span> app = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// file helloInLang.js</span></div><div class="line">app.helloInLang = &#123;</div><div class="line">    en: <span class="string">'Hello world!'</span>,</div><div class="line">    es: <span class="string">'¡Hola mundo!'</span>,</div><div class="line">    ru: <span class="string">'Привет мир!'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// file writeHello.js</span></div><div class="line">app.writeHello = <span class="function"><span class="keyword">function</span> (<span class="params">lang</span>) </span>&#123;</div><div class="line">    <span class="built_in">document</span>.write(app.helloInLang[lang]);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="注释定义依赖"><a href="#注释定义依赖" class="headerlink" title="注释定义依赖"></a>注释定义依赖</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file helloInLang.js</span></div><div class="line"><span class="keyword">var</span> helloInLang = &#123;</div><div class="line">    en: <span class="string">'Hello world!'</span>,</div><div class="line">    es: <span class="string">'¡Hola mundo!'</span>,</div><div class="line">    ru: <span class="string">'Привет мир!'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// file sayHello.js</span></div><div class="line"></div><div class="line"><span class="comment">/*! lazy require scripts/app/helloInLang.js */</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">lang</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> helloInLang[lang];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// file hello.js</span></div><div class="line"></div><div class="line"><span class="comment">/*! lazy require scripts/app/sayHello.js */</span></div><div class="line"></div><div class="line"><span class="built_in">document</span>.write(sayHello(<span class="string">'en'</span>));</div></pre></td></tr></table></figure>
<p>这种依赖的工作方式是：首先下载这些依赖文件，并进行文件内容解析，解析到有依赖存在的注释时迭代下载、解析……</p>
<h4 id="外部定义依赖"><a href="#外部定义依赖" class="headerlink" title="外部定义依赖"></a>外部定义依赖</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file deps.json</span></div><div class="line">&#123;</div><div class="line">    <span class="string">"files"</span>: &#123;</div><div class="line">        <span class="string">"main.js"</span>: [<span class="string">"sayHello.js"</span>],</div><div class="line">        <span class="string">"sayHello.js"</span>: [<span class="string">"helloInLang.js"</span>],</div><div class="line">        <span class="string">"helloInLang.js"</span>: []</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// file helloInLang.js</span></div><div class="line"><span class="keyword">var</span> helloInLang = &#123;</div><div class="line">    en: <span class="string">'Hello world!'</span>,</div><div class="line">    es: <span class="string">'¡Hola mundo!'</span>,</div><div class="line">    ru: <span class="string">'Привет мир!'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// file sayHello.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">lang</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> helloInLang[lang];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// file main.js</span></div><div class="line"><span class="built_in">console</span>.log(sayHello(<span class="string">'en'</span>));</div></pre></td></tr></table></figure>
<p>deps.json文件就是我们定义所有依赖的外部上下文依赖文件。当运行这个应用时，加载器会获取到这个文件，将这个文件中的依赖按照数组的正确顺序进行读取和加载。lodash就是使用的这种方法进行依赖加载的。</p>
<h4 id="沙箱模式"><a href="#沙箱模式" class="headerlink" title="沙箱模式"></a>沙箱模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file sandbox.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sandbox</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> modules = [];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> Sandbox.modules) &#123;</div><div class="line">        modules.push(i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; modules.length; i++) &#123;</div><div class="line">        <span class="keyword">this</span>[modules[i]] = Sandbox.modules[modules[i]]();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    callback(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// file greeting.js</span></div><div class="line">Sandbox.modules = Sandbox.modules || &#123;&#125;;</div><div class="line"></div><div class="line">Sandbox.modules.greeting = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> helloInLang = &#123;</div><div class="line">        en: <span class="string">'Hello world!'</span>,</div><div class="line">        es: <span class="string">'¡Hola mundo!'</span>,</div><div class="line">        ru: <span class="string">'Привет мир!'</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        sayHello: <span class="function"><span class="keyword">function</span> (<span class="params">lang</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> helloInLang[lang];</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// file app.js</span></div><div class="line"><span class="keyword">new</span> Sandbox(<span class="function"><span class="keyword">function</span>(<span class="params">box</span>) </span>&#123;</div><div class="line">    <span class="built_in">document</span>.write(box.greeting.sayHello(<span class="string">'es'</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>该模式的关键是使用一个全局的构造函数来代替全局对象，依赖模块可以被定义为这个构造函数的属性。</p>
<h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file greeting.js</span></div><div class="line">angular.module(<span class="string">'greeter'</span>, [])</div><div class="line">    .value(<span class="string">'greeting'</span>, &#123;</div><div class="line">        helloInLang: &#123;</div><div class="line">            en: <span class="string">'Hello world!'</span>,</div><div class="line">            es: <span class="string">'¡Hola mundo!'</span>,</div><div class="line">            ru: <span class="string">'Привет мир!'</span></div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        sayHello: <span class="function"><span class="keyword">function</span>(<span class="params">lang</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.helloInLang[lang];</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"><span class="comment">// file app.js</span></div><div class="line">angular.module(<span class="string">'app'</span>, [<span class="string">'greeter'</span>])</div><div class="line">    .controller(<span class="string">'GreetingController'</span>, [<span class="string">'$scope'</span>, <span class="string">'greeting'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$scope, greeting</span>) </span>&#123;</div><div class="line">        $scope.phrase = greeting.sayHello(<span class="string">'en'</span>);</div><div class="line">    &#125;]);</div></pre></td></tr></table></figure>
<h4 id="CommonJS-Modules"><a href="#CommonJS-Modules" class="headerlink" title="CommonJS Modules"></a>CommonJS Modules</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file greeting.js</span></div><div class="line"><span class="keyword">var</span> helloInLang = &#123;</div><div class="line">    en: <span class="string">'Hello world!'</span>,</div><div class="line">    es: <span class="string">'¡Hola mundo!'</span>,</div><div class="line">    ru: <span class="string">'Привет мир!'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sayHello = <span class="function"><span class="keyword">function</span> (<span class="params">lang</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> helloInLang[lang];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports.sayHello = sayHello;</div><div class="line"></div><div class="line"><span class="comment">// file hello.js</span></div><div class="line"><span class="keyword">var</span> sayHello = <span class="built_in">require</span>(<span class="string">'./lib/greeting'</span>).sayHello;</div><div class="line"><span class="keyword">var</span> phrase = sayHello(<span class="string">'en'</span>);</div><div class="line"><span class="built_in">console</span>.log(phrase);</div></pre></td></tr></table></figure>
<p>CommonJS使用require和module两个标志来表示依赖的引入和导出。</p>
<h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file lib/greeting.js</span></div><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> helloInLang = &#123;</div><div class="line">        en: <span class="string">'Hello world!'</span>,</div><div class="line">        es: <span class="string">'¡Hola mundo!'</span>,</div><div class="line">        ru: <span class="string">'Привет мир!'</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        sayHello: <span class="function"><span class="keyword">function</span> (<span class="params">lang</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> helloInLang[lang];</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// file hello.js</span></div><div class="line">define([<span class="string">'./lib/greeting'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">greeting</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> phrase = greeting.sayHello(<span class="string">'en'</span>);</div><div class="line">    <span class="built_in">document</span>.write(phrase);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
        
        </div>

        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://keefe.wang/2020/01/12/2020-01-12-Javascript-module-history.html" data-id="ckk4rtiie001dfv90p6uuo8ga" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
    
</article>

        
            <article id="post-2020-01-09-how-to-be-a-pragmatic-programmer" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        <div class="article-corner"></div>
        

        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2020/01/09/2020-01-09-how-to-be-a-pragmatic-programmer.html">怎样做一个Pragmatic Programmer</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2020/01/09/2020-01-09-how-to-be-a-pragmatic-programmer.html">
            <time datetime="2020-01-09T04:30:00.000Z" itemprop="datePublished">2020-01-09</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Reading/">Reading</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>, <a class="tag-link" href="/tags/规范/">规范</a>, <a class="tag-link" href="/tags/读书笔记/">读书笔记</a>
    </div>

                    </div>
                
            </header>
        

        

        <div class="article-entry" itemprop="articleBody">

        
            
            <h4 id="What-maks-a-pragmatic-programmer"><a href="#What-maks-a-pragmatic-programmer" class="headerlink" title="What maks a pragmatic programmer"></a>What maks a pragmatic programmer</h4><p>1.Early adopter/faster adapter: 善于学习新的技术并能够尝试将其集成在自己的知识库中;<br>2.Inquisitive：善于提问、保持好奇心；<br>3.Critical thinker：辩证地看待问题而非一味接受前人的话语；<br>4.Realistic：发觉问题的本质，认识问题的难度并能估计解决该问题的时间；<br>5.Jack of all trades：能够转移领域之后快速适应，通过掌握核心基础知识；<br>6.We who cut mere stones must always be envisioning cathedrals.<br>7.持续以上过程</p>
<h4 id="TIPs"><a href="#TIPs" class="headerlink" title="TIPs"></a>TIPs</h4><p>Tip1.在乎你所做的事情<br>Tip2.不断思考所做的事情，不断从big picture进行思考<br>Tip3.提供解决方案而非各种借口<br>Tip4.“不留一扇破窗”，一旦发现问题及时修复<br>Tip5.做项目的催化剂，吸引资源到一个可预见成功的项目中<br>Tip6.时刻牢记“蓝图”<br>Tip7.将产品质量作为需求之一进行考量<br>Tip8.定期对知识进行投资<br>Tip9.批判地看待自己的所见所闻</p>
<h4 id="持续进行知识投资"><a href="#持续进行知识投资" class="headerlink" title="持续进行知识投资"></a>持续进行知识投资</h4><p>1.定期地进行知识投资<br>2.注重知识的多样性<br>3.在2的基础上注意控制风险<br>4.在一个技术还未成熟前进行学习<br>5.时常对知识库进行review</p>
<h5 id="e-g"><a href="#e-g" class="headerlink" title="e.g."></a>e.g.</h5><p>1.一年至少学习一种新的语言<br>2.一个季度看一本技术书籍（甚至一个月、可涉及非技术例如用户等）<br>3.上课<br>4.参与到用户群体中<br>5.在不同环境中进行试验<br>6.跟上潮流：订阅杂志或期刊</p>

        
        </div>

        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://keefe.wang/2020/01/09/2020-01-09-how-to-be-a-pragmatic-programmer.html" data-id="ckk4rtiic0017fv90xc7odo8i" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
    
</article>

        
            <article id="post-2019-12-21-clean-code-note" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        <div class="article-corner"></div>
        

        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2019/12/21/2019-12-21-clean-code-note.html">Clean Code规范整理</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2019/12/21/2019-12-21-clean-code-note.html">
            <time datetime="2019-12-21T03:30:00.000Z" itemprop="datePublished">2019-12-21</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Reading/">Reading</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>, <a class="tag-link" href="/tags/规范/">规范</a>, <a class="tag-link" href="/tags/读书笔记/">读书笔记</a>
    </div>

                    </div>
                
            </header>
        

        

        <div class="article-entry" itemprop="articleBody">

        
            
            <h4 id="变量："><a href="#变量：" class="headerlink" title="变量："></a>变量：</h4><pre><code>1.变量名有意义
2.不使用魔法数字
3.参数用变量而不是数字
4.mapping中的iterator变量命名清楚
5.属性中不要出现类名/对象名
6.方法参数使用默认值检查参数是否为undefined
</code></pre><h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><pre><code>1.使用一到两个形参（或方法复杂、使用对象类型参数、形参的解构赋值）
2.一个方法应该只做一件事！
3.方法名要能自我解释
4.如果出现重复的代码要精练和抽象
5.使用Object.assign给对象赋值
6.（如果方法中出现flag，应当分成两个方法处理）
7.尽量避免方法的副作用（更改全局变量、多个方法写一个文件、公用一个状态等）
8.处理数组、对象时最好处理其复本
9.修改原生对象和方法最好使用class新建
10.尽量使用函数式编程代替命令式编程
11.存在多个判断条件时用方法来包括，避免使用非类型条件
12.避免使用条件语句，使用多态性（class）来代替
13.避免类型判断
</code></pre><h4 id="对象与数据结构"><a href="#对象与数据结构" class="headerlink" title="对象与数据结构"></a>对象与数据结构</h4><pre><code>1.使用class来实现继承
2.使用链式方法调用
3.谨慎使用继承（仅在以下三种情况使用）：
    a.关系为is-a而不是has-a的时候
    b.基类可以被复用时
    c.想通过更改基类来进行全局属性的改变时
</code></pre><h4 id="SOLID原则"><a href="#SOLID原则" class="headerlink" title="SOLID原则"></a>SOLID原则</h4><pre><code>1.SRP（单一职责）：一个类要足够内聚，负责尽量单一的功能，减少类的改动；
2.OCP（开闭原则）：对扩展开放，对修改封闭；
3.LSP（里式替换）：父类特性在子类中要完全继承无变化，即在父类对象被替换为子类对象时无影响；
4.ISP（接口隔离）：不同接口之间需要进行隔离；
5.DIP（依赖倒置）：高层模块不能依赖底层模块，应都依赖于抽象；
</code></pre><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><pre><code>1.用Promises，不用回调函数callbacks（用async/await更好）
</code></pre><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><pre><code>1.不确定的代码需要try...catch...
2.不要忘了catch里的错误处理、reject里的错误处理
</code></pre><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><pre><code>1.驼峰、下划线、大小写都需要保持一致
</code></pre>
        
        </div>

        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://keefe.wang/2019/12/21/2019-12-21-clean-code-note.html" data-id="ckk4rtiia0015fv9098x3fo5k" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
    
</article>

        
            <article id="post-2019-12-01-Vue-source-code-reading-data-binding" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        <div class="article-corner"></div>
        

        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2019/12/01/2019-12-01-Vue-source-code-reading-data-binding.html">源码阅读 - Vue的数据响应式原理</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2019/12/01/2019-12-01-Vue-source-code-reading-data-binding.html">
            <time datetime="2019-12-01T02:00:00.000Z" itemprop="datePublished">2019-12-01</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/SourceCodeReading/">SourceCodeReading</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>, <a class="tag-link" href="/tags/VUE/">VUE</a>, <a class="tag-link" href="/tags/数据响应/">数据响应</a>, <a class="tag-link" href="/tags/源码学习/">源码学习</a>
    </div>

                    </div>
                
            </header>
        

        

        <div class="article-entry" itemprop="articleBody">

        
            
            <h3 id="什么是数据响应式"><a href="#什么是数据响应式" class="headerlink" title="什么是数据响应式"></a>什么是数据响应式</h3><blockquote>
<p>Vue.js 一个核心思想是数据驱动。所谓数据驱动，是指视图是由数据驱动生成的，我们对视图的修改，不会直接操作 DOM，而是通过修改数据。——<a href="https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/" target="_blank" rel="external">《Vue.js技术揭秘》</a></p>
</blockquote>
<p>没有像 Vue 和 React 这些具有数据响应式特性的前端框架之前，我们从服务端提供过的接口获取到数据要渲染在 html 页面上时，抑或是需要获取表单的值进行计算回显到页面上时，都需要建立很多 DOM 事件监听器，并进行许多的 DOM 操作。举个最简单的例子：用户在 html 页面的表单中输入两个加数 a 和 b ，计算得到两个加数之和，并展示到页面上。这时我们需要监听表单中 a 和 b 两个输入框的变化，拿到变化值相加然后通过修改指定 id 或者 class 的选择器对应的 DOM 来修改两数之和。但是当输入表单不止两个时，就会令人捉急。</p>
<p>而 Vue 的数据响应式大大地优化了这一整套的流程。面对大量的 UI 交互和数据更新，数据响应式让我们做到从容不迫——我们需要去了解数据的改变是怎样被触发，更新触发后的数据改变又是怎样反馈到视图。接下来我们通过对部分 Vue 源码的简单分析和学习来深入了解 Vue 中的数据响应式是怎样实现的。</p>
<p>我们将这一部分的代码分析大致分为三部分：让数据变成响应式、依赖收集和派发更新。</p>
<h3 id="数据响应式的中心思想"><a href="#数据响应式的中心思想" class="headerlink" title="数据响应式的中心思想"></a>数据响应式的中心思想</h3><p><img src="https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiMWVmM2MyOWMtYzg4YS00ZDI0LTllYjMtYTUwMmZhNmMwODM0IiwicmVzb3VyY0d1aWQiOiI2MTI4MTIwZS1kNWUxLTQxZDgtODFkOS1hNTIyNWM1ODM4Y2MifQ==" alt="5de7af21d4c2de951720c006f84b98fc.png"></p>
<p>该原理图源自 Vue 官方教程的<a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="external">深入响应式原理</a>，这张图向我们展示了 Vue 的数据响应式的中心思想。</p>
<p>我们先来介绍图中的四个模块，<strong>黄色部分</strong>是 Vue 的渲染方法，视图初始化和视图更新时都会调用 <code>vm._render</code> 方法进行重新渲染。渲染时不可避免地会 touch 到每个需要展示到视图上的数据（<strong>紫色部分</strong>），触发这些数据的 get 方法从而收集到本次渲染的所有依赖。收集依赖和更新派发都是基于<strong>蓝色部分</strong>的 Watcher 观察者。而当我们在修改这些收集到依赖的数据时，会触发数据中的 set 属性方法，该方法会修改数据的值并 notify 到依赖到它的观察者，从而触发视图的重新渲染。<strong>绿色部分</strong>是渲染过程中生成的 Virtual DOM Tree，这棵树不仅关系到视图渲染，更是 Vue 优化视图更新过程的基础。</p>
<h3 id="让数据变成响应式"><a href="#让数据变成响应式" class="headerlink" title="让数据变成响应式"></a>让数据变成响应式</h3><p>基本上大家都了解 Vue 的数据响应式原理是由 JS标准内置对象方法 <strong>Object.defineProperty</strong> 来实现的，而这个方法是<strong>不兼容IE8和FF22及以下版本</strong>的浏览器的，所以 Vue 也只能在这些版本之上的浏览器中才能正常使用。这个方法的作用是直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。那么数据响应式用这个方法为<strong>什么对象</strong>添加或修改了<strong>什么属性</strong>呢？我们从 Vue 的初始化讲起。</p>
<p><img src="https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiMWVmM2MyOWMtYzg4YS00ZDI0LTllYjMtYTUwMmZhNmMwODM0IiwicmVzb3VyY0d1aWQiOiIzZTI1NmNmOS1iOWQ4LTRlYjQtOWJiMy1iNTI4ZDU3MWZlYmMifQ==" alt="99d9a00af95016a8e9b0b558fd4249ab.png"></p>
<h4 id="Vue-的初始化"><a href="#Vue-的初始化" class="headerlink" title="Vue 的初始化"></a>Vue 的初始化</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="keyword">this</span>._init(options)</div><div class="line">&#125;</div><div class="line">initMixin(Vue)     </div><div class="line">stateMixin(Vue)     </div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</div></pre></td></tr></table></figure>
<p>在 <a href="https://github.com/DQFE/vue/blob/dev/src/core/index.js#L1" target="_blank" rel="external"><em>src/core/index.js</em></a> 中我们可以看到一个 Vue 被导出，这个Vue是在 <em>src/core/instance/index</em> 中定义的，Vue 是一个方法，参数是options，我们大胆猜想这个 Vue 就是进行 vue 实例化的方法，而 options 就是我们传入的 data、computed、methods 等属性。这个 Vue 方法中主要调用了 _init 方法，这个方法是在 initMixin 方法调用时定义在 Vue 原型上的一个方法，_init 方法中对当前传入的 options 进行了一些处理（主要是判断当前实例化的是否为组件，使用 mergeOptions 方法对 options 进行加工，此处不做赘述），然后又调用了一系列方法进行了生命周期、事件、渲染器的初始化，我们主要来关注 <strong>initState</strong> 这个方法（<a href="https://github.com/DQFE/vue/blob/dev/src/core/instance/state.js#L48" target="_blank" rel="external"><em>src/core/instance/state.js</em></a>）:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm: Component</span>) </span>&#123;</div><div class="line">    vm._watchers = []</div><div class="line">    <span class="keyword">const</span> opts = vm.$options</div><div class="line">    <span class="keyword">if</span> (opts.props) initProps(vm, opts.props)</div><div class="line">    <span class="keyword">if</span> (opts.methods) initMethods(vm, opts.methods)</div><div class="line">    <span class="comment">// a*</span></div><div class="line">    <span class="keyword">if</span> (opts.data) &#123;</div><div class="line">        initData(vm)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed)</div><div class="line">    <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</div><div class="line">        initWatch(vm, opts.watch)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="将-Vue-实例上的-data-响应式化"><a href="#将-Vue-实例上的-data-响应式化" class="headerlink" title="将 Vue 实例上的 data 响应式化"></a>将 Vue 实例上的 data 响应式化</h4><p>上面的方法中对props、methods、data、computed和watch进行了初始化，这些都是Vue实例化方法中传入参数options对象的一些属性，这些属性都需要被<strong>响应式化</strong>。而针对于data的初始化分了两种情况[a<em>]，一种是options中没有data属性的，该方法会给data赋值一个空对象并进行observe（该方法之后我们会详细讲述），如果有data属性，则调用[<em>*initData</em></em>](<a href="https://github.com/DQFE/vue/blob/dev/src/core/instance/state.js#L112)方法进行初始化。我们主要通过对data属性的初始化来分析Vue中的数据响应式原理。" target="_blank" rel="external">https://github.com/DQFE/vue/blob/dev/src/core/instance/state.js#L112)方法进行初始化。我们主要通过对data属性的初始化来分析Vue中的数据响应式原理。</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span> (<span class="params">vm: Component</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> data = vm.$options.data</div><div class="line">    <span class="comment">// a*</span></div><div class="line">    data = vm._data = <span class="keyword">typeof</span> data === <span class="string">'function'</span></div><div class="line">    ? getData(data, vm)</div><div class="line">    : data || &#123;&#125;</div><div class="line">    <span class="keyword">if</span> (!isPlainObject(data)) &#123;</div><div class="line">        data = &#123;&#125;</div><div class="line">        process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</div><div class="line">          <span class="string">'data functions should return an object:\n'</span> +</div><div class="line">          <span class="string">'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function'</span>,</div><div class="line">          vm</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// b*</span></div><div class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data)</div><div class="line">    <span class="keyword">const</span> props = vm.$options.props</div><div class="line">    <span class="keyword">const</span> methods = vm.$options.methods</div><div class="line">    <span class="keyword">let</span> i = keys.length</div><div class="line">    <span class="keyword">while</span> (i--) &#123;</div><div class="line">        <span class="comment">// c*</span></div><div class="line">        <span class="keyword">const</span> key = keys[i]</div><div class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">          <span class="keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;</div><div class="line">            warn(</div><div class="line">              <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" has already been defined as a data property.`</span>,</div><div class="line">              vm</div><div class="line">            )</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</div><div class="line">          process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</div><div class="line">            <span class="string">`The data property "<span class="subst">$&#123;key&#125;</span>" is already declared as a prop. `</span> +</div><div class="line">            <span class="string">`Use prop default value instead.`</span>,</div><div class="line">            vm</div><div class="line">          )</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isReserved(key)) &#123;</div><div class="line">          proxy(vm, <span class="string">`_data`</span>, key)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// d*</span></div><div class="line">    observe(data, <span class="literal">true</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>initData 方法对 options 中的 data 进行处理，主要是有<strong>两个目的</strong>:</p>
<ul>
<li>一方面<strong>将 data 代理到 Vue 实例上</strong>，同时检查 data 中是否使用了 Vue 中的保留字、是否与 props、methods 属性中的数据同名</li>
<li>使用 <strong>observe</strong> 方法将data中的属性变成响应式的</li>
</ul>
<p>之前我们提到在调用 initState 方法之前会有对 Vue 实例化传入的 options 参数进行处理的环节（mergeOptions），这个过程会将 data 处理成一个函数（例如我们在 vue 组件中的 data 属性），之后会调用 <code>callHook(vm, &#39;beforeCreate&#39;)</code> 方法来触发 beforeCreate 的生命周期钩子，这个方法的调用可能会对 data 属性进行进一步处理，所以方法一开始会<strong>对 data 统一做处理使其成为一个function</strong>[a*]。</p>
<p>接下来会对 data 中的每一个数据进行遍历[b<em>]，遍历过程将会使用  <code>hasOwn(methods, key)</code>、<code>hasOwn(props, key)</code>、<code>!isReserved(key)</code> 方法对该数据是否占用保留字、是否与 props 和 methods 中的属性重名进行判断，然后调用 proxy 方法将其代理到 Vue 实例上。此处需要注意的是：<em>*如果 data 中的属性与 props、methods 中的属性重名，那么在 Vue 实例上调用这个属性时的优先级顺序是 props &gt; methods &gt; data</em></em>。</p>
<p>最后对每一个 data 中的属性调用 <code>observe</code> 方法，该方法的功能是赋予 data 中的属性可被监测的特性。这个方法和其中使用到的 Observe 类是在<a href="https://github.com/DQFE/vue/blob/dev/src/core/observer/index.js#L37" target="_blank" rel="external"><em>src/core/observer/index.js</em></a>文件中，observe 方法主要是调用<strong>Observer类构造方法</strong>，将每一个 data中的 value 变成可观察、响应式的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constructor</span> (value: any) &#123;</div><div class="line">    <span class="keyword">this</span>.value = value</div><div class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</div><div class="line">    <span class="keyword">this</span>.vmCount = <span class="number">0</span></div><div class="line">    </div><div class="line">    def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</div><div class="line">      <span class="comment">//...</span></div><div class="line">      <span class="keyword">this</span>.observeArray(value)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">this</span>.walk(value)</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到该构造函数有以下几个目的：</p>
<ul>
<li>针对当前的数据对象新建一个订阅器；</li>
<li>为每个数据的value都添加一个<strong>ob</strong>属性，该属性不可枚举并指向自身；</li>
<li>针对数组类型的数据进行单独处理（包括赋予其数组的属性和方法，以及 observeArray 进行的数组类型数据的响应式）；</li>
<li>this.walk(value)，遍历对象的 key 调用 defineReactive 方法；</li>
</ul>
<p><code>defineReactive</code>是真正为数据添加 get 和 set 属性方法的方法，它将 data 中的数据定义一个响应式对象，并给该对象设置 get 和 set 属性方法，其中 get 方法是对依赖进行收集， set 方法是当数据改变时通知 Watcher 派发更新。</p>
<h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><p>依赖收集的原理是：当视图被渲染时，会触发渲染中所使用到的数据的 get 属性方法，通过 get 方法进行依赖收集。</p>
<p>其真实的逻辑我们举例来说明：当前正在渲染组件 ComponentA，会将当前全局唯一的监听器置为这个 Watcher，这个组件中使用到了数据 <code>data () { return { a: b + 1} }</code>，此时触发b的 getter 会将当前的 watcher 添加到b的订阅者列表 subs 中。也就是说如果 ComponentA 依赖 b，则将该组件的渲染 Watcher 作为订阅者加入b的订阅者列表中。</p>
<p><img src="https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiMWVmM2MyOWMtYzg4YS00ZDI0LTllYjMtYTUwMmZhNmMwODM0IiwicmVzb3VyY0d1aWQiOiJkZjIxMjIzYi0zN2NkLTQyNTgtOTVhYi02NjM4MzNkZjFlZTIifQ==" alt="1e9dfeb2187b782e42b78196a723f860.jpeg"></p>
<p>我们先看下 <a href="https://github.com/DQFE/vue/blob/dev/src/core/observer/index.js#L160" target="_blank" rel="external">get</a> 属性方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> value = getter ? getter.call(obj) : val</div><div class="line">  <span class="keyword">if</span> (Dep.target) &#123;</div><div class="line">    dep.depend()</div><div class="line">    <span class="keyword">if</span> (childOb) &#123;</div><div class="line">      childOb.dep.depend()</div><div class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</div><div class="line">        dependArray(value)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> value</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Dep-订阅器"><a href="#Dep-订阅器" class="headerlink" title="Dep - 订阅器"></a>Dep - 订阅器</h4><p>数据对象中的 get 方法主要使用 depend 方法进行依赖收集，该方法是 Dep 类中的属性方法，继续来看 <a href="https://github.com/DQFE/vue/blob/dev/src/core/observer/dep.js#L13" target="_blank" rel="external">Dep 类</a>是怎样实现的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</div><div class="line">    <span class="comment">// a*</span></div><div class="line">    <span class="keyword">static</span> target: ?Watcher;</div><div class="line">    id: number;</div><div class="line">    subs: <span class="built_in">Array</span>&lt;Watcher&gt;;</div><div class="line">    <span class="keyword">constructor</span> () &#123;</div><div class="line">        <span class="keyword">this</span>.id = uid++</div><div class="line">        <span class="keyword">this</span>.subs = []</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    addSub (sub: Watcher) &#123;</div><div class="line">        <span class="keyword">this</span>.subs.push(sub)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    depend () &#123;</div><div class="line">        <span class="keyword">if</span> (Dep.target) &#123;</div><div class="line">            Dep.target.addDep(<span class="keyword">this</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Dep.target = <span class="literal">null</span></div><div class="line"><span class="keyword">const</span> targetStack = []</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span> (<span class="params">target: ?Watcher</span>) </span>&#123;</div><div class="line">    targetStack.push(target)</div><div class="line">    Dep.target = target</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">popTarget</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    targetStack.pop()</div><div class="line">    Dep.target = targetStack[targetStack.length - <span class="number">1</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Dep 类中有三个属性：<code>target</code>、<code>id</code> 和 <code>subs</code>，分别表示当前全局唯一的静态数据依赖的监听器 Watcher、该属性的 id 以及订阅这个属性数据的订阅者列表[a*]。另外还提供了将订阅者添加到订阅者列表的 <code>addSub方法</code>、从订阅者列表删除订阅者的 <code>removeSub</code> 方法。</p>
<p><code>Dep.target</code> 是当前全局唯一的订阅者，这是因为同一时间只允许一个订阅者被处理。target 的意思就是指当前正在处理的目标订阅者，而这个订阅者是有一个订阅者栈 <code>targetStack</code>，当某一个组件执行到某个生命周期的 hook 时（例如 mountComponent），会将当前目标订阅者 target 置为这个 watcher，并将其压入 <code>targetStack</code> 栈顶。</p>
<p>接下来是添加当前数据依赖的 <code>depend方法</code>，<code>Dep.target</code> 对象是一个 Watcher 类的实例，调用 Watcher 类的 <a href="https://github.com/DQFE/vue/blob/dev/src/core/observer/watcher.js#L128" target="_blank" rel="external">addDep 方法</a>，我们看下 addDep 方法将当前的依赖 Dep 实例放在了哪里：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">addDep (dep: Dep) &#123;</div><div class="line">    <span class="keyword">const</span> id = dep.id</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</div><div class="line">        <span class="keyword">this</span>.newDepIds.add(id)</div><div class="line">        <span class="keyword">this</span>.newDeps.push(dep)</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</div><div class="line">            dep.addSub(<span class="keyword">this</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们稍后会对 Watcher 类进行分析，目前先来简单看下 addDep 这个属性方法做了什么。可以看到入参是一个 Dep 类实例，这个实例实际上是当前全局唯一的订阅者，newDepIds 是当前数据依赖 dep 的 id 列表，newDeps 是当前数据依赖 dep 列表，depsId 则是上一个 tick 的数据依赖的 id 列表。这个方法主要的逻辑就是调用当前数据依赖 dep 的类方法 <code>addSub</code>，而这个方法在上面Dep 类方法中可以看到，就是将当前全局唯一的 watcher 实例放入这个数据依赖的订阅者列表中。</p>
<h4 id="target-Watcher的产生"><a href="#target-Watcher的产生" class="headerlink" title="target Watcher的产生"></a>target Watcher的产生</h4><p>我们以生命周期中的 <a href="https://github.com/DQFE/vue/blob/dev/src/core/instance/lifecycle.js#L141" target="_blank" rel="external">mountComponent</a> 这一个阶段为例来分析上面提到的Dep.target 这个全局唯一的当前订阅者 Watcher 是怎样产生的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">    vm: Component, </span></span></div><div class="line"><span class="function"><span class="params">    el: ?Element, hydrating?: boolean</span></span></div><div class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="keyword">let</span> updateComponent</div><div class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123; </div><div class="line">        updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 首次渲染视图会进入，生成虚拟Node，更新DOM&#125;</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 数据更新时会进入，调用渲染函数对视图进行更新</span></div><div class="line">        vm._update(vm._render(), hydrating)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</div><div class="line">        before () &#123;</div><div class="line">            <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</div><div class="line">                callHook(vm, <span class="string">'beforeUpdate'</span>)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="keyword">return</span> vm</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过mountComponent的代码可以看到在触发了<code>beforeMount</code>生命周期钩子后，紧接着创建了一个用于渲染Watcher实例。我们通过Watcher类的构造函数来看创建<a href="https://github.com/DQFE/vue/blob/dev/src/core/observer/watcher.js#L45" target="_blank" rel="external">Watcher</a>实例时做了哪些工作：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constructor</span> (</div><div class="line">    vm: Component,              // 当前渲染的组件</div><div class="line">    expOrFn: string | Function,  // 当前Watcher实例的getter属性方法</div><div class="line">    cb: Function,               // 回调函数</div><div class="line">    options?: ?Object,          // 手动传入watch时的option</div><div class="line">    isRenderWatcher?: boolean    // 是否为渲染watcher的标识</div><div class="line">  ) &#123;</div><div class="line">    <span class="keyword">this</span>.vm = vm</div><div class="line">    <span class="keyword">if</span> (isRenderWatcher) &#123;</div><div class="line">        vm._watcher = <span class="keyword">this</span></div><div class="line">    &#125;</div><div class="line">    vm._watchers.push(<span class="keyword">this</span>)</div><div class="line">    <span class="comment">// 此处处理我们传入的watcher参数（在组件内手动新建watch属性）</span></div><div class="line">    <span class="keyword">if</span> (options) &#123;&#125; <span class="keyword">else</span> &#123;&#125;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="comment">// parse expression for getter</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">'function'</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.getter = expOrFn</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">this</span>.getter = parsePath(expOrFn)</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.getter) &#123;</div><div class="line">            <span class="keyword">this</span>.getter = noop</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy ? <span class="literal">undefined</span> : <span class="keyword">this</span>.get()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过 Watcher 类的构造函数传参可以看到 mountComponent 生命周期中创建的 Watcher 是一个渲染 Watcher，将当前的 getter 设置为了 updateComponent 方法（也就是重新渲染视图的方法），最后调用了 get 属性方法，我们接下来看 <a href="https://github.com/DQFE/vue/blob/dev/src/core/observer/watcher.js#L101" target="_blank" rel="external">get 方法</a>做了什么：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">get () &#123;</div><div class="line">    pushTarget(<span class="keyword">this</span>)</div><div class="line">    <span class="keyword">let</span> value</div><div class="line">    <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        value = <span class="keyword">this</span>.getter.call(vm, vm)</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</div><div class="line">            handleError(e, vm, <span class="string">`getter for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</div><div class="line">        &#125; <span class="keyword">else</span> &#123; <span class="keyword">throw</span> e &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</div><div class="line">            traverse(value)</div><div class="line">        &#125;</div><div class="line">        popTarget()</div><div class="line">        <span class="keyword">this</span>.cleanupDeps()</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> value</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>get 方法首先调用了在 <code>Dep类</code>文件中定义的全局方法 pushTarget，将 Dep.target 置为当前正在执行的渲染 Watcher，并将这个 watcher 压到了 targetStack。接下来调用 wathcer 的 getter 方法：由于此时的 getter 就是 updateComponent 方法，执行 updateComponent 方法，也就是 <code>vm._update(vm._render(), hydrating)</code> 进行渲染，渲染过程中必然会 touch 到 data 中相关依赖的属性，此时就会触发各个属性中的 get 方法（也就是将当前的渲染 Watcher 添加到所有渲染中使用到的数据的依赖列表 subs 中）。</p>
<p>渲染完之后会将当前的渲染 Watcher 从 targetStack 推出，进行下一个 watcher 的任务。最后会进行<em>依赖的清空</em>，每次数据的变化都会引起视图重新渲染，每一次渲染又会进行依赖收集，又会触发 data 中每个属性的 get 方法，这时会有一种情况发生：<code>&lt;div v-if=&quot;someBool&quot;&gt;&lt;/div&gt;&lt;div v-else&gt;&lt;/div&gt;</code> 第一次当 someBool 为真时，进行渲染，当我们把 someBool 的值 update 为 false 时，这时候属性 a 不会被使用，所以如果不进行依赖清空，会导致不必要的依赖通知。依赖清空主要是对 newDeps 进行更新，通过对比本次收集的依赖和之前的依赖进行对比，把不需要的依赖清除。</p>
<h3 id="派发更新"><a href="#派发更新" class="headerlink" title="派发更新"></a>派发更新</h3><p><img src="evernotecid://954D5E79-AC85-4E89-863E-EB8C8DEE61D9/appyinxiangcom/23187233/ENResource/p11" alt="6ff6878b57427d1b0115d669089d54d3.png"></p>
<p>当我们修改一个存在 data 属性上的值时，会触发数据中的 <a href="https://github.com/DQFE/vue/blob/dev/src/core/observer/index.js#L173" target="_blank" rel="external">set 属性方法</a>，首先会判断并修改该属性数据的值，并触发自身的 dep.notify 方法开始更新派发：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> value = getter ? getter.call(obj) : val</div><div class="line">  <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  childOb = !shallow &amp;&amp; observe(newVal)</div><div class="line">  dep.notify()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来让我们进入<a href="https://github.com/DQFE/vue/blob/dev/src/core/observer/dep.js#L37" target="_blank" rel="external"><code>dep.notify</code></a>这个方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">notify () &#123;</div><div class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</div><div class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !config.async) &#123;</div><div class="line">        subs.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</div><div class="line">      subs[i].update()</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>notify 这个方法是每一个数据在响应式化之后自己内部闭包的 dep 实例的方法，还记得之前讲过的 subs 保存着所有订阅该数据的订阅者，所以在 notify 方法中首先对 subs 这个订阅者序列按照其 id 进行了排序。接下来就是调用每一个订阅者 watcher 实例的 <code>update</code> 方法进行更新的派发。update 方法是在 Watcher 类文件中，使用了队列的方式来管理订阅者的更新派发，其中主要调用了 <a href="https://github.com/DQFE/vue/blob/dev/src/core/observer/scheduler.js#L164" target="_blank" rel="external"><code>queueWatcher</code></a> 这个方法来实现该逻辑：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span> (<span class="params">watcher: Watcher</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> id = watcher.id</div><div class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;    <span class="comment">// a*</span></div><div class="line">    has[id] = <span class="literal">true</span></div><div class="line">    <span class="keyword">if</span> (!flushing) &#123;        <span class="comment">// b*</span></div><div class="line">      queue.push(watcher)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">let</span> i = queue.length - <span class="number">1</span></div><div class="line">      <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</div><div class="line">        i--</div><div class="line">      &#125;</div><div class="line">      queue.splice(i + <span class="number">1</span>, <span class="number">0</span>, watcher)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!waiting) &#123;         <span class="comment">// c*</span></div><div class="line">      waiting = <span class="literal">true</span></div><div class="line">      <span class="comment">// ...</span></div><div class="line">      nextTick(flushSchedulerQueue)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>进入该方法后，首先使用一个名为 has 的 Map 来保证每一个 watcher 仅推入队列一次[a<em>]。<code>flushing</code> 这个标识符表示目前这个队列是否正在进行更新派发，如果是，那么将这个 id 对应的订阅者进行替换，如果已经路过这个 id，那么就立刻将这个 id 对应的 watcher 放在下一个排入队列[b</em>]。接下来根据<code>waiting</code> 这个标识符来表示当前是否正在对这个队列进行更新派发[c*]，如果没有的话，就可以调用 <a href="https://github.com/DQFE/vue/blob/dev/src/core/observer/scheduler.js#L71" target="_blank" rel="external"><code>nextTick(flushSchedulerQueue)</code></a> 方法进行真正的更新派发了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSchedulerQueue</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  flushing = <span class="literal">true</span></div><div class="line">  <span class="keyword">let</span> watcher, id</div><div class="line"></div><div class="line">  queue.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)</div><div class="line">  </div><div class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; queue.length; index++) &#123;</div><div class="line">    watcher = queue[index]</div><div class="line">    <span class="keyword">if</span> (watcher.before) &#123;</div><div class="line">      watcher.before()</div><div class="line">    &#125;</div><div class="line">    id = watcher.id</div><div class="line">    has[id] = <span class="literal">null</span></div><div class="line">    watcher.run()</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这个方法首先对队列中的 watcher 按照其 id 进行了排序，排序的主要目的有三：</p>
<ul>
<li>组件的更新由父到子；因为父组件的创建过程是先于子的，所以 watcher 的创建也是先父后子，执行顺序也应该保持先父后子。</li>
<li>用户的自定义 watcher 要优先于渲染 watcher 执行；因为用户自定义 watcher 是在渲染 watcher 之前创建的。</li>
<li>如果一个组件在父组件的 watcher 执行期间被销毁，那么它对应的 watcher 执行都可以被跳过，所以父组件的 watcher 应该先执行。<br>排序结束之后，便对这个队列进行遍历，并执行<code>watcher.run()</code>方法去实现数据更新的通知，run方法的逻辑是：<ul>
<li>新的值与老的值不同时会触发通知；</li>
<li>但是当值是对象或者deep为true时无论如何都会进行通知</li>
</ul>
</li>
</ul>
<p>所以 watcher 有两个功能，一个是将属性的值进行更新，另一个就是可以执行 watch 中的回调函数 handler(newVal, oldVal)，这也是为何我们可以在 watcher 中拿到新旧两个值的原因。</p>
<p>至此，数据的更新派发也通知到了各个组件，便又可以进行视图的更新渲染，收集依赖，派发更新……</p>

        
        </div>

        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://keefe.wang/2019/12/01/2019-12-01-Vue-source-code-reading-data-binding.html" data-id="ckk4rtikd005vfv90abdceuuv" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
    
</article>

        
        <nav id="page-nav">
            <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
        </nav>
    
    </section>

    
    <aside id="sidebar">
   
        
    <div class="widget-wrap">
        <div class="widget-corner"></div>
        <h3 class="widget-title">Recent Posts</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/07/29/2020-07-29-use-vue-test-utils-to-test-components.html" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Document/">Document</a></p>
                            <p class="item-title"><a href="/2020/07/29/2020-07-29-use-vue-test-utils-to-test-components.html" class="title">使用 vue-test-utils 进行测试</a></p>
                            <p class="item-date"><time datetime="2020-07-29T14:23:00.000Z" itemprop="datePublished">2020-07-29</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/07/23/2020-07-23-advanced-function-in-vue.html" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Document/">Document</a></p>
                            <p class="item-title"><a href="/2020/07/23/2020-07-23-advanced-function-in-vue.html" class="title">Vue 高级用法与精粹</a></p>
                            <p class="item-date"><time datetime="2020-07-23T11:32:00.000Z" itemprop="datePublished">2020-07-23</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/07/22/2020-07-22-things-need-to-be-aware-of-in-vue.html" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Document/">Document</a></p>
                            <p class="item-title"><a href="/2020/07/22/2020-07-22-things-need-to-be-aware-of-in-vue.html" class="title">Vue 中容易被忽视的小功能</a></p>
                            <p class="item-date"><time datetime="2020-07-22T11:03:00.000Z" itemprop="datePublished">2020-07-22</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/06/03/2020-06-03-advanced-eventloop-in-javascript.html" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Document/">Document</a></p>
                            <p class="item-title"><a href="/2020/06/03/2020-06-03-advanced-eventloop-in-javascript.html" class="title">JavaScript 基于事件循环的并发模型</a></p>
                            <p class="item-date"><time datetime="2020-06-03T08:31:00.000Z" itemprop="datePublished">2020-06-03</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/05/23/2020-05-30-source-code-reading-Egg-starting.html" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/SourceCodeReading/">SourceCodeReading</a></p>
                            <p class="item-title"><a href="/2020/05/23/2020-05-30-source-code-reading-Egg-starting.html" class="title">EggJS源码阅读-启动流程与代码实现</a></p>
                            <p class="item-date"><time datetime="2020-05-23T04:30:00.000Z" itemprop="datePublished">2020-05-23</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <div class="widget-corner"></div>
        <h3 class="widget-title">Categories</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Document/">Document</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Reading/">Reading</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Research/">Research</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SourceCodeReading/">SourceCodeReading</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Toolkit/">Toolkit</a><span class="category-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <div class="widget-corner"></div>
        <h3 class="widget-title">Archives</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">十二月 2014</a><span class="archive-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <div class="widget-corner"></div>
        <h3 class="widget-title">Tags</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/API/">API</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Babel/">Babel</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3/">CSS3</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6/">ES6</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EggJS/">EggJS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Express/">Express</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Framework/">Framework</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Http/">Http</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">22</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JenaAPI/">JenaAPI</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jupyter/">Jupyter</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Knowledge-Base/">Knowledge Base</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Leaflet/">Leaflet</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Map/">Map</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/">Markdown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NodeJS/">NodeJS</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/">Nodejs</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ontology/">Ontology</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Selector/">Selector</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Test/">Test</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VUE/">VUE</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/原型/">原型</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础知识/">基础知识</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/形状文法/">形状文法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据响应/">数据响应</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则表达式/">正则表达式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码学习/">源码学习</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/继承/">继承</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/腾讯地图/">腾讯地图</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/规范/">规范</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/解释器/">解释器</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/说明书/">说明书</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书笔记/">读书笔记</a><span class="tag-list-count">12</span></li></ul>
        </div>
    </div>

    
        
    
        
    <div class="widget-wrap widget-list">
        <div class="widget-corner"></div>
        <h3 class="widget-title">Links</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://hexo.io">Hexo</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
    
</div>






        <footer id="footer" class="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2021 Keefe Wang<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/sanfran1068">Keefe</a>
        </div>
    </div>
</footer>
        


    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>